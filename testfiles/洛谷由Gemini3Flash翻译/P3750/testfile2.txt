const int maxn = 100010;
const int mod = 10007;

int n;
int k;
int a[maxn];
int cnt = 0;
int f[maxn];

// 快速幂函数
int quick_pow(int x, int p) {
    int an = 1;
    int po = x;
    // 将 while(p) 转换为 for(; p; )
    for (; p; ) {
        if (p % 2) {
            an = (an * po) % mod;
        }
        po = (po * po) % mod;
        p = p / 2;
    }
    return an;
}

int main() {
    n = getint();
    k = getint();
    
    int i;
    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
    }
    
    // 模拟开关灯逻辑
    for (i = n; i >= 1; i = i - 1) {
        if (a[i]) {
            cnt = cnt + 1;
            int j;
            for (j = 1; j * j <= i; j = j + 1) {
                if (i % j == 0) {
                    // SysY不支持 ^= 异或赋值，使用if-else翻转0/1
                    if (a[j]) a[j] = 0; 
                    else a[j] = 1;
                    
                    if (j * j != i) {
                        int idx = i / j;
                        if (a[idx]) a[idx] = 0; 
                        else a[idx] = 1;
                    }
                }
            }
        }
    }
    
    f[n + 1] = 0;
    // DP 计算概率期望
    for (i = n; i >= 1; i = i - 1) {
        int tmp = (n - i) * f[i + 1] % mod;
        tmp = (tmp + n) % mod;
        tmp = tmp * quick_pow(i, mod - 2) % mod;
        f[i] = tmp;
    }
    
    int ans = 0;
    if (cnt <= k) {
        ans = cnt;
    } else {
        for (i = cnt; i > k; i = i - 1) {
            ans = (ans + f[i]) % mod;
        }
        ans = (ans + k) % mod;
    }
    
    for (i = 1; i <= n; i = i + 1) {
        ans = (ans * i) % mod;
    }
    
    printf("%d\n", ans);
    return 0;
}