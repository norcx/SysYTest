/* UVa12264 Risk (scaled/converted)
 * Input format (strict SysY, integers only):
 *   T
 *   For each testcase:
 *     N
 *     A[0..N-1]
 *     adj matrix as N*N ints (0/1), row-major; 1 means 'Y'
 */

const int MAXN = 110;
const int MAXV = 2 * MAXN + 5;
const int MAXE = 50000;
const int INF = 1000000000;

int N;
int A[MAXN];
int adj[MAXN * MAXN];

int head[MAXV];
int to[MAXE];
int cap[MAXE];
int flow[MAXE];
int nxt[MAXE];
int edge_cnt;

int level_[MAXV];
int q_[MAXV];
int cur_[MAXV];

int S_;
int T_;
int V_;

int min2(int a, int b) {
  if (a < b) return a;
  return b;
}

int rev_edge(int e) {
  if (e % 2 == 0) return e + 1;
  return e - 1;
}

void dinic_init(int v) {
  int i;
  V_ = v;
  edge_cnt = 0;
  for (i = 0; i < V_; i = i + 1) head[i] = -1;
}

void dinic_add_edge(int u, int v, int c) {
  to[edge_cnt] = v;
  cap[edge_cnt] = c;
  flow[edge_cnt] = 0;
  nxt[edge_cnt] = head[u];
  head[u] = edge_cnt;
  edge_cnt = edge_cnt + 1;

  to[edge_cnt] = u;
  cap[edge_cnt] = 0;
  flow[edge_cnt] = 0;
  nxt[edge_cnt] = head[v];
  head[v] = edge_cnt;
  edge_cnt = edge_cnt + 1;
}

int dinic_bfs() {
  int i;
  int qh;
  int qt;
  int x;
  int e;
  int y;

  for (i = 0; i < V_; i = i + 1) level_[i] = -1;
  qh = 0;
  qt = 0;
  q_[qt] = S_;
  qt = qt + 1;
  level_[S_] = 0;

  for (; qh < qt; qh = qh + 1) {
    x = q_[qh];
    e = head[x];
    for (; e != -1; e = nxt[e]) {
      y = to[e];
      if (level_[y] < 0 && cap[e] > flow[e]) {
        level_[y] = level_[x] + 1;
        q_[qt] = y;
        qt = qt + 1;
      }
    }
  }

  if (level_[T_] >= 0) return 1;
  return 0;
}

int dinic_dfs(int x, int pushed) {
  int e;
  int y;
  int remaining;
  int ret;
  int f;
  int r;

  if (x == T_ || pushed == 0) return pushed;

  remaining = pushed;
  ret = 0;

  e = cur_[x];
  for (; e != -1; e = nxt[e]) {
    cur_[x] = e;
    y = to[e];
    if (level_[y] == level_[x] + 1 && cap[e] > flow[e]) {
      f = dinic_dfs(y, min2(remaining, cap[e] - flow[e]));
      if (f > 0) {
        flow[e] = flow[e] + f;
        r = rev_edge(e);
        flow[r] = flow[r] - f;
        ret = ret + f;
        remaining = remaining - f;
        if (remaining == 0) break;
      }
    }
  }
  cur_[x] = e;
  return ret;
}

int dinic_maxflow(int s, int t) {
  int total;
  int i;

  S_ = s;
  T_ = t;
  total = 0;

  for (;;) {
    if (dinic_bfs() == 0) break;
    for (i = 0; i < V_; i = i + 1) cur_[i] = head[i];
    total = total + dinic_dfs(S_, INF);
  }

  return total;
}

int is_ok(int m) {
  int i;
  int j;
  int f;
  int sum_f;
  int idx;
  int v;

  v = 2 * N + 2;
  dinic_init(v);
  S_ = 2 * N;
  T_ = S_ + 1;
  sum_f = 0;

  for (i = 0; i < N; i = i + 1) {
    if (A[i] != 0) {
      dinic_add_edge(i, i + N, INF);
      dinic_add_edge(S_, i, A[i]);

      f = 1;
      for (j = 0; j < N; j = j + 1) {
        if (i != j) {
          idx = i * MAXN + j;
          if (adj[idx] != 0) {
            if (A[j] != 0) {
              dinic_add_edge(i, j + N, INF);
            } else {
              f = m;
            }
          }
        }
      }

      dinic_add_edge(i + N, T_, f);
      sum_f = sum_f + f;
    }
  }

  if (dinic_maxflow(S_, T_) == sum_f) return 1;
  return 0;
}

int main() {
  int T;
  int tc;
  int i;
  int j;
  int L;
  int R;
  int M;

  T = getint();
  for (tc = 0; tc < T; tc = tc + 1) {
    N = getint();

    R = 10;
    for (i = 0; i < N; i = i + 1) {
      A[i] = getint();
      R = R + A[i];
    }

    for (i = 0; i < N; i = i + 1) {
      for (j = 0; j < N; j = j + 1) {
        adj[i * MAXN + j] = getint();
      }
    }

    L = 0;
    for (;;) {
      if (L + 1 >= R) break;
      M = L + (R - L) / 2;
      if (is_ok(M) != 0)
        L = M;
      else
        R = M;
    }

    printf("%d\n", L);
  }

  return 0;
}
