/*
  UVa1660 Cable TV Network (vertex connectivity via maxflow / mincut).
  Input format (SysY-friendly):
    Repeated testcases:
      N
      M
      u1
      v1
      ...
      uM
      vM
    Terminator:
      0
      0
*/

const int MAXN = 60;
const int MAXV = 2 * MAXN;
const int MAXM = 500;
const int MAXE = 5000;
const int INF = 1000000000;

int N;
int M;
int eu[MAXM];
int ev[MAXM];

int Vcnt;
int edge_cnt;
int head[MAXV];
int to[MAXE];
int cap[MAXE];
int flow[MAXE];
int nxt[MAXE];
int level[MAXV];
int cur[MAXV];
int q[MAXV];

void graph_init(int vcount) {
  int i;
  Vcnt = vcount;
  edge_cnt = 0;
  for (i = 0; i < Vcnt; i = i + 1) head[i] = -1;
}

void add_edge(int u, int v, int c) {
  to[edge_cnt] = v;
  cap[edge_cnt] = c;
  flow[edge_cnt] = 0;
  nxt[edge_cnt] = head[u];
  head[u] = edge_cnt;
  edge_cnt = edge_cnt + 1;

  to[edge_cnt] = u;
  cap[edge_cnt] = 0;
  flow[edge_cnt] = 0;
  nxt[edge_cnt] = head[v];
  head[v] = edge_cnt;
  edge_cnt = edge_cnt + 1;
}

int rev_edge(int e) {
  if (e % 2 == 0) return e + 1;
  return e - 1;
}

int bfs(int s, int t) {
  int i;
  int hh;
  int tt;
  int x;
  int e;
  int v;

  for (i = 0; i < Vcnt; i = i + 1) level[i] = -1;
  level[s] = 0;
  q[0] = s;
  hh = 0;
  tt = 1;

  for (; hh < tt; hh = hh + 1) {
    x = q[hh];
    for (e = head[x]; e != -1; e = nxt[e]) {
      v = to[e];
      if (level[v] == -1 && cap[e] > flow[e]) {
        level[v] = level[x] + 1;
        q[tt] = v;
        tt = tt + 1;
      }
    }
  }

  if (level[t] != -1) return 1;
  return 0;
}

int dfs(int u, int t, int f) {
  int e;
  int v;
  int allow;
  int send;
  int pushed;

  if (u == t) return f;
  if (f == 0) return 0;

  e = cur[u];
  for (; e != -1;) {
    cur[u] = e;
    v = to[e];
    if (level[v] == level[u] + 1 && cap[e] > flow[e]) {
      allow = cap[e] - flow[e];
      send = f;
      if (allow < send) send = allow;
      pushed = dfs(v, t, send);
      if (pushed > 0) {
        flow[e] = flow[e] + pushed;
        flow[rev_edge(e)] = flow[rev_edge(e)] - pushed;
        return pushed;
      }
    }
    e = nxt[e];
  }
  cur[u] = -1;
  return 0;
}

int dinic(int s, int t) {
  int total;
  int i;
  int pushed;

  total = 0;
  for (; bfs(s, t);) {
    for (i = 0; i < Vcnt; i = i + 1) cur[i] = head[i];
    for (;;) {
      pushed = dfs(s, t, INF);
      if (pushed == 0) break;
      total = total + pushed;
    }
  }
  return total;
}

int solve() {
  int ans;
  int i;
  int j;
  int u;
  int k;
  int tmp;

  if (N == 0) return 0;
  if (N == 1) return 1;

  ans = N;
  for (i = 0; i < N; i = i + 1) {
    for (j = 0; j < N; j = j + 1) {
      if (i != j) {
        graph_init(2 * N);
        for (u = 0; u < N; u = u + 1) add_edge(u, u + N, 1);
        for (k = 0; k < M; k = k + 1) {
          add_edge(eu[k] + N, ev[k], INF);
          add_edge(ev[k] + N, eu[k], INF);
        }
        tmp = dinic(i + N, j);
        if (tmp < ans) ans = tmp;
      }
    }
  }
  return ans;
}

int main() {
  int i;
  int ans;
  for (;;) {
    N = getint();
    M = getint();
    if (N == 0 && M == 0) break;
    for (i = 0; i < M; i = i + 1) {
      eu[i] = getint();
      ev[i] = getint();
    }
    ans = solve();
    printf("%d\n", ans);
  }
  return 0;
}
