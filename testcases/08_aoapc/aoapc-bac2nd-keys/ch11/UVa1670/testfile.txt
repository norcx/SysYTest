/*
  Converted from:
  Kingdom Roadmap, ACM/ICPC NEERC 2011, UVa1670

  Input format (repeated until n==0):
    n
    (n-1) lines of edges: u v

  Output:
    k
    k lines: a b
*/

const int MAXN = 2005;
const int MAXE = 4010;
const int MAXANS = 4010;

int n;
int root;

int head[MAXN];
int tail[MAXN];
int to[MAXE];
int nxt[MAXE];
int deg[MAXN];
int ecnt;

int retSz[MAXN];
int retA[MAXN];
int retB[MAXN];

int ansCnt;
int ansFrom[MAXANS];
int ansTo[MAXANS];

void init_graph(int nn) {
    int i;
    n = nn;
    ecnt = 0;
    root = 0;
    ansCnt = 0;
    for (i = 1; i <= n; i = i + 1) {
        head[i] = 0;
        tail[i] = 0;
        deg[i] = 0;
        retSz[i] = 0;
        retA[i] = 0;
        retB[i] = 0;
    }
}

void add_arc(int u, int v) {
    ecnt = ecnt + 1;
    to[ecnt] = v;
    nxt[ecnt] = 0;
    if (head[u] == 0) {
        head[u] = ecnt;
        tail[u] = ecnt;
    } else {
        nxt[tail[u]] = ecnt;
        tail[u] = ecnt;
    }
}

void add_edge(int u, int v) {
    add_arc(u, v);
    add_arc(v, u);
}

void connect(int u, int pa) {
    int lsSz;
    int lsA;
    int lsB;
    int e;
    int v;
    int lvsSz;
    int lvsA;
    int lvsB;
    int x;
    int y;

    if (deg[u] == 1) {
        retSz[u] = 1;
        retA[u] = u;
        retB[u] = 0;
        return;
    }

    lsSz = 0;
    lsA = 0;
    lsB = 0;

    for (e = head[u]; e != 0; e = nxt[e]) {
        v = to[e];
        if (v == pa) {
        } else {
            connect(v, u);
            lvsSz = retSz[v];
            lvsA = retA[v];
            lvsB = retB[v];

            if (lsSz + lvsSz > 2) {
                if (lsSz == 2) x = lsB;
                else x = lsA;
                if (lvsSz == 2) y = lvsB;
                else y = lvsA;
                ansCnt = ansCnt + 1;
                ansFrom[ansCnt] = x;
                ansTo[ansCnt] = y;

                if (lsSz == 2) {
                    lsSz = 1;
                    lsB = 0;
                } else {
                    lsSz = 0;
                    lsA = 0;
                }

                if (lvsSz == 2) {
                    lvsSz = 1;
                    lvsB = 0;
                } else {
                    lvsSz = 0;
                    lvsA = 0;
                }
            }

            if (lvsSz == 1) {
                if (lsSz == 0) {
                    lsSz = 1;
                    lsA = lvsA;
                } else {
                    lsSz = 2;
                    lsB = lvsA;
                }
            } else {
                if (lvsSz == 2) {
                    if (lsSz == 0) {
                        lsSz = 2;
                        lsA = lvsA;
                        lsB = lvsB;
                    } else {
                        /*
                          lsSz==1 && lvsSz==2 would have triggered pairing above.
                          Keep code defined anyway.
                        */
                        ansCnt = ansCnt + 1;
                        ansFrom[ansCnt] = lsA;
                        ansTo[ansCnt] = lvsB;
                        lsSz = 1;
                        lsA = lvsA;
                        lsB = 0;
                    }
                }
            }
        }
    }

    retSz[u] = lsSz;
    retA[u] = lsA;
    retB[u] = lsB;
    return;
}

void solve_case() {
    int sz;
    int a;
    int b;
    ansCnt = 0;

    connect(root, 0);
    sz = retSz[root];

    if (sz == 2) {
        ansCnt = ansCnt + 1;
        ansFrom[ansCnt] = retA[root];
        ansTo[ansCnt] = retB[root];
    } else {
        if (sz == 1) {
            ansCnt = ansCnt + 1;
            ansFrom[ansCnt] = root;
            ansTo[ansCnt] = retA[root];
        } else {
            /* Should not happen for valid inputs with n>=2 */
        }
    }

    printf("%d\n", ansCnt);
    for (a = 1; a <= ansCnt; a = a + 1) {
        printf("%d %d\n", ansFrom[a], ansTo[a]);
    }
    b = 0;
    return;
}

int main() {
    int i;
    int u;
    int v;
    int t;
    int nn;

    for (;;) {
        nn = getint();
        if (nn == 0) break;
        init_graph(nn);

        for (i = 0; i < n - 1; i = i + 1) {
            u = getint();
            v = getint();
            add_edge(u, v);
            deg[u] = deg[u] + 1;
            deg[v] = deg[v] + 1;

            if (root == 0) {
                if (deg[u] > 1) root = u;
                if (root == 0 && deg[v] > 1) root = v;
            }
        }

        if (n == 2) {
            ansCnt = 1;
            ansFrom[1] = 1;
            ansTo[1] = 2;
            printf("%d\n", ansCnt);
            printf("%d %d\n", ansFrom[1], ansTo[1]);
        } else {
            if (root == 0) root = 1;
            solve_case();
        }

        t = 0;
    }

    return 0;
}
