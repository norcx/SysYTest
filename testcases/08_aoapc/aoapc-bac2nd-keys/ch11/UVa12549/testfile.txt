/* Description:
 *   [Add description here]
 */
 
const int MAXP = 256;
const int MAXN = 1024;
const int MAXE = 256;

int X;
int Y;
int P;
int W;

int px[MAXP];
int py[MAXP];
int pt[MAXP]; /* 0 = robot '*', 1 = wall '#' */
int pointsN;

int head[MAXN];
int toV[MAXE];
int nextE[MAXE];
int edgeCnt;

int leftMatch[MAXN];  /* right vertex -> left vertex */
int rightMatch[MAXN]; /* left vertex -> right vertex */
int visS[MAXN];
int visT[MAXN];

void swap_points(int i, int j) {
  int t;
  t = px[i]; px[i] = px[j]; px[j] = t;
  t = py[i]; py[i] = py[j]; py[j] = t;
  t = pt[i]; pt[i] = pt[j]; pt[j] = t;
}

void sort_by_yx() {
  int i;
  int j;
  int best;
  for (i = 0; i < pointsN; i = i + 1) {
    best = i;
    for (j = i + 1; j < pointsN; j = j + 1) {
      if (py[j] < py[best]) {
        best = j;
      } else {
        if (py[j] == py[best]) {
          if (px[j] < px[best]) best = j;
        }
      }
    }
    if (best != i) swap_points(i, best);
  }
}

void sort_by_xy() {
  int i;
  int j;
  int best;
  for (i = 0; i < pointsN; i = i + 1) {
    best = i;
    for (j = i + 1; j < pointsN; j = j + 1) {
      if (px[j] < px[best]) {
        best = j;
      } else {
        if (px[j] == px[best]) {
          if (py[j] < py[best]) best = j;
        }
      }
    }
    if (best != i) swap_points(i, best);
  }
}

void graph_init(int nLeft) {
  int i;
  for (i = 0; i < nLeft; i = i + 1) head[i] = -1;
  edgeCnt = 0;
}

void add_edge(int u, int v) {
  toV[edgeCnt] = v;
  nextE[edgeCnt] = head[u];
  head[u] = edgeCnt;
  edgeCnt = edgeCnt + 1;
}

int dfs_match(int u) {
  int e;
  int v;
  visS[u] = 1;
  e = head[u];
  for (; e != -1; e = nextE[e]) {
    v = toV[e];
    if (visT[v] == 0) {
      visT[v] = 1;
      if (leftMatch[v] == -1) {
        leftMatch[v] = u;
        rightMatch[u] = v;
        return 1;
      } else {
        if (dfs_match(leftMatch[v]) != 0) {
          leftMatch[v] = u;
          rightMatch[u] = v;
          return 1;
        }
      }
    }
  }
  return 0;
}

int max_matching(int nLeft, int nRight) {
  int u;
  int i;
  int ans;
  for (i = 0; i < nRight; i = i + 1) leftMatch[i] = -1;
  for (i = 0; i < nLeft; i = i + 1) rightMatch[i] = -1;

  ans = 0;
  for (u = 0; u < nLeft; u = u + 1) {
    for (i = 0; i < nLeft; i = i + 1) visS[i] = 0;
    for (i = 0; i < nRight; i = i + 1) visT[i] = 0;
    if (dfs_match(u) != 0) ans = ans + 1;
  }
  return ans;
}

int min_cover_size(int nLeft, int nRight) {
  int u;
  int v;
  int i;
  int coverX;
  int coverY;

  /* maximum matching */
  i = max_matching(nLeft, nRight);

  for (u = 0; u < nLeft; u = u + 1) visS[u] = 0;
  for (v = 0; v < nRight; v = v + 1) visT[v] = 0;

  for (u = 0; u < nLeft; u = u + 1) {
    if (rightMatch[u] == -1) {
      dfs_match(u);
    }
  }

  coverX = 0;
  coverY = 0;
  for (u = 0; u < nLeft; u = u + 1) {
    if (visS[u] == 0) coverX = coverX + 1;
  }
  for (v = 0; v < nRight; v = v + 1) {
    if (visT[v] != 0) coverY = coverY + 1;
  }
  return coverX + coverY;
}

int solve_case() {
  int i;
  int dy;
  int dx;
  int nLeft;
  int nRight;

  sort_by_yx();
  dy = 0;
  for (i = 0; i < pointsN; i = i + 1) {
    if (pt[i] == 1) dy = dy + 1;
    py[i] = py[i] + dy;
    if (pt[i] == 1) dy = dy + 1;
  }
  Y = Y + dy;

  sort_by_xy();
  dx = 0;
  for (i = 0; i < pointsN; i = i + 1) {
    if (pt[i] == 1) dx = dx + 1;
    px[i] = px[i] + dx;
    if (pt[i] == 1) dx = dx + 1;
  }
  X = X + dx;

  nLeft = X;
  nRight = Y;

  graph_init(nLeft);
  for (i = 0; i < pointsN; i = i + 1) {
    if (pt[i] == 0) {
      add_edge(px[i], py[i]);
    }
  }

  return min_cover_size(nLeft, nRight);
}

int main() {
  int C;
  int t;
  int i;
  int yy;
  int xx;
  int ans;

  C = getint();
  for (t = 1; t <= C; t = t + 1) {
    Y = getint();
    X = getint();
    P = getint();
    pointsN = 0;

    for (i = 0; i < P; i = i + 1) {
      yy = getint();
      xx = getint();
      py[pointsN] = yy - 1;
      px[pointsN] = xx - 1;
      pt[pointsN] = 0;
      pointsN = pointsN + 1;
    }

    W = getint();
    for (i = 0; i < W; i = i + 1) {
      yy = getint();
      xx = getint();
      py[pointsN] = yy - 1;
      px[pointsN] = xx - 1;
      pt[pointsN] = 1;
      pointsN = pointsN + 1;
    }

    ans = solve_case();
    printf("%d\n", ans);
  }
  return 0;
}
