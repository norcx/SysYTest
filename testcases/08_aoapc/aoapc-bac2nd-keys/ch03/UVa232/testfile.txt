/* Description:
 *   Converted from UVa232 "Crossword Answers".
 *   Input encoding (integers only):
 *     Repeated puzzles:
 *       R
 *       C
 *       R*C cell values in row-major order
 *         0 = block '*'
 *         1..26 = 'A'..'Z'
 *     Terminator:
 *       0
 *       0
 *
 *   Output (integers only):
 *     For each puzzle:
 *       t
 *       acrossCount
 *       For each across word:
 *         label
 *         length
 *         letter codes (one per line)
 *       downCount
 *       For each down word:
 *         label
 *         length
 *         letter codes (one per line)
 */

const int MAXN = 256;

int R;
int C;
int grid[MAXN];
int eligiblePos[MAXN];
int acrossIdx[MAXN];
int downIdx[MAXN];

int main() {
  int t;
  int i;
  int j;
  int k;
  int eligibleCount;
  int acrossCount;
  int downCount;
  int v;
  int idx;
  int isCross;
  int isDown;
  int n;
  int pos;
  int x;
  int y;
  int len;
  int cy;
  int cx;
  int cell;

  t = 1;
  for (;;) {
    R = getint();
    C = getint();
    if (R == 0) {
      break;
    }

    i = 0;
    for (i = 0; i < R; i = i + 1) {
      j = 0;
      for (j = 0; j < C; j = j + 1) {
        v = getint();
        grid[i * C + j] = v;
      }
    }

    eligibleCount = 0;
    acrossCount = 0;
    downCount = 0;

    i = 0;
    for (i = 0; i < R; i = i + 1) {
      j = 0;
      for (j = 0; j < C; j = j + 1) {
        idx = i * C + j;
        if (grid[idx] == 0) {
        } else {
          isCross = 0;
          isDown = 0;

          if (j == 0) {
            isCross = 1;
          } else {
            if (grid[i * C + j - 1] == 0) {
              isCross = 1;
            }
          }

          if (i == 0) {
            isDown = 1;
          } else {
            if (grid[(i - 1) * C + j] == 0) {
              isDown = 1;
            }
          }

          if (isCross == 1) {
            acrossIdx[acrossCount] = eligibleCount;
            acrossCount = acrossCount + 1;
          }
          if (isDown == 1) {
            downIdx[downCount] = eligibleCount;
            downCount = downCount + 1;
          }

          if (isCross == 1 || isDown == 1) {
            eligiblePos[eligibleCount] = idx;
            eligibleCount = eligibleCount + 1;
          }
        }
      }
    }

    printf("%d\n", t);

    printf("%d\n", acrossCount);
    k = 0;
    for (k = 0; k < acrossCount; k = k + 1) {
      n = acrossIdx[k];
      pos = eligiblePos[n];
      x = pos / C;
      y = pos - x * C;

      len = 0;
      cy = 0;
      for (cy = y; cy < C; cy = cy + 1) {
        cell = grid[x * C + cy];
        if (cell == 0) {
          break;
        }
        len = len + 1;
      }

      printf("%d\n", n + 1);
      printf("%d\n", len);

      cy = 0;
      for (cy = y; cy < C; cy = cy + 1) {
        cell = grid[x * C + cy];
        if (cell == 0) {
          break;
        }
        printf("%d\n", cell);
      }
    }

    printf("%d\n", downCount);
    k = 0;
    for (k = 0; k < downCount; k = k + 1) {
      n = downIdx[k];
      pos = eligiblePos[n];
      x = pos / C;
      y = pos - x * C;

      len = 0;
      cx = 0;
      for (cx = x; cx < R; cx = cx + 1) {
        cell = grid[cx * C + y];
        if (cell == 0) {
          break;
        }
        len = len + 1;
      }

      printf("%d\n", n + 1);
      printf("%d\n", len);

      cx = 0;
      for (cx = x; cx < R; cx = cx + 1) {
        cell = grid[cx * C + y];
        if (cell == 0) {
          break;
        }
        printf("%d\n", cell);
      }
    }

    t = t + 1;
  }

  return 0;
}
