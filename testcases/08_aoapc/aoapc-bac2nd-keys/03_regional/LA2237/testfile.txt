/* Description:
 *   Strict SysY adaptation of "A Major Problem" (LA2237).
 *   Since SysY only supports integer I/O, notes/keys are encoded as integers.
 *
 *   Note IDs:
 *     1:C  2:C#  3:D  4:D#  5:E  6:F  7:F#  8:G  9:G#  10:A  11:A#  12:B
 *     13:B#  14:Db  15:Eb  16:Fb  17:E#  18:Gb  19:Ab  20:Bb  21:Cb
 *
 *   Input format (all integers, 1 per line):
 *     Repeated cases:
 *       sKey
 *       tKey
 *       note1
 *       note2
 *       ...
 *       0        (end of note list for this case)
 *     0          (end of all input)
 */

const int NCNT = 12;
const int SCALEN = 7;
const int NOTE_MAX = 21;
const int MAX_SCALE = 32;
const int MAX_NOTES = 64;

const int N_C = 1;
const int N_Cs = 2;
const int N_D = 3;
const int N_Ds = 4;
const int N_E = 5;
const int N_F = 6;
const int N_Fs = 7;
const int N_G = 8;
const int N_Gs = 9;
const int N_A = 10;
const int N_As = 11;
const int N_B = 12;
const int N_Bs = 13;
const int N_Db = 14;
const int N_Eb = 15;
const int N_Fb = 16;
const int N_Es = 17;
const int N_Gb = 18;
const int N_Ab = 19;
const int N_Bb = 20;
const int N_Cb = 21;

const int Step[7] = {2, 2, 1, 2, 2, 2, 1};

int notes1Pos[12] = {N_C, N_Cs, N_D, N_Ds, N_E, N_F, N_Fs, N_G, N_Gs, N_A, N_As, N_B};
int notes2Pos[12] = {N_Bs, N_Db, N_D, N_Eb, N_Fb, N_Es, N_Gb, N_G, N_Ab, N_A, N_Bb, N_Cb};

/* Letters: C=0 D=1 E=2 F=3 G=4 A=5 B=6 */
int noteLetter[22] = {
    0,
    0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6,
    6, 1, 2, 3, 2, 4, 5, 6, 0
};

/* Accidentals: natural=0 sharp=1 flat=2 */
int noteAcc[22] = {
    0,
    0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0,
    1, 2, 2, 2, 1, 2, 2, 2, 2
};

int keyToScale[22];
int scaleCount;
int scaleKey[MAX_SCALE];
int scaleNotes[MAX_SCALE * SCALEN];

int tmpNotes[SCALEN];
int usedLetter[7];
int usedCount;

void storeScale() {
    int i;
    int key;
    key = tmpNotes[0];
    if (key < 1 || key > NOTE_MAX) return;
    if (keyToScale[key] != 0) return;
    if (scaleCount >= MAX_SCALE) return;
    scaleKey[scaleCount] = key;
    for (i = 0; i < SCALEN; i = i + 1) {
        scaleNotes[scaleCount * SCALEN + i] = tmpNotes[i];
    }
    keyToScale[key] = scaleCount + 1;
    scaleCount = scaleCount + 1;
}

void genScale(int cur, int depth, int hasFlat, int hasSharp) {
    int cur2;
    int next;
    int opt1;
    int opt2;
    int noteId;
    int letter;
    int acc;

    cur2 = cur % NCNT;
    if (cur2 < 0) cur2 = cur2 + NCNT;

    if (depth == SCALEN) {
        if (usedCount == SCALEN) storeScale();
        return;
    }

    next = cur2 + Step[depth];
    opt1 = notes1Pos[cur2];
    opt2 = notes2Pos[cur2];

    noteId = opt1;
    letter = noteLetter[noteId];
    if (usedLetter[letter] == 0) {
        usedLetter[letter] = 1;
        usedCount = usedCount + 1;
        tmpNotes[depth] = noteId;
        acc = noteAcc[noteId];
        if (acc == 0) {
            genScale(next, depth + 1, hasFlat, hasSharp);
        } else if (acc == 1) {
            if (hasFlat == 0) genScale(next, depth + 1, 0, 1);
        } else {
            if (hasSharp == 0) genScale(next, depth + 1, 1, 0);
        }
        usedLetter[letter] = 0;
        usedCount = usedCount - 1;
    }

    if (opt2 != opt1) {
        noteId = opt2;
        letter = noteLetter[noteId];
        if (usedLetter[letter] == 0) {
            usedLetter[letter] = 1;
            usedCount = usedCount + 1;
            tmpNotes[depth] = noteId;
            acc = noteAcc[noteId];
            if (acc == 0) {
                genScale(next, depth + 1, hasFlat, hasSharp);
            } else if (acc == 1) {
                if (hasFlat == 0) genScale(next, depth + 1, 0, 1);
            } else {
                if (hasSharp == 0) genScale(next, depth + 1, 1, 0);
            }
            usedLetter[letter] = 0;
            usedCount = usedCount - 1;
        }
    }
}

void generateScales() {
    int i;
    for (i = 0; i <= NOTE_MAX; i = i + 1) keyToScale[i] = 0;
    scaleCount = 0;
    for (i = 0; i < 7; i = i + 1) usedLetter[i] = 0;
    usedCount = 0;
    for (i = 0; i < NCNT; i = i + 1) genScale(i, 0, 0, 0);
}

int isValidKey(int k) {
    if (k < 1) return 0;
    if (k > NOTE_MAX) return 0;
    if (keyToScale[k] == 0) return 0;
    return 1;
}

int findInScale(int scaleIdx, int noteId) {
    int i;
    for (i = 0; i < SCALEN; i = i + 1) {
        if (scaleNotes[scaleIdx * SCALEN + i] == noteId) return i;
    }
    return -1;
}

int main() {
    int sKey;
    int tKey;
    int notes[MAX_NOTES];
    int noteCount;
    int note;
    int first;
    int sValid;
    int tValid;
    int ss;
    int ts;
    int i;
    int pos;
    int outNote;

    generateScales();
    first = 1;

    for (;;) {
        sKey = getint();
        if (sKey == 0) break;
        tKey = getint();

        noteCount = 0;
        for (;;) {
            note = getint();
            if (note == 0) break;
            if (noteCount < MAX_NOTES) {
                notes[noteCount] = note;
                noteCount = noteCount + 1;
            }
        }

        if (first == 0) printf("\n");
        first = 0;

        sValid = isValidKey(sKey);
        tValid = isValidKey(tKey);

        if (sValid != 0 && tValid != 0) {
            printf("Transposing from %d to %d:\n", sKey, tKey);
            ss = keyToScale[sKey] - 1;
            ts = keyToScale[tKey] - 1;
            for (i = 0; i < noteCount; i = i + 1) {
                pos = findInScale(ss, notes[i]);
                if (pos < 0) {
                    printf("  %d is not a valid note in the %d major scale\n", notes[i], sKey);
                } else {
                    outNote = scaleNotes[ts * SCALEN + pos];
                    printf("  %d transposes to %d\n", notes[i], outNote);
                }
            }
        } else if (sValid == 0 && tValid == 0) {
            printf("Key of %d is not a valid major key\n", sKey);
        } else {
            if (sValid != 0) printf("Key of %d is not a valid major key\n", tKey);
            else printf("Key of %d is not a valid major key\n", sKey);
        }
    }

    return 0;
}
