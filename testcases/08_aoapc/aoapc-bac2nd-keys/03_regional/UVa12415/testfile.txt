/*
  UVa12415 - Digit Patterns (scaled-down strict SysY version)

  Input format (integers only, 1 per line):
    n
    rexLen
    rexCharCode[0..rexLen-1]   // ASCII codes: digits '0'..'9', '(', ')', '+', '*'
    txtLen
    txtCharCode[0..txtLen-1]   // ASCII digit codes
    ... repeat ...
    -1                         // sentinel to stop

  Output:
    All prefix lengths i (i>0) such that txt[0..i-1] matches rex, space-separated.
*/

const int TYPE_A = 0;
const int TYPE_STAR = 1;
const int TYPE_OR = 2;
const int TYPE_CONCAT = 3;

const int MAXR = 64;
const int MAXT = 128;
const int MAXNODES = 256;
const int MAXS = 300;
const int MAXE = 6000;

int rexLen;
int rexCodes[MAXR];
int txtLen;
int txtCodes[MAXT];
int pR;

int nodeType[MAXNODES];
int nodeVal[MAXNODES];
int nodeL[MAXNODES];
int nodeR[MAXNODES];
int nodeCnt;

int stateCnt;
int edgeCnt;
int headE[MAXS];
int toE[MAXE];
int chE[MAXE];
int nextE[MAXE];

int startState;
int acceptState;

int q[MAXS];

int currSet[MAXS];
int tmpSet[MAXS];
int nextSet[MAXS];

int ans[MAXT + 1];
int ansCnt;

int nodeStart[MAXNODES];
int nodeEnd[MAXNODES];

int newNode(int t, int l, int r, int v) {
    int idx = nodeCnt;
    nodeType[idx] = t;
    nodeL[idx] = l;
    nodeR[idx] = r;
    nodeVal[idx] = v;
    nodeCnt = nodeCnt + 1;
    return idx;
}

int parse(int level) {
    int u;
    int v;
    int c;

    if (level == 2) {
        // ITEM
        if (rexCodes[pR] == 40) {          // '('
            pR = pR + 1;
            u = parse(0);                  // parse Expr
            pR = pR + 1;                   // ')'
        } else {
            c = rexCodes[pR];
            pR = pR + 1;
            u = newNode(TYPE_A, -1, -1, c - 48);
        }

        for (;;) {
            if (pR < rexLen && rexCodes[pR] == 42) {   // '*'
                pR = pR + 1;
                u = newNode(TYPE_STAR, u, -1, 0);
            } else {
                break;
            }
        }
        return u;
    }

    if (level == 1) {
        // CONCAT
        u = parse(2);
        for (;;) {
            if (pR < rexLen &&
                rexCodes[pR] != 41 &&     // ')'
                rexCodes[pR] != 43) {     // '+'
                v = parse(2);
                u = newNode(TYPE_CONCAT, u, v, 0);
            } else {
                break;
            }
        }
        return u;
    }

    // level == 0 : OR
    u = parse(1);
    for (;;) {
        if (pR < rexLen && rexCodes[pR] == 43) {  // '+'
            pR = pR + 1;
            v = parse(1);
            u = newNode(TYPE_OR, u, v, 0);
        } else {
            break;
        }
    }
    return u;
}

void addEdge(int s, int t, int ch) {
    toE[edgeCnt] = t;
    chE[edgeCnt] = ch;
    nextE[edgeCnt] = headE[s];
    headE[s] = edgeCnt;
    edgeCnt = edgeCnt + 1;
}

void buildNFA(int u) {
    int st;
    int ed;
    int l;
    int r;
    st = stateCnt;
    stateCnt = stateCnt + 1;
    ed = stateCnt;
    stateCnt = stateCnt + 1;

    if (nodeType[u] == TYPE_A) {
        addEdge(st, ed, nodeVal[u]);
    } else if (nodeType[u] == TYPE_STAR) {
        l = nodeL[u];
        buildNFA(l);
        addEdge(st, nodeStart[l], -1);
        addEdge(st, ed, -1);
        addEdge(nodeEnd[l], nodeStart[l], -1);
        addEdge(nodeEnd[l], ed, -1);
    } else if (nodeType[u] == TYPE_OR) {
        l = nodeL[u];
        r = nodeR[u];
        buildNFA(l);
        buildNFA(r);
        addEdge(st, nodeStart[l], -1);
        addEdge(st, nodeStart[r], -1);
        addEdge(nodeEnd[l], ed, -1);
        addEdge(nodeEnd[r], ed, -1);
    } else {
        l = nodeL[u];
        r = nodeR[u];
        buildNFA(l);
        buildNFA(r);
        addEdge(st, nodeStart[l], -1);
        addEdge(nodeEnd[l], nodeStart[r], -1);
        addEdge(nodeEnd[r], ed, -1);
    }

    nodeStart[u] = st;
    nodeEnd[u] = ed;
}

void clearAll() {
    int i;
    nodeCnt = 0;
    stateCnt = 0;
    edgeCnt = 0;
    for (i = 0; i < MAXS; i = i + 1) {
        headE[i] = -1;
    }
}

void setClear(int a[]) {
    int i;
    for (i = 0; i < stateCnt; i = i + 1) {
        a[i] = 0;
    }
}

void setCopy(int src[], int dst[]) {
    int i;
    for (i = 0; i < stateCnt; i = i + 1) {
        dst[i] = src[i];
    }
}

void epsClosure(int inSet[], int outSet[]) {
    int i;
    int front;
    int back;
    int s;
    int e;
    int t;

    for (i = 0; i < stateCnt; i = i + 1) {
        outSet[i] = inSet[i];
    }

    front = 0;
    back = 0;
    for (i = 0; i < stateCnt; i = i + 1) {
        if (outSet[i] != 0) {
            q[back] = i;
            back = back + 1;
        }
    }

    for (; front < back;) {
        s = q[front];
        front = front + 1;
        e = headE[s];
        for (; e != -1;) {
            if (chE[e] == -1) {
                t = toE[e];
                if (outSet[t] == 0) {
                    outSet[t] = 1;
                    q[back] = t;
                    back = back + 1;
                }
            }
            e = nextE[e];
        }
    }
}

void moveSet(int inSet[], int digit, int outSet[]) {
    int s;
    int e;
    int t;
    setClear(outSet);
    for (s = 0; s < stateCnt; s = s + 1) {
        if (inSet[s] != 0) {
            e = headE[s];
            for (; e != -1;) {
                if (chE[e] == digit) {
                    t = toE[e];
                    outSet[t] = 1;
                }
                e = nextE[e];
            }
        }
    }
}

int main() {
    for (;;) {
        int n;
        int root;
        int i;
        int digit;

        n = getint();
        if (n < 0) {
            break;
        }

        rexLen = getint();
        for (i = 0; i < rexLen; i = i + 1) {
            rexCodes[i] = getint();
        }
        txtLen = getint();
        for (i = 0; i < txtLen; i = i + 1) {
            txtCodes[i] = getint();
        }

        clearAll();
        pR = 0;
        root = parse(0);
        buildNFA(root);
        startState = nodeStart[root];
        acceptState = nodeEnd[root];

        setClear(currSet);
        currSet[startState] = 1;
        epsClosure(currSet, tmpSet);
        setCopy(tmpSet, currSet);

        ansCnt = 0;
        for (i = 0; i < txtLen; i = i + 1) {
            if (i > 0) {
                if (currSet[acceptState] != 0) {
                    ans[ansCnt] = i;
                    ansCnt = ansCnt + 1;
                }
            }

            digit = txtCodes[i] - 48;
            if (digit < 0) {
                digit = 0;
            }
            if (digit > n) {
                digit = n;
            }

            moveSet(currSet, digit, nextSet);
            epsClosure(nextSet, currSet);
        }

        if (currSet[acceptState] != 0) {
            ans[ansCnt] = txtLen;
            ansCnt = ansCnt + 1;
        }

        if (ansCnt == 0) {
            printf("\n");
        } else {
            printf("%d", ans[0]);
            for (i = 1; i < ansCnt; i = i + 1) {
                printf(" ");
                printf("%d", ans[i]);
            }
            printf("\n");
        }
    }

    return 0;
}
