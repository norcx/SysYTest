/* Description:
 *   UVa11196 - Birthday Cake
 *   Given N (volume) and M (layers), minimize surface area:
 *     V = sum(ri*ri*hi)
 *     S = sum(2*ri*hi) + r1*r1
 *   ri and hi are positive integers with strict decreasing constraints.
 *   Input: multiple pairs N, M; terminated by 0 0.
 *   Output: "Case t: ans".
 */

const int INF = 1000000000;

int N;
int M;
int ans;

int min_int(int a, int b) {
    if (a < b) return a;
    return b;
}

int isqrt_ceil(int n) {
    int r;
    r = 0;
    for (;;) {
        if (r * r >= n) break;
        r = r + 1;
    }
    return r;
}

void dfs(int k, int V, int S, int R, int H) {
    int r;
    int h;
    int maxh;
    int topArea;

    if (k == 0) {
        if (V == 0) ans = min_int(ans, S);
        return;
    }

    if (k * k * (k + 1) * (k + 1) / 4 <= V && S + k * (k + 1) * (2 * k + 1) / 3 < ans) {
        for (r = R; r >= k && S + 2 * V / r < ans; r = r - 1) {
            maxh = V / (r * r);
            if (maxh > H) maxh = H;
            for (h = maxh; h >= k && r * r * (h + h - k + 1) * k / 2 >= V; h = h - 1) {
                topArea = 0;
                if (k == M) topArea = r * r;
                dfs(k - 1, V - r * r * h, S + 2 * r * h + topArea, r - 1, h - 1);
            }
        }
    }
}

int main() {
    int t;
    t = 1;
    for (;;) {
        N = getint();
        M = getint();
        if (N == 0 && M == 0) break;
        ans = INF;
        dfs(M, N, 0, isqrt_ceil(N), INF);
        if (ans == INF) ans = 0;
        printf("Case %d: %d\n", t, ans);
        t = t + 1;
    }
    return 0;
}
