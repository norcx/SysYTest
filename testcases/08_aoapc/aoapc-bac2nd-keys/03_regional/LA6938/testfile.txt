/*
  LA6938 Outer space invaders (scaled-down Strict SysY testcase)
  Input format:
    T
    n
    A1
    B1
    H1
    ...
*/

const int MAXN = 50;
const int MAXK = 110;
const int INF = 1061109567;

int A[MAXN];
int B[MAXN];
int H[MAXN];
int P[MAXK];
int F[MAXK * MAXK];

int idx2(int i, int j) {
    return i * MAXK + j;
}

int lower_bound_int(int a[], int n, int x) {
    int l;
    int r;
    int mid;
    l = 0;
    r = n;
    for (; l < r;) {
        mid = (l + r) / 2;
        if (a[mid] < x) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l;
}

void qsort_int(int a[], int l, int r) {
    int i;
    int j;
    int pivot;
    int tmp;
    if (l >= r) {
        return;
    }
    i = l;
    j = r;
    pivot = a[(l + r) / 2];
    for (;;) {
        for (; a[i] < pivot; i = i + 1) {
        }
        for (; a[j] > pivot; j = j - 1) {
        }
        if (i <= j) {
            tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
            i = i + 1;
            j = j - 1;
        }
        if (i > j) {
            break;
        }
    }
    if (l < j) {
        qsort_int(a, l, j);
    }
    if (i < r) {
        qsort_int(a, i, r);
    }
    return;
}

int main() {
    int T;
    int t;
    int n;
    int m;
    int k;
    int i;
    int j;
    int sl;
    int q;
    int hst;
    int df;
    int l;
    int r;
    int d;
    int cand;

    T = getint();
    for (t = 0; t < T; t = t + 1) {
        n = getint();
        m = 0;
        for (i = 0; i < n; i = i + 1) {
            A[i] = getint();
            B[i] = getint();
            H[i] = getint();
            P[m] = A[i];
            m = m + 1;
            P[m] = B[i];
            m = m + 1;
        }
        P[m] = -INF;
        m = m + 1;
        P[m] = INF;
        m = m + 1;

        qsort_int(P, 0, m - 1);
        k = 0;
        for (i = 0; i < m; i = i + 1) {
            if (i == 0) {
                P[k] = P[i];
                k = k + 1;
            } else {
                if (P[i] != P[i - 1]) {
                    P[k] = P[i];
                    k = k + 1;
                }
            }
        }

        for (i = 0; i < k; i = i + 1) {
            for (j = 0; j < k; j = j + 1) {
                F[idx2(i, j)] = 0;
            }
        }

        for (sl = 1; sl < k; sl = sl + 1) {
            for (i = 0; i + sl < k; i = i + 1) {
                j = i + sl;
                hst = -1;
                for (q = 0; q < n; q = q + 1) {
                    if (P[i] < A[q] && B[q] < P[j]) {
                        if (hst == -1) {
                            hst = q;
                        } else {
                            if (H[hst] < H[q]) {
                                hst = q;
                            }
                        }
                    }
                }

                if (hst == -1) {
                    F[idx2(i, j)] = 0;
                } else {
                    df = INF;
                    l = lower_bound_int(P, k, A[hst]);
                    r = lower_bound_int(P, k, B[hst]);
                    for (d = l; d <= r; d = d + 1) {
                        cand = H[hst] + F[idx2(i, d)] + F[idx2(d, j)];
                        if (cand < df) {
                            df = cand;
                        }
                    }
                    F[idx2(i, j)] = df;
                }
            }
        }

        printf("%d\n", F[idx2(0, k - 1)]);
    }
    return 0;
}
