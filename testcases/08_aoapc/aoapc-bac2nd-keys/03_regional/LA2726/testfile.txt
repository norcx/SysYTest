/* Description:
 *   Combining Images (quadtree AND), integer I/O version.
 *
 *   Input format (all integers, 1 per line):
 *     Repeated testcases:
 *       L1
 *       d1[0..L1-1]   (each digit is 0..15, hex nibbles)
 *       L2
 *       d2[0..L2-1]
 *     Terminates with L1 = 0.
 *
 *   Output:
 *     Blank line between testcases.
 *     For each testcase t:
 *       Image t:
 *       K
 *       out_digit[0..K-1]   (each is 0..15)
 */

const int MAX_DIG = 128;
const int MAX_BITS = 20000;
const int MAX_NODE = 12000;

const int HEX_BITS[64] = {
    0,0,0,0,  0,0,0,1,  0,0,1,0,  0,0,1,1,
    0,1,0,0,  0,1,0,1,  0,1,1,0,  0,1,1,1,
    1,0,0,0,  1,0,0,1,  1,0,1,0,  1,0,1,1,
    1,1,0,0,  1,1,0,1,  1,1,1,0,  1,1,1,1
};

int in1[MAX_DIG];
int in2[MAX_DIG];

int bits[MAX_BITS];
int outBits[MAX_BITS];

int outDigits[6000];

int nodeFlag[MAX_NODE];
int nodeVal[MAX_NODE];
int nodeChild[MAX_NODE * 4];
int nodeCnt;

int newNode() {
    int idx;
    int i;
    idx = nodeCnt;
    nodeCnt = nodeCnt + 1;
    nodeFlag[idx] = 0;
    nodeVal[idx] = 0;
    for (i = 0; i < 4; i = i + 1) {
        nodeChild[idx * 4 + i] = -1;
    }
    return idx;
}

void fromHexDigits(int digits[], int len, int outArr[], int outLen[]) {
    int p;
    int first;
    int i;
    int b;
    int h;
    int x;
    outLen[0] = 0;
    p = 1;
    first = 1;
    for (i = 0; i < len; i = i + 1) {
        h = digits[i];
        for (b = 0; b < 4; b = b + 1) {
            x = HEX_BITS[h * 4 + b];
            if (first == 1) {
                if (p == 1) {
                    if (x == 1) {
                        p = 0;
                    }
                } else {
                    outArr[outLen[0]] = x;
                    outLen[0] = outLen[0] + 1;
                }
            } else {
                outArr[outLen[0]] = x;
                outLen[0] = outLen[0] + 1;
            }
        }
        if (first == 1) {
            first = 0;
        }
    }
}

int parseBits(int bitArr[], int bitLen, int pos[]) {
    int idx;
    int i;
    idx = newNode();
    nodeFlag[idx] = bitArr[pos[0]];
    pos[0] = pos[0] + 1;
    if (nodeFlag[idx] == 1) {
        nodeVal[idx] = bitArr[pos[0]];
        pos[0] = pos[0] + 1;
        return idx;
    }
    for (i = 0; i < 4; i = i + 1) {
        nodeChild[idx * 4 + i] = parseBits(bitArr, bitLen, pos);
    }
    return idx;
}

int intersect(int a, int b) {
    int idx;
    int i;
    int cp;
    int canCollapse;
    int firstVal;
    int v;

    if (nodeFlag[a] == 1) {
        if (nodeFlag[b] == 1) {
            idx = newNode();
            nodeFlag[idx] = 1;
            v = 0;
            if (nodeVal[a] == 1) {
                if (nodeVal[b] == 1) {
                    v = 1;
                }
            }
            nodeVal[idx] = v;
            return idx;
        }
        if (nodeVal[a] == 1) {
            return b;
        }
        return a;
    }
    if (nodeFlag[b] == 1) {
        return intersect(b, a);
    }

    idx = newNode();
    canCollapse = 1;
    firstVal = 0;
    for (i = 0; i < 4; i = i + 1) {
        cp = intersect(nodeChild[a * 4 + i], nodeChild[b * 4 + i]);
        nodeChild[idx * 4 + i] = cp;
        if (canCollapse == 1) {
            if (nodeFlag[cp] == 0) {
                canCollapse = 0;
            } else {
                if (i == 0) {
                    firstVal = nodeVal[cp];
                } else {
                    if (nodeVal[cp] != firstVal) {
                        canCollapse = 0;
                    }
                }
            }
        }
    }

    if (canCollapse == 1) {
        nodeFlag[idx] = 1;
        nodeVal[idx] = firstVal;
        for (i = 0; i < 4; i = i + 1) {
            nodeChild[idx * 4 + i] = -1;
        }
    } else {
        nodeFlag[idx] = 0;
    }
    return idx;
}

void toBits(int idx, int bitArr[], int bitLen[]) {
    int i;
    bitArr[bitLen[0]] = nodeFlag[idx];
    bitLen[0] = bitLen[0] + 1;
    if (nodeFlag[idx] == 1) {
        bitArr[bitLen[0]] = nodeVal[idx];
        bitLen[0] = bitLen[0] + 1;
        return;
    }
    for (i = 0; i < 4; i = i + 1) {
        toBits(nodeChild[idx * 4 + i], bitArr, bitLen);
    }
}

void toHexDigits(int bitArr[], int bitLen, int digitArr[], int digitLen[]) {
    int p;
    int z;
    int i;
    int b;
    int j;
    digitLen[0] = 0;
    p = (bitLen + 1) % 4;
    z = 1;
    i = 0;
    b = 0;
    if (p != 0) {
        for (j = i; j < p - 1; j = j + 1) {
            z = z * 2 + bitArr[j];
        }
        i = j;
        digitArr[digitLen[0]] = z;
        digitLen[0] = digitLen[0] + 1;
        z = 0;
        b = 0;
    } else {
        b = 1;
    }

    for (j = i; j < bitLen; j = j + 1) {
        z = z * 2 + bitArr[j];
        b = b + 1;
        if (b == 4) {
            digitArr[digitLen[0]] = z;
            digitLen[0] = digitLen[0] + 1;
            z = 0;
            b = 0;
        }
    }
}

int main() {
    int t;
    int l1;
    int l2;
    int i;
    int bitLen;
    int pos;
    int bitLenArr[1];
    int posArr[1];
    int outDigitLenArr[1];
    int root1;
    int root2;
    int root3;
    int outDigitLen;

    t = 1;
    for (;;) {
        l1 = getint();
        if (l1 == 0) {
            break;
        }
        for (i = 0; i < l1; i = i + 1) {
            in1[i] = getint();
        }
        l2 = getint();
        for (i = 0; i < l2; i = i + 1) {
            in2[i] = getint();
        }

        if (t > 1) {
            printf("\n");
        }

        nodeCnt = 0;
        fromHexDigits(in1, l1, bits, bitLenArr);
        bitLen = bitLenArr[0];
        posArr[0] = 0;
        root1 = parseBits(bits, bitLen, posArr);

        fromHexDigits(in2, l2, bits, bitLenArr);
        bitLen = bitLenArr[0];
        posArr[0] = 0;
        root2 = parseBits(bits, bitLen, posArr);

        root3 = intersect(root1, root2);
        bitLenArr[0] = 0;
        toBits(root3, outBits, bitLenArr);
        bitLen = bitLenArr[0];
        toHexDigits(outBits, bitLen, outDigits, outDigitLenArr);
        outDigitLen = outDigitLenArr[0];

        printf("Image %d:\n", t);
        printf("%d\n", outDigitLen);
        for (i = 0; i < outDigitLen; i = i + 1) {
            printf("%d\n", outDigits[i]);
        }

        t = t + 1;
    }

    return 0;
}
