/* Description:
 *   Strict SysY adaptation of a UVa1390-style solver:
 *   - Reads T testcases (to avoid relying on EOF for termination).
 *   - For each graph, computes connected component sizes via DFS.
 *   - Runs a memoized DP over integer partitions of N, using fixed-point ints.
 *   - Prints the expected value scaled by SCALE (integer).
 *
 * Input format (all integers, one per line):
 *   T
 *   N
 *   M
 *   u1
 *   v1
 *   ...
 *   uM
 *   vM
 *   (repeat for T cases)
 *
 * Output:
 *   One integer per line: dp * SCALE
 */

const int MAXN = 32;
const int MAXSTATE = 9000; /* >= number of integer partitions of 32 (8349) */
const int SCALE = 1000;

int N;
int M;
int G[MAXN * MAXN];
int vis[MAXN];

int memo_len[MAXSTATE];
int memo_val[MAXSTATE];
int memo_data[MAXSTATE * MAXN];
int memo_used;

int dfs(int u) {
  int ans;
  int v;
  ans = 1;
  vis[u] = 1;
  for (v = 0; v < N; v = v + 1) {
    if (G[u * MAXN + v] != 0 && vis[v] == 0) {
      ans = ans + dfs(v);
    }
  }
  return ans;
}

void sort_parts(int a[], int k) {
  int i;
  for (i = 1; i < k; i = i + 1) {
    int x;
    int j;
    int pos;
    x = a[i];
    pos = i;
    for (j = 0; j < i; j = j + 1) {
      if (pos == i && a[j] > x) {
        pos = j;
      }
    }
    for (j = i; j > pos; j = j - 1) {
      a[j] = a[j - 1];
    }
    a[pos] = x;
  }
}

int find_state(int parts[], int k) {
  int idx;
  int t;
  for (idx = 0; idx < memo_used; idx = idx + 1) {
    if (memo_len[idx] == k) {
      for (t = 0; t < k; t = t + 1) {
        if (memo_data[idx * MAXN + t] != parts[t]) {
          break;
        }
      }
      if (t == k) {
        return idx;
      }
    }
  }
  return -1;
}

int build_next(int parts[], int k, int i, int j, int next[]) {
  int merged;
  int nk;
  int t;
  int p;
  int pos;
  int q;

  merged = parts[i] + parts[j];
  nk = k - 1;

  p = 0;
  for (t = 0; t < k; t = t + 1) {
    if (t != i && t != j) {
      next[p] = parts[t];
      p = p + 1;
    }
  }

  pos = 0;
  for (pos = 0; pos < nk - 1; pos = pos + 1) {
    if (merged <= next[pos]) {
      break;
    }
  }
  for (q = nk - 2; q >= pos; q = q - 1) {
    next[q + 1] = next[q];
  }
  next[pos] = merged;
  return nk;
}

int dp(int parts[], int k) {
  int idx;
  int t;
  int i;
  int j;
  int next[MAXN];
  int nk;
  int sum_scaled;
  int sum_p;
  int denom;
  int e_scaled;
  int temp;
  int res;

  if (k == 1) {
    return 0;
  }

  idx = find_state(parts, k);
  if (idx >= 0) {
    return memo_val[idx];
  }

  idx = memo_used;
  memo_used = memo_used + 1;
  memo_len[idx] = k;
  for (t = 0; t < k; t = t + 1) {
    memo_data[idx * MAXN + t] = parts[t];
  }

  sum_scaled = 0;
  sum_p = 0;
  for (i = 0; i < k; i = i + 1) {
    for (j = i + 1; j < k; j = j + 1) {
      int ci;
      int cj;
      int weight;
      int child;

      ci = parts[i];
      cj = parts[j];
      weight = ci * cj * 2;

      nk = build_next(parts, k, i, j, next);
      child = dp(next, nk);
      sum_scaled = sum_scaled + weight * (child + SCALE);
      sum_p = sum_p + weight;
    }
  }

  denom = N * (N - 1);
  e_scaled = sum_scaled / denom;
  temp = e_scaled * denom / SCALE + denom - sum_p;
  res = temp * SCALE / sum_p;

  memo_val[idx] = res;
  return res;
}

int main() {
  int T;
  int tc;
  int i;

  T = getint();
  for (tc = 0; tc < T; tc = tc + 1) {
    int u;
    int v;
    int k;
    int parts[MAXN];
    int out;

    N = getint();
    M = getint();

    for (i = 0; i < MAXN * MAXN; i = i + 1) {
      G[i] = 0;
    }
    for (i = 0; i < MAXN; i = i + 1) {
      vis[i] = 0;
    }
    memo_used = 0;

    for (i = 0; i < M; i = i + 1) {
      u = getint() - 1;
      v = getint() - 1;
      if (u >= 0 && u < N && v >= 0 && v < N) {
        G[u * MAXN + v] = 1;
        G[v * MAXN + u] = 1;
      }
    }

    k = 0;
    for (u = 0; u < N; u = u + 1) {
      if (vis[u] == 0) {
        parts[k] = dfs(u);
        k = k + 1;
      }
    }
    sort_parts(parts, k);

    out = dp(parts, k);
    printf("%d\n", out);
  }
  return 0;
}
