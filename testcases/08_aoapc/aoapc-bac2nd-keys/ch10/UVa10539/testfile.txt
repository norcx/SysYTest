// UVa10539 Almost Prime Numbers (scaled to int-only Strict SysY)

const int MAXN = 50000;
const int MAXP = 2000000000;
const int APS_MAX = 100000;

int vis[MAXN];
int primes[MAXN];
int prime_cnt;

int aps[APS_MAX];
int aps_cnt;

void sieve() {
  int i;
  int j;
  prime_cnt = 0;
  for (i = 0; i < MAXN; i = i + 1) vis[i] = 0;

  for (i = 2; i < MAXN; i = i + 1) {
    if (vis[i] == 0) {
      primes[prime_cnt] = i;
      prime_cnt = prime_cnt + 1;
      for (j = i + i; j < MAXN; j = j + i) vis[j] = 1;
    }
  }
}

void build_almost_primes() {
  int idx;
  int p;
  int powv;
  aps_cnt = 0;

  for (idx = 0; idx < prime_cnt; idx = idx + 1) {
    p = primes[idx];
    if (p <= MAXP / p) {
      powv = p * p;
      for (;;) {
        if (aps_cnt < APS_MAX) {
          aps[aps_cnt] = powv;
          aps_cnt = aps_cnt + 1;
        }
        if (powv > MAXP / p) break;
        powv = powv * p;
      }
    }
  }
}

void shell_sort_aps() {
  int gap;
  int i;
  int j;
  int temp;

  gap = aps_cnt / 2;
  for (; gap > 0; gap = gap / 2) {
    for (i = gap; i < aps_cnt; i = i + 1) {
      temp = aps[i];
      j = i;
      for (; j >= gap && aps[j - gap] > temp; j = j - gap) aps[j] = aps[j - gap];
      aps[j] = temp;
    }
  }
}

int lower_bound_aps(int x) {
  int l;
  int r;
  int m;
  l = 0;
  r = aps_cnt;
  for (;;) {
    if (l >= r) break;
    m = (l + r) / 2;
    if (aps[m] < x)
      l = m + 1;
    else
      r = m;
  }
  return l;
}

int upper_bound_aps(int x) {
  int l;
  int r;
  int m;
  l = 0;
  r = aps_cnt;
  for (;;) {
    if (l >= r) break;
    m = (l + r) / 2;
    if (aps[m] <= x)
      l = m + 1;
    else
      r = m;
  }
  return l;
}

int main() {
  int t;
  int qi;
  int L;
  int H;
  int a;
  int b;

  sieve();
  build_almost_primes();
  shell_sort_aps();

  t = getint();
  for (qi = 0; qi < t; qi = qi + 1) {
    L = getint();
    H = getint();
    a = lower_bound_aps(L);
    b = upper_bound_aps(H);
    printf("%d\n", b - a);
  }
  return 0;
}
