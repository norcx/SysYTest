/*
 * UVa 10622 - Perfect P-th Powers
 * Read integers N (one per line) until N == 0.
 * For each N, output the largest p such that N = k^p for some integer k.
 * If N < 0, p must be odd.
 */

const int MAXP = 50000;
int is_comp[MAXP + 1];
int primes[6000];
int prime_cnt;

int gcd(int a, int b) {
    for (;;) {
        if (b == 0) break;
        int t;
        t = a % b;
        a = b;
        b = t;
    }
    return a;
}

void sieve() {
    int i;
    int j;
    prime_cnt = 0;
    for (i = 0; i <= MAXP; i = i + 1) is_comp[i] = 0;

    for (i = 2; i <= MAXP; i = i + 1) {
        if (is_comp[i] == 0) {
            primes[prime_cnt] = i;
            prime_cnt = prime_cnt + 1;
            for (j = i + i; j <= MAXP; j = j + i) is_comp[j] = 1;
        }
    }
    return;
}

int solve(int n) {
    int neg;
    int g;
    int i;
    int p;
    int k;

    neg = 0;
    if (n < 0) {
        neg = 1;
        n = 0 - n;
    }

    if (n == 1) return 1;

    g = 0;
    for (i = 0; i < prime_cnt; i = i + 1) {
        p = primes[i];
        if (p * p > n) break;

        k = 0;
        for (;;) {
            if (n % p != 0) break;
            n = n / p;
            k = k + 1;
        }

        if (k > 0) {
            if (g == 0) g = k;
            else g = gcd(g, k);
            if (g == 1) break;
        }
    }

    if (n > 1) {
        if (g == 0) g = 1;
        else g = gcd(g, 1);
    }
    if (g == 0) g = 1;

    if (neg == 1) {
        for (;;) {
            if (g % 2 != 0) break;
            g = g / 2;
        }
    }
    return g;
}

int main() {
    int n;
    sieve();
    for (;;) {
        n = getint();
        if (n == 0) break;
        printf("%d\n", solve(n));
    }
    return 0;
}
