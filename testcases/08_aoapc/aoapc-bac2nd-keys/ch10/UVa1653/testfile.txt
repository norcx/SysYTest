/* UVa1653 Yet Another Multiple Problem (scaled SysY testcase)
 * BFS on remainders; reconstruct answer via predecessors.
 */
const int MAXN = 10005;

int D[10];
int visited[MAXN];
int pre[MAXN];
int dig[MAXN];
int q[MAXN];
int res_digits[MAXN];

void solve_one(int n, int m, int tc) {
  int i;
  int d;
  for (i = 0; i < 10; i = i + 1) D[i] = 1;
  for (i = 0; i < m; i = i + 1) {
    d = getint();
    if (d >= 0 && d <= 9) D[d] = 0;
  }

  for (i = 0; i < n; i = i + 1) {
    visited[i] = 0;
    pre[i] = -2;
    dig[i] = 0;
  }

  int head;
  int tail;
  head = 0;
  tail = 0;
  for (d = 1; d <= 9; d = d + 1) {
    if (D[d] == 1) {
      int r;
      r = d % n;
      if (visited[r] == 0) {
        visited[r] = 1;
        pre[r] = -1;
        dig[r] = d;
        q[tail] = r;
        tail = tail + 1;
      }
    }
  }

  int found;
  found = 0;
  for (head = 0; head < tail; head = head + 1) {
    int v;
    v = q[head];
    if (v == 0) {
      found = 1;
      break;
    }
    for (d = 0; d <= 9; d = d + 1) {
      if (D[d] == 1) {
        int nv;
        nv = (v * 10 + d) % n;
        if (visited[nv] == 0) {
          visited[nv] = 1;
          pre[nv] = v;
          dig[nv] = d;
          q[tail] = nv;
          tail = tail + 1;
        }
      }
    }
  }

  printf("Case %d: ", tc);
  if (found == 0) {
    printf("-1\n");
    return;
  }

  int len;
  int cur;
  len = 0;
  cur = 0;
  for (i = 0; i < MAXN; i = i + 1) {
    res_digits[len] = dig[cur];
    len = len + 1;
    if (pre[cur] == -1) break;
    cur = pre[cur];
  }

  for (i = len - 1; i >= 0; i = i - 1) {
    printf("%d", res_digits[i]);
  }
  printf("\n");
  return;
}

int main() {
  int T;
  int tc;
  T = getint();
  for (tc = 1; tc <= T; tc = tc + 1) {
    int n;
    int m;
    n = getint();
    m = getint();
    solve_one(n, m, tc);
  }
  return 0;
}
