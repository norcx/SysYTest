/* Description:
 *   UVa 1210 - Sum of Consecutive Prime Numbers
 *   Count representations of N as a sum of consecutive primes.
 *   Input: one integer per line, terminated by a sentinel 0.
 *   Output: answer per query line.
 */

const int MAXN = 10000 + 4;
const int MAXP = 2000;

int vis[MAXN];
int primes[MAXP];
int ps[MAXP];
int prime_cnt;

void gen_primes() {
    int i;
    int j;

    prime_cnt = 0;
    for (i = 0; i < MAXN; i = i + 1) vis[i] = 0;

    for (i = 2; i < MAXN; i = i + 1) {
        if (vis[i] == 0) {
            primes[prime_cnt] = i;
            prime_cnt = prime_cnt + 1;
            j = i * i;
            for (; j < MAXN; j = j + i) vis[j] = 1;
        }
    }

    if (prime_cnt > 0) {
        ps[0] = primes[0];
        for (i = 1; i < prime_cnt; i = i + 1) ps[i] = ps[i - 1] + primes[i];
    }
    return;
}

int ps_has_target_from(int start, int target) {
    int low;
    int high;
    int mid;

    low = start;
    high = prime_cnt - 1;
    for (; low <= high;) {
        mid = (low + high) / 2;
        if (ps[mid] == target) return 1;
        if (ps[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return 0;
}

int main() {
    int n;
    int i;
    int ans;

    gen_primes();

    for (;;) {
        n = getint();
        if (n == 0) break;

        ans = 0;
        for (i = 0; i < prime_cnt; i = i + 1) {
            if (ps[i] == n) ans = ans + 1;
            if (primes[i] > n) break;
            if (ps_has_target_from(i, ps[i] + n) == 1) ans = ans + 1;
        }

        printf("%d\n", ans);
    }

    return 0;
}
