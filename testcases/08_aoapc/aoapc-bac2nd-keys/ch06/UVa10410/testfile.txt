/*
 * UVa 10410 Tree Reconstruction (strict SysY)
 *
 * Input (repeated until sentinel 0):
 *   N
 *   B[1..N]  (BFS order)
 *   D[1..N]  (DFS preorder)
 * Output:
 *   Adjacency list of reconstructed rooted tree.
 *
 * Note: EOF-driven input is refactored to a sentinel N==0 for SysY.
 */

const int MAXN = 1100;
const int MAXE = 1100;

int N;
int B[MAXN];
int D[MAXN];
int BIdx[MAXN];

int head[MAXN];
int tail[MAXN];
int to[MAXE];
int nxt[MAXE];
int edgeCnt;

void addChild(int u, int v) {
    edgeCnt = edgeCnt + 1;
    to[edgeCnt] = v;
    nxt[edgeCnt] = 0;
    if (head[u] == 0) {
        head[u] = edgeCnt;
    } else {
        nxt[tail[u]] = edgeCnt;
    }
    tail[u] = edgeCnt;
    return;
}

void solve(int l, int r) {
    if (l >= r) return;

    int u;
    int i;
    int lasti;
    int lastv;
    int v;

    u = D[l];
    i = l + 1;
    lasti = i;

    lastv = D[i];
    addChild(u, lastv);

    for (i = i + 1; i <= r; i = i + 1) {
        v = D[i];
        if (v > lastv && BIdx[lastv] + 1 == BIdx[v]) {
            solve(lasti, i - 1);
            addChild(u, v);
            lasti = i;
            lastv = v;
        }
    }

    solve(lasti, r);
    return;
}

int main() {
    int i;
    int e;

    for (;;) {
        N = getint();
        if (N == 0) break;

        edgeCnt = 0;
        for (i = 1; i <= N; i = i + 1) {
            B[i] = getint();
            BIdx[B[i]] = i;
            head[i] = 0;
            tail[i] = 0;
        }
        for (i = 1; i <= N; i = i + 1) {
            D[i] = getint();
        }

        solve(1, N);

        for (i = 1; i <= N; i = i + 1) {
            printf("%d:", i);
            for (e = head[i]; e != 0; e = nxt[e]) {
                printf(" %d", to[e]);
            }
            printf("\n");
        }
    }

    return 0;
}
