const int MAXN = 10;
const int MAXE = 2 * (MAXN - 1);
const int MAXMASK = 1024;
const int MAXST = MAXMASK * MAXN;

int pow2[MAXN];

int n;
int m;
int S;
int T;
int O[MAXN];

int head[MAXN];
int toV[MAXE];
int nextE[MAXE];
int edgeCnt;

int vis[MAXST];
int distArr[MAXST];
int preState[MAXST];
int preFrom[MAXST];
int preTo[MAXST];

int q[MAXST];
int qTail;

int pathFrom[MAXST];
int pathTo[MAXST];

void init_pow2() {
  int i;
  pow2[0] = 1;
  for (i = 1; i < MAXN; i = i + 1) {
    pow2[i] = pow2[i - 1] * 2;
  }
}

int isRock(int mask, int pos) {
  int t;
  t = mask / pow2[pos];
  t = t % 2;
  return t;
}

void addEdge(int u, int v) {
  toV[edgeCnt] = v;
  nextE[edgeCnt] = head[u];
  head[u] = edgeCnt;
  edgeCnt = edgeCnt + 1;
}

void tryMove(int mask, int rp, int from, int curId, int curDist) {
  int e;
  for (e = head[from]; e != -1; e = nextE[e]) {
    int v;
    int newRp;
    int newMask;
    int nid;
    v = toV[e];
    if (v == rp) {
      continue;
    }
    if (isRock(mask, v) == 1) {
      continue;
    }
    newRp = rp;
    newMask = mask;
    if (from == rp) {
      newRp = v;
    } else {
      newMask = mask - pow2[from] + pow2[v];
    }
    nid = newRp + newMask * MAXN;
    if (vis[nid] == 0) {
      vis[nid] = 1;
      distArr[nid] = curDist + 1;
      preState[nid] = curId;
      preFrom[nid] = from;
      preTo[nid] = v;
      q[qTail] = nid;
      qTail = qTail + 1;
    }
  }
}

void solve_case() {
  int i;
  int startMask;
  int startId;
  int foundId;

  for (i = 0; i < MAXST; i = i + 1) {
    vis[i] = 0;
    preState[i] = -1;
  }

  startMask = 0;
  for (i = 0; i < m; i = i + 1) {
    int pos;
    pos = O[i];
    if (0 <= pos && pos < n) {
      if (isRock(startMask, pos) == 0) {
        startMask = startMask + pow2[pos];
      }
    }
  }

  startId = S + startMask * MAXN;
  vis[startId] = 1;
  distArr[startId] = 0;
  preState[startId] = -1;

  qTail = 0;
  q[qTail] = startId;
  qTail = qTail + 1;

  foundId = -1;
  for (i = 0; i < qTail; i = i + 1) {
    int id;
    int rp;
    int mask;
    int curDist;
    int j;

    id = q[i];
    rp = id % MAXN;
    mask = id / MAXN;
    curDist = distArr[id];

    if (rp == T) {
      foundId = id;
      break;
    }

    tryMove(mask, rp, rp, id, curDist);
    for (j = 0; j < n; j = j + 1) {
      if (isRock(mask, j) == 1) {
        tryMove(mask, rp, j, id, curDist);
      }
    }
  }

  if (foundId == -1) {
    printf("-1\n");
    return;
  }

  printf("%d\n", distArr[foundId]);

  {
    int len;
    int cur;
    int k;
    len = 0;
    cur = foundId;
    for (;;) {
      if (preState[cur] == -1) {
        break;
      }
      pathFrom[len] = preFrom[cur];
      pathTo[len] = preTo[cur];
      len = len + 1;
      cur = preState[cur];
    }
    for (k = len - 1; k >= 0; k = k - 1) {
      printf("%d %d\n", pathFrom[k] + 1, pathTo[k] + 1);
    }
  }
}

int main() {
  int K;
  int t;

  init_pow2();
  K = getint();

  for (t = 1; t <= K; t = t + 1) {
    int i;
    int u;
    int v;

    n = getint();
    m = getint();
    S = getint();
    T = getint();
    S = S - 1;
    T = T - 1;

    for (i = 0; i < m; i = i + 1) {
      O[i] = getint() - 1;
    }

    for (i = 0; i < MAXN; i = i + 1) {
      head[i] = -1;
    }
    edgeCnt = 0;
    for (i = 0; i < n - 1; i = i + 1) {
      u = getint() - 1;
      v = getint() - 1;
      addEdge(u, v);
      addEdge(v, u);
    }

    printf("Case %d: ", t);
    solve_case();
    printf("\n");
  }

  return 0;
}
