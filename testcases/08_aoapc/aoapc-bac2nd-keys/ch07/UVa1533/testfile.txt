// Moving Pegs (UVa1533) - Strict SysY version
// Input:
//   T
//   e1
//   e2
//   ...
// Output: for each e
//   either:
//     <moves>\n
//     <from1> <to1> <from2> <to2> ...\n
//   or:
//     IMPOSSIBLE\n

const int N = 7;
const int D = 6;

// Flattened DIRS[i][d] => DIRS[i*6 + d], i in [0..N], d in [0..5]
// A simple 1-D board: two directions (left/right) stored in d=0/1, others are 0.
const int DIRS[48] = {
  0,0,3,4,5,6,
  0,2,4,5,6,7,
  1,3,5,6,7,0,
  2,4,6,7,0,0,
  3,5,7,0,0,0,
  4,6,0,0,0,0,
  5,7,0,0,0,0,
  6,0,0,0,0,0
};

int pow2[8];
int fullMask;

int visStamp[128];
int stamp;

int parentMask[128];
int moveFrom[128];
int moveTo[128];

int q[128];

int get_dir(int i, int d) {
  return DIRS[i * 6 + d];
}

int is_occupied(int mask, int i) {
  int t;
  t = mask / pow2[i];
  t = t % 2;
  return t;
}

int find_jump(int mask, int i, int d) {
  int j;
  j = get_dir(i, d);
  if (j == 0) return 0;
  if (is_occupied(mask, j) == 0) return 0;
  for (; j != 0 && is_occupied(mask, j) != 0; ) {
    j = get_dir(j, d);
  }
  return j;
}

void solve(int e) {
  int startMask;
  int goalMask;
  int head;
  int tail;
  int startIdx;
  int found;
  int curMask;
  int i;
  int d;

  stamp = stamp + 1;

  startMask = fullMask - pow2[e];
  goalMask = pow2[e];
  startIdx = startMask / 2;

  visStamp[startIdx] = stamp;
  parentMask[startIdx] = -1;

  head = 0;
  tail = 0;
  q[tail] = startMask;
  tail = tail + 1;

  found = 0;
  for (; head < tail; head = head + 1) {
    int mask;
    mask = q[head];

    if (mask == goalMask) {
      found = 1;
      curMask = mask;
      head = tail;
    } else {
      for (i = 1; i <= N; i = i + 1) {
        if (is_occupied(mask, i) == 0) {
        } else {
          for (d = 0; d < D; d = d + 1) {
            int t;
            t = find_jump(mask, i, d);
            if (t == 0) {
            } else {
              int newMask;
              int j;
              int newIdx;

              newMask = mask - pow2[i];
              j = get_dir(i, d);
              for (; j != t; ) {
                newMask = newMask - pow2[j];
                j = get_dir(j, d);
              }
              newMask = newMask + pow2[t];

              newIdx = newMask / 2;
              if (visStamp[newIdx] == stamp) {
              } else {
                visStamp[newIdx] = stamp;
                parentMask[newIdx] = mask;
                moveFrom[newIdx] = i;
                moveTo[newIdx] = t;
                q[tail] = newMask;
                tail = tail + 1;
              }
            }
          }
        }
      }
    }
  }

  if (found == 0) {
    printf("IMPOSSIBLE\n");
  } else {
    int pathF[64];
    int pathT[64];
    int moves;
    int idx;

    moves = 0;
    curMask = goalMask;
    for (; curMask != startMask; ) {
      idx = curMask / 2;
      pathF[moves] = moveFrom[idx];
      pathT[moves] = moveTo[idx];
      moves = moves + 1;
      curMask = parentMask[idx];
    }

    printf("%d\n", moves);

    if (moves > 0) {
      int k;
      k = moves - 1;
      printf("%d", pathF[k]);
      printf(" %d", pathT[k]);
      for (k = moves - 2; k >= 0; k = k - 1) {
        printf(" %d", pathF[k]);
        printf(" %d", pathT[k]);
      }
      printf("\n");
    } else {
      printf("\n");
    }
  }
}

int main() {
  int i;
  int T;
  int e;

  pow2[0] = 1;
  for (i = 1; i <= N; i = i + 1) {
    pow2[i] = pow2[i - 1] * 2;
  }

  fullMask = 0;
  for (i = 1; i <= N; i = i + 1) {
    fullMask = fullMask + pow2[i];
  }

  stamp = 0;

  T = getint();
  for (i = 0; i < T; i = i + 1) {
    e = getint();
    solve(e);
  }
  return 0;
}
