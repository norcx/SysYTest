/* UVa817: According to Bartjens (SysY adaptation)
 * Input format (newline-separated integers):
 *   m, then m digits (0..9); repeat; m==0 terminates.
 */
const int TARGET = 2000;
const int OP_NUM = 0;
const int OP_ADD = 1;
const int OP_SUB = 2;
const int OP_MUL = 3;

int digits[16];
int m;

int tokOp[64];
int tokVal[64];
int tokLen;
int found;

int eval(int l, int r) {
  int sum;
  int term;
  int sign;
  int i;
  int op;
  int val;

  sum = 0;
  term = tokVal[l];
  sign = 1;

  for (i = l + 1; i < r; i = i + 2) {
    op = tokOp[i];
    val = tokVal[i + 1];

    if (op == OP_ADD) {
      sum = sum + sign * term;
      term = val;
      sign = 1;
    } else if (op == OP_SUB) {
      sum = sum + sign * term;
      term = val;
      sign = -1;
    } else {
      term = term * val;
    }
  }

  return sum + sign * term;
}

void print_exp() {
  int i;
  printf("  ");
  for (i = 0; i < tokLen; i = i + 1) {
    if (tokOp[i] == OP_NUM) {
      printf("%d", tokVal[i]);
    } else if (tokOp[i] == OP_ADD) {
      printf("+");
    } else if (tokOp[i] == OP_SUB) {
      printf("-");
    } else {
      printf("*");
    }
  }
  printf("=\n");
}

void dfs(int pos) {
  int digit;
  int lastVal;
  int opIndex;
  int op;

  if (pos == m) {
    if (eval(0, tokLen - 1) == TARGET) {
      print_exp();
      found = 1;
    }
    return;
  }

  digit = digits[pos];

  for (opIndex = 0; opIndex < 3; opIndex = opIndex + 1) {
    op = OP_SUB;
    if (opIndex == 0) {
      op = OP_MUL;
    } else if (opIndex == 1) {
      op = OP_ADD;
    }

    tokOp[tokLen] = op;
    tokVal[tokLen] = 0;
    tokLen = tokLen + 1;

    tokOp[tokLen] = OP_NUM;
    tokVal[tokLen] = digit;
    tokLen = tokLen + 1;

    dfs(pos + 1);

    tokLen = tokLen - 2;
  }

  lastVal = tokVal[tokLen - 1];
  if (lastVal != 0) {
    tokVal[tokLen - 1] = lastVal * 10 + digit;
    dfs(pos + 1);
    tokVal[tokLen - 1] = lastVal;
  }
}

int main() {
  int t;
  int i;

  t = 1;
  for (;;) {
    m = getint();
    if (m == 0) {
      break;
    }
    for (i = 0; i < m; i = i + 1) {
      digits[i] = getint();
    }

    printf("Problem %d\n", t);

    if (m == 4 && digits[0] == 2 && digits[1] == 0 && digits[2] == 0 && digits[3] == 0) {
      printf("  IMPOSSIBLE\n");
    } else {
      found = 0;
      tokLen = 1;
      tokOp[0] = OP_NUM;
      tokVal[0] = digits[0];

      dfs(1);

      if (found == 0) {
        printf("  IMPOSSIBLE\n");
      }
    }

    t = t + 1;
  }
  return 0;
}
