/* UVa10384 The Wall Pushers (converted to Strict SysY)
 * Output: path as digits (0=W,1=N,2=E,3=S)
 */
const int R = 4;
const int C = 6;
const int RC = 24;

int cells[24];
int vis[24];
int path[512];
int pathLen;

int dx[4] = {0, -1, 0, 1};
int dy[4] = {-1, 0, 1, 0};
int revd[4] = {2, 3, 0, 1};
int pow2[4] = {1, 2, 4, 8};

int idx(int x, int y) { return x * C + y; }

int isValid(int x, int y) {
  if (x < 0) return 0;
  if (x >= R) return 0;
  if (y < 0) return 0;
  if (y >= C) return 0;
  return 1;
}

int getbit(int v, int b) { return (v / pow2[b]) % 2; }

int getCellBit(int pos, int b) { return getbit(cells[pos], b); }

void setCellBit(int pos, int b, int val) {
  int old;
  old = getCellBit(pos, b);
  if (old == val) return;
  if (val == 1) cells[pos] = cells[pos] + pow2[b];
  else cells[pos] = cells[pos] - pow2[b];
}

int isExit(int x, int y) {
  int pos;
  pos = idx(x, y);

  if (x == 0 && getCellBit(pos, 1) == 0) {
    path[pathLen] = 1;
    pathLen = pathLen + 1;
    return 1;
  }
  if (y == 0 && getCellBit(pos, 0) == 0) {
    path[pathLen] = 0;
    pathLen = pathLen + 1;
    return 1;
  }
  if (x == R - 1 && getCellBit(pos, 3) == 0) {
    path[pathLen] = 3;
    pathLen = pathLen + 1;
    return 1;
  }
  if (y == C - 1 && getCellBit(pos, 2) == 0) {
    path[pathLen] = 2;
    pathLen = pathLen + 1;
    return 1;
  }
  return 0;
}

int dfs(int x, int y, int d, int maxd) {
  int i;
  int ax;
  int ay;
  int pos;
  int npos;
  int aax;
  int aay;

  pos = idx(x, y);
  if (isExit(x, y) == 1) return 1;
  if (d >= maxd) return 0;

  for (i = 0; i < 4; i = i + 1) {
    ax = x + dx[i];
    ay = y + dy[i];
    if (isValid(ax, ay) == 1) {
      npos = idx(ax, ay);
      if (vis[npos] == 0) {
        path[pathLen] = i;
        pathLen = pathLen + 1;
        vis[npos] = 1;

        if (getCellBit(pos, i) == 0) {
          if (dfs(ax, ay, d + 1, maxd) == 1) return 1;
        } else {
          if (getCellBit(npos, i) == 0) {
            setCellBit(pos, i, 0);
            setCellBit(npos, i, 1);
            setCellBit(npos, revd[i], 0);

            aax = ax + dx[i];
            aay = ay + dy[i];
            if (isValid(aax, aay) == 1) {
              setCellBit(idx(aax, aay), revd[i], 1);
            }

            if (dfs(ax, ay, d + 1, maxd) == 1) return 1;

            if (isValid(aax, aay) == 1) {
              setCellBit(idx(aax, aay), revd[i], 0);
            }
            setCellBit(pos, i, 1);
            setCellBit(npos, i, 0);
            setCellBit(npos, revd[i], 1);
          }
        }

        vis[npos] = 0;
        pathLen = pathLen - 1;
      }
    }
  }

  return 0;
}

int main() {
  int sx;
  int sy;
  int i;
  int j;
  int maxd;

  for (;;) {
    sy = getint();
    sx = getint();
    if (sy == 0) break;
    if (sx == 0) break;

    for (i = 0; i < R; i = i + 1) {
      for (j = 0; j < C; j = j + 1) {
        cells[idx(i, j)] = getint();
      }
    }

    sx = sx - 1;
    sy = sy - 1;

    maxd = 1;
    for (;;) {
      for (i = 0; i < RC; i = i + 1) vis[i] = 0;
      pathLen = 0;
      vis[idx(sx, sy)] = 1;

      if (dfs(sx, sy, 0, maxd) == 1) break;
      maxd = maxd + 1;
    }

    for (i = 0; i < pathLen; i = i + 1) {
      printf("%d", path[i]);
    }
    printf("\n");
  }

  return 0;
}
