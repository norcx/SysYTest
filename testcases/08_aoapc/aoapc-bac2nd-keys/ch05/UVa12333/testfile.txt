/* Description:
 *   Scaled-down "Revenge of Fibonacci" prefix-to-index lookup.
 *
 * Input (strict integers, 1 per line):
 *   T
 *   For each case:
 *     L
 *     d0
 *     d1
 *     ...
 *     d(L-1)
 *
 * Query is the digit string d0d1...d(L-1). If query is exactly "1", answer is 0.
 * Otherwise, answer is the smallest i (2 <= i < MAXF) such that Fibonacci(i)'s
 * decimal representation starts with the query. If no match, answer is -1.
 */

const int BASE = 10000;
const int MAXF = 3000;
const int MAXLEN = 200;
const int PFX_MAX = 16;

const int TRIE_MAXNODE = 50000;
const int TRIE_SIGMA = 10;

int trie_ch[500000];
int trie_val[50000];
int trie_sz;

int f0[200];
int f1[200];
int f2[200];
int len0;
int len1;
int len2;

int pfx_digits[16];
int qry_digits[16];

int big_copy(int src[], int srcLen, int dst[]) {
    int i;
    for (i = 0; i < srcLen; i = i + 1) {
        dst[i] = src[i];
    }
    return srcLen;
}

int big_add(int a[], int aLen, int b[], int bLen, int c[]) {
    int i;
    int carry;
    int maxLen;
    carry = 0;
    maxLen = aLen;
    if (bLen > maxLen) maxLen = bLen;
    for (i = 0; i < maxLen; i = i + 1) {
        int x;
        x = carry;
        if (i < aLen) x = x + a[i];
        if (i < bLen) x = x + b[i];
        c[i] = x % BASE;
        carry = x / BASE;
    }
    if (carry > 0) {
        c[maxLen] = carry;
        maxLen = maxLen + 1;
    }
    return maxLen;
}

int get_prefix_digits(int a[], int aLen, int out[], int maxOut) {
    int outLen;
    int msb;
    int dcount;
    int div;
    int tmp;
    int k;
    int i;

    outLen = 0;
    if (aLen <= 0) return 0;

    msb = a[aLen - 1];
    dcount = 1;
    if (msb >= 1000) dcount = 4;
    else if (msb >= 100) dcount = 3;
    else if (msb >= 10) dcount = 2;
    else dcount = 1;

    div = 1;
    if (dcount == 4) div = 1000;
    else if (dcount == 3) div = 100;
    else if (dcount == 2) div = 10;
    else div = 1;

    tmp = msb;
    for (k = 0; k < dcount; k = k + 1) {
        if (outLen >= maxOut) return outLen;
        out[outLen] = tmp / div;
        tmp = tmp - out[outLen] * div;
        outLen = outLen + 1;
        div = div / 10;
    }

    for (i = aLen - 2; i >= 0; i = i - 1) {
        int block;
        int d0;
        int d1;
        int d2;
        int d3;

        block = a[i];
        d0 = block / 1000;
        block = block - d0 * 1000;
        d1 = block / 100;
        block = block - d1 * 100;
        d2 = block / 10;
        d3 = block - d2 * 10;

        if (outLen >= maxOut) return outLen;
        out[outLen] = d0;
        outLen = outLen + 1;
        if (outLen >= maxOut) return outLen;
        out[outLen] = d1;
        outLen = outLen + 1;
        if (outLen >= maxOut) return outLen;
        out[outLen] = d2;
        outLen = outLen + 1;
        if (outLen >= maxOut) return outLen;
        out[outLen] = d3;
        outLen = outLen + 1;
    }

    return outLen;
}

int trie_new_node(int v) {
    int node;
    int k;
    node = trie_sz;
    trie_sz = trie_sz + 1;
    trie_val[node] = v;
    for (k = 0; k < TRIE_SIGMA; k = k + 1) {
        trie_ch[node * TRIE_SIGMA + k] = 0;
    }
    return node;
}

void trie_init() {
    int k;
    trie_sz = 1;
    trie_val[0] = 0;
    for (k = 0; k < TRIE_SIGMA; k = k + 1) {
        trie_ch[k] = 0;
    }
}

void trie_insert(int digits[], int dlen, int v) {
    int u;
    int i;
    u = 0;
    for (i = 0; i < dlen; i = i + 1) {
        int c;
        int idx;
        int nxt;
        c = digits[i];
        idx = u * TRIE_SIGMA + c;
        nxt = trie_ch[idx];
        if (nxt == 0) {
            nxt = trie_new_node(v);
            trie_ch[idx] = nxt;
        }
        u = nxt;
    }
    if (trie_val[u] == 0) trie_val[u] = v;
}

int trie_get_value(int digits[], int dlen) {
    int u;
    int v;
    int i;
    u = 0;
    v = -1;
    for (i = 0; i < dlen; i = i + 1) {
        int c;
        int idx;
        int nxt;
        c = digits[i];
        idx = u * TRIE_SIGMA + c;
        nxt = trie_ch[idx];
        if (nxt == 0) return v;
        u = nxt;
    }
    if (trie_val[u] != 0) v = trie_val[u];
    return v;
}

int main() {
    int i;
    int T;
    int t;

    trie_init();

    len0 = 1;
    len1 = 1;
    f0[0] = 1;
    f1[0] = 1;

    for (i = 2; i < MAXF; i = i + 1) {
        int pLen;
        len2 = big_add(f0, len0, f1, len1, f2);
        pLen = get_prefix_digits(f2, len2, pfx_digits, PFX_MAX);
        trie_insert(pfx_digits, pLen, i);
        len0 = big_copy(f1, len1, f0);
        len1 = big_copy(f2, len2, f1);
    }

    T = getint();
    for (t = 1; t <= T; t = t + 1) {
        int L;
        int storeLen;
        int j;
        int ans;

        L = getint();
        storeLen = L;
        if (storeLen > PFX_MAX) storeLen = PFX_MAX;

        for (j = 0; j < L; j = j + 1) {
            int d;
            d = getint();
            if (j < storeLen) qry_digits[j] = d;
        }

        ans = 0;
        if (L == 1 && qry_digits[0] == 1) {
            ans = 0;
        } else {
            if (L > PFX_MAX) ans = -1;
            else ans = trie_get_value(qry_digits, L);
        }

        printf("Case #%d: %d\n", t, ans);
    }

    return 0;
}
