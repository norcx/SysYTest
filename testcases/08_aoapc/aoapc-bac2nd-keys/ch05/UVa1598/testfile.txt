/*
 * Exchange (UVa 1598) converted to Strict SysY.
 *
 * Input encoding (integers only, one per line):
 *   Repeated datasets, ended by a single 0 line.
 *   For each dataset:
 *     n
 *     then n commands, each encoded as:
 *       1 size price   (BUY)
 *       2 size price   (SELL)
 *       3 x            (CANCEL command #x, 1-based within the dataset)
 */

const int MAXN = 10010;
const int INF_ASK = 99999;

int orderBuy[MAXN];
int orderSize[MAXN];
int orderPrice[MAXN];
int canceled[MAXN];

int orderIndexForCmd[MAXN];
int orderCount;

int buyHeap[MAXN];
int buyPos[MAXN];
int buyHeapSize;

int sellHeap[MAXN];
int sellPos[MAXN];
int sellHeapSize;

int buyBetter(int a, int b) {
    if (orderPrice[a] > orderPrice[b]) return 1;
    if (orderPrice[a] < orderPrice[b]) return 0;
    if (a < b) return 1;
    return 0;
}

int sellBetter(int a, int b) {
    if (orderPrice[a] < orderPrice[b]) return 1;
    if (orderPrice[a] > orderPrice[b]) return 0;
    if (a < b) return 1;
    return 0;
}

void buySwap(int i, int j) {
    int ai;
    int aj;
    ai = buyHeap[i];
    aj = buyHeap[j];
    buyHeap[i] = aj;
    buyHeap[j] = ai;
    buyPos[ai] = j;
    buyPos[aj] = i;
}

void sellSwap(int i, int j) {
    int ai;
    int aj;
    ai = sellHeap[i];
    aj = sellHeap[j];
    sellHeap[i] = aj;
    sellHeap[j] = ai;
    sellPos[ai] = j;
    sellPos[aj] = i;
}

int buyEmpty() {
    if (buyHeapSize == 0) return 1;
    return 0;
}

int sellEmpty() {
    if (sellHeapSize == 0) return 1;
    return 0;
}

int buyTop() { return buyHeap[1]; }
int sellTop() { return sellHeap[1]; }

int buyTopPrice() { return orderPrice[buyTop()]; }
int sellTopPrice() { return orderPrice[sellTop()]; }

void buyUp(int idx) {
    int p;
    for (; idx > 1; ) {
        p = idx / 2;
        if (buyBetter(buyHeap[idx], buyHeap[p]) == 1) {
            buySwap(idx, p);
            idx = p;
        } else {
            break;
        }
    }
}

void sellUp(int idx) {
    int p;
    for (; idx > 1; ) {
        p = idx / 2;
        if (sellBetter(sellHeap[idx], sellHeap[p]) == 1) {
            sellSwap(idx, p);
            idx = p;
        } else {
            break;
        }
    }
}

void buyDown(int idx) {
    int l;
    int r;
    int best;
    for (; ; ) {
        l = idx * 2;
        if (l > buyHeapSize) break;
        r = l + 1;
        best = l;
        if (r <= buyHeapSize && buyBetter(buyHeap[r], buyHeap[l]) == 1) best = r;
        if (buyBetter(buyHeap[best], buyHeap[idx]) == 1) {
            buySwap(best, idx);
            idx = best;
        } else {
            break;
        }
    }
}

void sellDown(int idx) {
    int l;
    int r;
    int best;
    for (; ; ) {
        l = idx * 2;
        if (l > sellHeapSize) break;
        r = l + 1;
        best = l;
        if (r <= sellHeapSize && sellBetter(sellHeap[r], sellHeap[l]) == 1) best = r;
        if (sellBetter(sellHeap[best], sellHeap[idx]) == 1) {
            sellSwap(best, idx);
            idx = best;
        } else {
            break;
        }
    }
}

void buyPush(int oi) {
    buyHeapSize = buyHeapSize + 1;
    buyHeap[buyHeapSize] = oi;
    buyPos[oi] = buyHeapSize;
    buyUp(buyHeapSize);
}

void sellPush(int oi) {
    sellHeapSize = sellHeapSize + 1;
    sellHeap[sellHeapSize] = oi;
    sellPos[oi] = sellHeapSize;
    sellUp(sellHeapSize);
}

int buyPop() {
    int ans;
    ans = buyHeap[1];
    buySwap(1, buyHeapSize);
    buyHeapSize = buyHeapSize - 1;
    buyPos[ans] = 0;
    if (buyHeapSize >= 1) buyDown(1);
    return ans;
}

int sellPop() {
    int ans;
    ans = sellHeap[1];
    sellSwap(1, sellHeapSize);
    sellHeapSize = sellHeapSize - 1;
    sellPos[ans] = 0;
    if (sellHeapSize >= 1) sellDown(1);
    return ans;
}

void buyErase(int oi) {
    int idx;
    idx = buyPos[oi];
    if (idx == 0) return;
    buySwap(idx, buyHeapSize);
    buyHeapSize = buyHeapSize - 1;
    buyPos[oi] = 0;
    if (idx <= buyHeapSize) {
        buyUp(idx);
        buyDown(idx);
    }
}

void sellErase(int oi) {
    int idx;
    idx = sellPos[oi];
    if (idx == 0) return;
    sellSwap(idx, sellHeapSize);
    sellHeapSize = sellHeapSize - 1;
    sellPos[oi] = 0;
    if (idx <= sellHeapSize) {
        sellUp(idx);
        sellDown(idx);
    }
}

int buyTopSize() {
    int tp;
    int ans;
    int i;
    int oi;
    tp = buyTopPrice();
    ans = 0;
    for (i = 1; i <= buyHeapSize; i = i + 1) {
        oi = buyHeap[i];
        if (orderPrice[oi] == tp) ans = ans + orderSize[oi];
    }
    return ans;
}

int sellTopSize() {
    int tp;
    int ans;
    int i;
    int oi;
    tp = sellTopPrice();
    ans = 0;
    for (i = 1; i <= sellHeapSize; i = i + 1) {
        oi = sellHeap[i];
        if (orderPrice[oi] == tp) ans = ans + orderSize[oi];
    }
    return ans;
}

void cancelOrder(int cmdIndex) {
    int oi;
    oi = orderIndexForCmd[cmdIndex];
    if (oi < 0) return;
    if (canceled[oi] == 1) return;
    if (orderBuy[oi] == 1) buyErase(oi);
    else sellErase(oi);
    canceled[oi] = 1;
}

void trade(int oi) {
    int askPrice;
    int bidPrice;
    int toi;
    int tradeSize;

    if (orderBuy[oi] == 1) {
        if (sellEmpty() == 1 || orderPrice[oi] < sellTopPrice()) {
            buyPush(oi);
            return;
        }

        for (; ; ) {
            if (sellEmpty() == 1) break;
            if (orderSize[oi] <= 0) break;
            askPrice = sellTopPrice();
            if (orderPrice[oi] < askPrice) break;

            toi = sellTop();
            tradeSize = orderSize[oi];
            if (orderSize[toi] < tradeSize) tradeSize = orderSize[toi];
            printf("TRADE %d %d\n", tradeSize, askPrice);

            orderSize[toi] = orderSize[toi] - tradeSize;
            orderSize[oi] = orderSize[oi] - tradeSize;
            sellPop();

            if (orderSize[toi] == 0) canceled[toi] = 1;
            else sellPush(toi);
        }

        if (orderSize[oi] > 0) buyPush(oi);
        else canceled[oi] = 1;
        return;
    }

    if (buyEmpty() == 1 || orderPrice[oi] > buyTopPrice()) {
        sellPush(oi);
        return;
    }

    for (; ; ) {
        if (buyEmpty() == 1) break;
        if (orderSize[oi] <= 0) break;
        bidPrice = buyTopPrice();
        if (orderPrice[oi] > bidPrice) break;

        toi = buyTop();
        tradeSize = orderSize[oi];
        if (orderSize[toi] < tradeSize) tradeSize = orderSize[toi];
        printf("TRADE %d %d\n", tradeSize, bidPrice);

        orderSize[toi] = orderSize[toi] - tradeSize;
        orderSize[oi] = orderSize[oi] - tradeSize;
        buyPop();

        if (orderSize[toi] == 0) canceled[toi] = 1;
        else buyPush(toi);
    }

    if (orderSize[oi] > 0) sellPush(oi);
    else canceled[oi] = 1;
}

void quote() {
    int bidSize;
    int bidPrice;
    int askSize;
    int askPrice;

    bidSize = 0;
    bidPrice = 0;
    askSize = 0;
    askPrice = INF_ASK;

    if (buyEmpty() == 0) {
        bidSize = buyTopSize();
        bidPrice = buyTopPrice();
    }
    if (sellEmpty() == 0) {
        askSize = sellTopSize();
        askPrice = sellTopPrice();
    }

    printf("QUOTE %d %d - %d %d\n", bidSize, bidPrice, askSize, askPrice);
}

void resetCase(int n) {
    int i;
    orderCount = 0;
    buyHeapSize = 0;
    sellHeapSize = 0;
    for (i = 0; i < MAXN; i = i + 1) {
        buyPos[i] = 0;
        sellPos[i] = 0;
        canceled[i] = 0;
    }
    for (i = 0; i < n; i = i + 1) orderIndexForCmd[i] = -1;
}

int main() {
    int first;
    int n;
    int i;
    int typ;
    int size;
    int price;
    int x;
    int oi;

    first = 1;
    for (; ; ) {
        n = getint();
        if (n == 0) break;
        if (first == 0) printf("\n");
        first = 0;

        resetCase(n);
        for (i = 0; i < n; i = i + 1) {
            typ = getint();
            if (typ == 3) {
                x = getint();
                cancelOrder(x - 1);
                quote();
            } else {
                size = getint();
                price = getint();

                oi = orderCount;
                orderCount = orderCount + 1;

                orderBuy[oi] = 0;
                if (typ == 1) orderBuy[oi] = 1;
                orderSize[oi] = size;
                orderPrice[oi] = price;
                canceled[oi] = 0;
                orderIndexForCmd[i] = oi;

                trade(oi);
                quote();
            }
        }
    }
    return 0;
}
