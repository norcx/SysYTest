/* Description:
 *   UVA1596 Bug Hunt (encoded integer input).
 *
 * Input encoding (one integer per line):
 *   op = getint()
 *   op == 0: end
 *   op == 1: end current program => print bugLine, reset
 *   op == 2: declare array: name, size
 *   op == 3: assignment: name, rhsExpr, indexExpr
 *
 * Expr encoding:
 *   kind == 0: literal: value
 *   kind == 1: array element: name, indexExpr
 */

const int MAXA = 128;
const int MAXS = 64;

int arr_size[MAXA];
int arr_has[MAXA * MAXS];
int arr_val[MAXA * MAXS];

int expr_ok;

void clear_array_slots(int name) {
    int base;
    int i;
    base = name * MAXS;
    i = 0;
    for (i = 0; i < MAXS; i = i + 1) {
        arr_has[base + i] = 0;
    }
}

void reset_all() {
    int i;
    i = 0;
    for (i = 0; i < MAXA; i = i + 1) {
        arr_size[i] = -1;
    }
    i = 0;
    for (i = 0; i < MAXA * MAXS; i = i + 1) {
        arr_has[i] = 0;
    }
}

void init_array(int name, int sz) {
    if (name < 0) return;
    if (name >= MAXA) return;
    arr_size[name] = sz;
    clear_array_slots(name);
}

int set_value(int name, int idx, int v) {
    int base;
    if (name < 0) return 0;
    if (name >= MAXA) return 0;
    if (arr_size[name] < 0) return 0;
    if (idx < 0) return 0;
    if (idx >= arr_size[name]) return 0;
    if (idx >= MAXS) return 0;
    base = name * MAXS + idx;
    arr_has[base] = 1;
    arr_val[base] = v;
    return 1;
}

void skip_expr() {
    int kind;
    kind = getint();
    if (kind == 0) {
        getint();
        return;
    }
    getint();
    skip_expr();
}

int eval_expr() {
    int kind;
    int v;
    int name;
    int idx;
    int base;

    kind = getint();
    if (kind == 0) {
        v = getint();
        return v;
    }

    name = getint();
    idx = eval_expr();
    if (expr_ok == 0) return 0;

    if (name < 0) {
        expr_ok = 0;
        return 0;
    }
    if (name >= MAXA) {
        expr_ok = 0;
        return 0;
    }
    if (arr_size[name] < 0) {
        expr_ok = 0;
        return 0;
    }
    if (idx < 0) {
        expr_ok = 0;
        return 0;
    }
    if (idx >= arr_size[name]) {
        expr_ok = 0;
        return 0;
    }
    if (idx >= MAXS) {
        expr_ok = 0;
        return 0;
    }

    base = name * MAXS + idx;
    if (arr_has[base] == 0) {
        expr_ok = 0;
        return 0;
    }
    return arr_val[base];
}

int main() {
    int op;
    int name;
    int sz;
    int lineNum;
    int bugLine;
    int rv;
    int idx;
    int rhs_ok;
    int idx_ok;

    reset_all();
    lineNum = 0;
    bugLine = 0;

    for (;;) {
        op = getint();
        if (op == 0) {
            return 0;
        }
        if (op == 1) {
            printf("%d\n", bugLine);
            reset_all();
            lineNum = 0;
            bugLine = 0;
        } else if (op == 2) {
            name = getint();
            sz = getint();
            if (bugLine == 0) {
                init_array(name, sz);
                lineNum = lineNum + 1;
            }
        } else if (op == 3) {
            name = getint();
            if (bugLine == 0) {
                if (name < 0) {
                    skip_expr();
                    skip_expr();
                    bugLine = lineNum + 1;
                } else if (name >= MAXA) {
                    skip_expr();
                    skip_expr();
                    bugLine = lineNum + 1;
                } else if (arr_size[name] < 0) {
                    skip_expr();
                    skip_expr();
                    bugLine = lineNum + 1;
                } else {
                    expr_ok = 1;
                    rv = eval_expr();
                    rhs_ok = expr_ok;

                    expr_ok = 1;
                    idx = eval_expr();
                    idx_ok = expr_ok;

                    if (rhs_ok != 0) {
                        if (idx_ok != 0) {
                            if (set_value(name, idx, rv) != 0) {
                                lineNum = lineNum + 1;
                            } else {
                                bugLine = lineNum + 1;
                            }
                        } else {
                            bugLine = lineNum + 1;
                        }
                    } else {
                        bugLine = lineNum + 1;
                    }
                }
            } else {
                skip_expr();
                skip_expr();
            }
        } else {
            return 0;
        }
    }

    return 0;
}
