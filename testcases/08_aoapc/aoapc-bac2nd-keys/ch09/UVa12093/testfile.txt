/* Description:
 *   Protecting Zonk (tree DP), ACM/ICPC Dhaka 2006, UVa12093
 *   Converted to Strict SysY (iterative DFS to avoid recursion depth issues)
 */

const int MAXN = 10010;
const int MAXE = 20020;
const int INF = 2147483647;

int N;
int C1;
int C2;

int head[MAXN];
int to[MAXE];
int nxt[MAXE];
int ecnt;

int parentArr[MAXN];
int stackArr[MAXN];
int orderArr[MAXN];

int dp0[MAXN];
int dp1[MAXN];
int dp2[MAXN];
int dp3[MAXN];

int min2(int a, int b) {
  if (a < b) return a;
  return b;
}

int min3(int a, int b, int c) { return min2(min2(a, b), c); }

int min4(int a, int b, int c, int d) { return min2(min2(a, b), min2(c, d)); }

void addEdge(int u, int v) {
  to[ecnt] = v;
  nxt[ecnt] = head[u];
  head[u] = ecnt;
  ecnt = ecnt + 1;
}

void solveOne() {
  int i;
  int u;
  int v;

  for (i = 1; i <= N; i = i + 1) head[i] = -1;
  ecnt = 0;

  for (i = 1; i <= N - 1; i = i + 1) {
    u = getint();
    v = getint();
    addEdge(u, v);
    addEdge(v, u);
  }

  int top;
  int ord;
  top = 0;
  ord = 0;
  parentArr[1] = 0;
  stackArr[top] = 1;
  top = top + 1;

  for (; top > 0;) {
    top = top - 1;
    u = stackArr[top];
    orderArr[ord] = u;
    ord = ord + 1;

    int e;
    for (e = head[u]; e != -1; e = nxt[e]) {
      v = to[e];
      if (v != parentArr[u]) {
        parentArr[v] = u;
        stackArr[top] = v;
        top = top + 1;
      }
    }
  }

  int idx;
  for (idx = ord - 1; idx >= 0; idx = idx - 1) {
    u = orderArr[idx];

    int D0;
    int D1;
    int D2;
    int D3;
    int U1E;
    int minV0;

    D0 = 0;
    D1 = 0;
    D2 = 0;
    D3 = 0;
    U1E = 0;
    minV0 = INF;

    int e;
    for (e = head[u]; e != -1; e = nxt[e]) {
      v = to[e];
      if (parentArr[v] == u) {
        int w;
        w = min3(dp0[v], dp1[v], dp2[v]);

        D0 = D0 + min4(dp0[v], dp1[v], dp2[v], dp3[v]);
        D1 = D1 + w;
        D2 = D2 + dp1[v];
        D3 = D3 + w;

        U1E = U1E + w;

        int diff;
        diff = dp0[v] - w;
        if (diff < minV0) minV0 = diff;
      }
    }

    D0 = D0 + C2;

    int t1;
    int t2;
    t1 = D1 + C1;
    if (minV0 == INF)
      t2 = INF;
    else
      t2 = U1E + minV0;
    D1 = min2(t1, t2);

    dp0[u] = D0;
    dp1[u] = D1;
    dp2[u] = D2;
    dp3[u] = D3;
  }

  int ans;
  ans = min3(dp0[1], dp1[1], dp2[1]);
  printf("%d\n", ans);
}

int main() {
  for (;;) {
    N = getint();
    if (N == 0) break;
    C1 = getint();
    C2 = getint();
    solveOne();
  }
  return 0;
}
