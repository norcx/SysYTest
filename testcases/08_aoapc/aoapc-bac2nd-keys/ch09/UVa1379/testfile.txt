const int MAXN = 105;
const int MAXM = 205;
const int MAXG = 215;
const int DP_SIZE = 1296;

int N;
int M;
int numG;

int winp[(MAXM + 1) * MAXN];
int pit[(MAXM + 1) * MAXN];
int G[MAXG + 1];

int DP0[DP_SIZE];
int DP1[DP_SIZE];

int idx_win(int op, int j) {
    return op * MAXN + j;
}

int idx_dp(int a, int b, int c, int d) {
    return ((a * 6 + b) * 6 + c) * 6 + d;
}

int getPi(int op, int i) {
    return pit[idx_win(op, i)];
}

int getP(int op, int i) {
    return winp[idx_win(op, i)];
}

void sort_op(int op) {
    int j;
    int k;
    int maxPos;
    int tmp;
    int tmp2;
    for (j = 1; j <= N; j = j + 1) {
        maxPos = j;
        for (k = j + 1; k <= N; k = k + 1) {
            if (getP(op, k) > getP(op, maxPos)) {
                maxPos = k;
            }
        }
        if (maxPos != j) {
            tmp = winp[idx_win(op, j)];
            winp[idx_win(op, j)] = winp[idx_win(op, maxPos)];
            winp[idx_win(op, maxPos)] = tmp;

            tmp2 = pit[idx_win(op, j)];
            pit[idx_win(op, j)] = pit[idx_win(op, maxPos)];
            pit[idx_win(op, maxPos)] = tmp2;
        }
    }
    return;
}

int solve() {
    int i;
    int idx;
    int ans;
    int cur;

    int prev;
    int now;
    int op;

    int p0;
    int p1;
    int p2;
    int p3;
    int p4;

    int opi;
    int dIndex;
    int prevIndex;
    int cand;

    for (idx = 0; idx < DP_SIZE; idx = idx + 1) {
        DP0[idx] = 0;
        DP1[idx] = 0;
    }

    ans = 0;
    cur = 0;

    for (i = 1; i <= numG; i = i + 1) {
        prev = cur;
        now = 1 - cur;
        cur = now;

        if (now == 0) {
            for (idx = 0; idx < DP_SIZE; idx = idx + 1) {
                DP0[idx] = 0;
            }
        } else {
            for (idx = 0; idx < DP_SIZE; idx = idx + 1) {
                DP1[idx] = 0;
            }
        }

        op = G[i];
        if (op == 0) {
            for (p1 = 0; p1 <= 5; p1 = p1 + 1) {
                for (p2 = 0; p2 <= 5; p2 = p2 + 1) {
                    for (p3 = 0; p3 <= 5; p3 = p3 + 1) {
                        for (p4 = 0; p4 <= 5; p4 = p4 + 1) {
                            dIndex = idx_dp(0, p1, p2, p3);
                            prevIndex = idx_dp(p1, p2, p3, p4);

                            if (prev == 0) {
                                cand = DP0[prevIndex];
                            } else {
                                cand = DP1[prevIndex];
                            }

                            if (now == 0) {
                                if (cand > DP0[dIndex]) {
                                    DP0[dIndex] = cand;
                                }
                                if (DP0[dIndex] > ans) {
                                    ans = DP0[dIndex];
                                }
                            } else {
                                if (cand > DP1[dIndex]) {
                                    DP1[dIndex] = cand;
                                }
                                if (DP1[dIndex] > ans) {
                                    ans = DP1[dIndex];
                                }
                            }
                        }
                    }
                }
            }
            continue;
        }

        for (p0 = 1; p0 <= 5; p0 = p0 + 1) {
            opi = getPi(op, p0);
            for (p1 = 0; p1 <= 5; p1 = p1 + 1) {
                if (i > 1 && getPi(G[i - 1], p1) == opi) {
                    continue;
                }
                for (p2 = 0; p2 <= 5; p2 = p2 + 1) {
                    if (i > 2 && getPi(G[i - 2], p2) == opi) {
                        continue;
                    }
                    for (p3 = 0; p3 <= 5; p3 = p3 + 1) {
                        if (i > 3 && getPi(G[i - 3], p3) == opi) {
                            continue;
                        }
                        for (p4 = 0; p4 <= 5; p4 = p4 + 1) {
                            if (i > 4 && getPi(G[i - 4], p4) == opi) {
                                continue;
                            }

                            dIndex = idx_dp(p0, p1, p2, p3);
                            prevIndex = idx_dp(p1, p2, p3, p4);

                            if (prev == 0) {
                                cand = DP0[prevIndex];
                            } else {
                                cand = DP1[prevIndex];
                            }
                            cand = cand + getP(op, p0);

                            if (now == 0) {
                                if (cand > DP0[dIndex]) {
                                    DP0[dIndex] = cand;
                                }
                                if (DP0[dIndex] > ans) {
                                    ans = DP0[dIndex];
                                }
                            } else {
                                if (cand > DP1[dIndex]) {
                                    DP1[dIndex] = cand;
                                }
                                if (DP1[dIndex] > ans) {
                                    ans = DP1[dIndex];
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return ans;
}

int main() {
    int T;
    int tc;
    int i;
    int j;
    int p;
    int ans;
    int integerPart;
    int fracPart;

    T = getint();
    for (tc = 0; tc < T; tc = tc + 1) {
        N = getint();
        M = getint();
        numG = getint();
        numG = numG + 10;

        for (i = 1; i <= M; i = i + 1) {
            for (j = 1; j <= N; j = j + 1) {
                p = getint();
                winp[idx_win(i, j)] = p;
                pit[idx_win(i, j)] = j;
            }
            sort_op(i);
        }

        G[0] = 0;
        for (i = 1; i <= numG; i = i + 1) {
            G[i] = getint();
        }

        ans = solve();
        integerPart = ans / 100;
        fracPart = ans - integerPart * 100;
        if (fracPart < 10) {
            printf("%d.0%d\n", integerPart, fracPart);
        } else {
            printf("%d.%d\n", integerPart, fracPart);
        }
    }
    return 0;
}
