/*
  Converted from a floating-point geometry DP into Strict SysY:
  - Input: multiple cases, each with n, m, then n points (x, y) in CCW order.
  - Output: maximum polygon area (doubled, integer) selecting m vertices.
  - Terminator: a single 0 for n.
*/

const int MAXN = 50;
const int MAXM = 50;
const int DP_SIZE = 50 * 50 * 51;

int X[MAXN];
int Y[MAXN];
int DP[DP_SIZE];

int dpIndex(int i, int j, int k) {
    return (i * MAXN + j) * (MAXM + 1) + k;
}

int absint(int x) {
    if (x < 0) return -x;
    return x;
}

int triArea2(int a, int b, int c) {
    int x1;
    int y1;
    int x2;
    int y2;
    int cross;
    x1 = X[b] - X[a];
    y1 = Y[b] - Y[a];
    x2 = X[c] - X[a];
    y2 = Y[c] - Y[a];
    cross = x1 * y2 - y1 * x2;
    return absint(cross);
}

int solve(int n, int m) {
    int i;
    int j;
    int x;
    int k;
    int idx;
    int val;
    int ans;

    for (i = 0; i < DP_SIZE; i = i + 1) DP[i] = 0;
    if (m < 3) return 0;

    for (k = 3; k <= m; k = k + 1) {
        for (i = 0; i < n; i = i + 1) {
            for (x = i + 1; x < n; x = x + 1) {
                for (j = x + 1; j < n; j = j + 1) {
                    val = DP[dpIndex(i, x, k - 1)] + triArea2(i, x, j);
                    idx = dpIndex(i, j, k);
                    if (val > DP[idx]) DP[idx] = val;
                }
            }
        }
    }

    ans = 0;
    for (i = 0; i < n; i = i + 1) {
        for (j = i + 1; j < n; j = j + 1) {
            val = DP[dpIndex(i, j, m)];
            if (val > ans) ans = val;
        }
    }
    return ans;
}

int main() {
    int n;
    int m;
    int i;
    int ans;

    for (;;) {
        n = getint();
        if (n == 0) break;
        m = getint();
        for (i = 0; i < n; i = i + 1) {
            X[i] = getint();
            Y[i] = getint();
        }
        ans = solve(n, m);
        printf("%d\n", ans);
    }
    return 0;
}
