/*
  Strict SysY translation of the provided C++ program.
  It searches for an Egyptian fraction decomposition of a/b with forbidden denominators.

  Input (newline-separated integers):
    t
    a
    b
    k
    k lines of forbidden denominators
    ... repeated for t cases ...

  Output:
    Case X: a/b=1/x1+1/x2+...+1/xn
    or
    Case X: No solution.
*/

const int MAXN = 110;
const int MAXD = 100;
const int FORB_LIMIT = 20000;

int forbidden[20001];
int v[MAXN];
int ans[MAXN];

int a;
int b;
int k;

void init_case() {
    int i;
    for (i = 0; i <= FORB_LIMIT; i = i + 1) forbidden[i] = 0;
    for (i = 0; i < MAXN; i = i + 1) v[i] = 0;
    for (i = 0; i < MAXN; i = i + 1) ans[i] = -1;
}

int gcd_int(int x, int y) {
    int t;
    if (x < 0) x = 0 - x;
    if (y < 0) y = 0 - y;
    for (;;) {
        if (y == 0) return x;
        t = x % y;
        x = y;
        y = t;
    }
    return 1;
}

int is_forbidden(int x) {
    if (x < 0) return 0;
    if (x <= FORB_LIMIT) return forbidden[x];
    return 0;
}

int better(int d) {
    int i;
    for (i = d; i >= 0; i = i - 1) {
        if (v[i] != ans[i]) {
            if (ans[i] == -1) return 1;
            if (v[i] < ans[i]) return 1;
            return 0;
        }
    }
    return 0;
}

int get_from(int num, int den) {
    return den / num + 1;
}

int dfs(int d, int maxd, int from, int num, int den) {
    int denom;
    int ok;
    int i;
    int a2;
    int b2;
    int g;
    int bound;
    int new_from;

    if (d == maxd) {
        if (den % num != 0) return 0;
        denom = den / num;
        if (is_forbidden(denom) != 0) return 0;
        v[d] = denom;
        if (better(d) != 0) {
            for (i = 0; i <= d; i = i + 1) ans[i] = v[i];
        }
        return 1;
    }

    ok = 0;
    new_from = get_from(num, den);
    if (from < new_from) from = new_from;

    bound = den * (maxd - d + 1) / num;
    bound = bound + 1;
    for (i = from; i <= bound; i = i + 1) {
        if (is_forbidden(i) != 0) continue;
        v[d] = i;

        a2 = i * num - den;
        b2 = i * den;
        g = gcd_int(a2, b2);
        if (dfs(d + 1, maxd, i + 1, a2 / g, b2 / g) != 0) ok = 1;
    }

    return ok;
}

int solve_maxd() {
    int maxd;
    int f;
    int i;
    int ok;
    for (maxd = 1; maxd <= MAXD; maxd = maxd + 1) {
        for (i = 0; i < MAXN; i = i + 1) ans[i] = -1;
        for (i = 0; i < MAXN; i = i + 1) v[i] = 0;
        f = get_from(a, b);
        ok = dfs(0, maxd, f, a, b);
        if (ok != 0) return maxd;
    }
    return -1;
}

int main() {
    int t;
    int kase;
    int i;
    int x;
    int maxd;

    t = getint();
    kase = 0;
    for (; t > 0; t = t - 1) {
        init_case();

        a = getint();
        b = getint();
        k = getint();
        for (i = 0; i < k; i = i + 1) {
            x = getint();
            if (0 <= x && x <= FORB_LIMIT) forbidden[x] = 1;
        }

        maxd = solve_maxd();

        kase = kase + 1;
        printf("Case %d: ", kase);
        if (maxd >= 0) {
            printf("%d/%d=", a, b);
            for (i = 0; i < maxd; i = i + 1) printf("1/%d+", ans[i]);
            printf("1/%d\n", ans[maxd]);
        } else {
            printf("No solution.\n");
        }
    }
    return 0;
}
