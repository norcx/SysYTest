/* Description:
 *   [Add description here]
 */

const int MAXN = 10005;
const int MAXLOG = 15;
const int MAXE = (MAXN - 1) * 2;

int head[MAXN];
int to[MAXE];
int nxt[MAXE];
int edge_cnt;

int parent[MAXN];
int depth[MAXN];
int up[MAXN * MAXLOG];
int order[MAXN];

int mark[MAXN];

void add_edge(int u, int v) {
  to[edge_cnt] = v;
  nxt[edge_cnt] = head[u];
  head[u] = edge_cnt;
  edge_cnt = edge_cnt + 1;
}

void init_graph(int n) {
  int i;
  for (i = 0; i < n; i = i + 1) {
    head[i] = -1;
  }
  edge_cnt = 0;
}

void build_lca(int n) {
  int i;
  int front;
  int back;
  int u;
  int e;
  int v;
  int k;
  int idx;
  int anc;

  for (i = 0; i < n; i = i + 1) {
    parent[i] = -1;
    depth[i] = 0;
  }

  parent[0] = 0;
  depth[0] = 0;
  order[0] = 0;

  back = 1;
  for (front = 0; front < back; front = front + 1) {
    u = order[front];
    e = head[u];
    for (; e != -1; e = nxt[e]) {
      v = to[e];
      if (parent[v] == -1 && v != 0) {
        parent[v] = u;
        depth[v] = depth[u] + 1;
        order[back] = v;
        back = back + 1;
      }
    }
  }

  for (i = 0; i < n; i = i + 1) {
    up[i * MAXLOG] = parent[i];
  }
  for (k = 1; k < MAXLOG; k = k + 1) {
    for (i = 0; i < n; i = i + 1) {
      anc = up[i * MAXLOG + (k - 1)];
      up[i * MAXLOG + k] = up[anc * MAXLOG + (k - 1)];
    }
  }
}

int lca_query(int u, int v) {
  int tmp;
  int diff;
  int k;
  int uu;
  int vv;
  int au;
  int av;

  if (depth[u] < depth[v]) {
    tmp = u;
    u = v;
    v = tmp;
  }

  diff = depth[u] - depth[v];
  for (k = 0; k < MAXLOG; k = k + 1) {
    if (diff % 2 == 1) {
      u = up[u * MAXLOG + k];
    }
    diff = diff / 2;
    if (diff == 0) {
      break;
    }
  }

  if (u == v) {
    return u;
  }

  for (k = MAXLOG - 1; k >= 0; k = k - 1) {
    uu = up[u * MAXLOG + k];
    vv = up[v * MAXLOG + k];
    if (uu != vv) {
      u = uu;
      v = vv;
    }
  }

  return parent[u];
}

int main() {
  int T;
  int kase;
  int n;
  int q;
  int i;
  int x;
  int y;
  int c;
  int d;
  int pd;
  int u;

  T = getint();
  for (kase = 1; kase <= T; kase = kase + 1) {
    n = getint();
    init_graph(n);

    for (i = 0; i < n - 1; i = i + 1) {
      x = getint();
      y = getint();
      add_edge(x, y);
      add_edge(y, x);
    }

    build_lca(n);

    for (i = 0; i < n; i = i + 1) {
      mark[i] = 0;
    }

    q = getint();
    for (i = 0; i < q; i = i + 1) {
      x = getint();
      y = getint();
      c = getint();
      d = lca_query(x, y);
      pd = parent[d];
      mark[x] = mark[x] + c;
      mark[y] = mark[y] + c;
      mark[d] = mark[d] - c;
      if (pd != d) {
        mark[pd] = mark[pd] - c;
      }
    }

    for (i = n - 1; i >= 0; i = i - 1) {
      u = order[i];
      if (u != 0) {
        mark[parent[u]] = mark[parent[u]] + mark[u];
      }
    }

    printf("Case #%d:\n", kase);
    for (i = 0; i < n; i = i + 1) {
      printf("%d\n", mark[i]);
    }
  }
  return 0;
}
