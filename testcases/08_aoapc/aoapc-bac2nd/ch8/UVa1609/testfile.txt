/* Description:
 *   Converted from UVa1609 "Foul Play" scheduling algorithm.
 *   Input format (strict SysY):
 *     Repeated testcases:
 *       n
 *       n*n integers (0/1), row-major table[i][j] for 1<=i,j<=n
 *     Terminator:
 *       n = 0
 *   Output: match pairs, one per line.
 */

const int MAXN = 70;
int table[MAXN * MAXN];
int win[MAXN];
int lose[MAXN];
int win2[MAXN];
int lose2[MAXN];
int finalv[MAXN];

int main() {
  int n;
  int i;
  int j;
  int nt;

  for (;;) {
    n = getint();
    if (n == 0) break;

    for (i = 1; i <= n; i = i + 1) {
      for (j = 1; j <= n; j = j + 1) {
        table[i * MAXN + j] = getint();
      }
    }

    int winSize;
    int loseSize;
    winSize = 0;
    loseSize = 0;
    for (i = 2; i <= n; i = i + 1) {
      if (table[1 * MAXN + i] == 1) {
        win[winSize] = i;
        winSize = winSize + 1;
      } else {
        lose[loseSize] = i;
        loseSize = loseSize + 1;
      }
    }

    nt = n;
    for (; nt > 1; nt = nt / 2) {
      int win2Size;
      int lose2Size;
      int finalSize;
      win2Size = 0;
      lose2Size = 0;
      finalSize = 0;

      for (i = 0; i < loseSize; i = i + 1) {
        int tlose;
        int matched;
        tlose = lose[i];
        matched = 0;

        for (j = 0; j < winSize; j = j + 1) {
          int twin;
          twin = win[j];
          if (twin > 0 && table[twin * MAXN + tlose] == 1) {
            printf("%d %d\n", twin, tlose);
            win2[win2Size] = twin;
            win2Size = win2Size + 1;
            win[j] = 0;
            matched = 1;
            break;
          }
        }

        if (matched == 0) {
          finalv[finalSize] = tlose;
          finalSize = finalSize + 1;
        }
      }

      int first;
      first = 1;
      for (i = 0; i < winSize; i = i + 1) {
        int twin2;
        twin2 = win[i];
        if (twin2 > 0) {
          if (first == 1) {
            printf("1 %d\n", twin2);
            first = 0;
          } else {
            finalv[finalSize] = twin2;
            finalSize = finalSize + 1;
          }
        }
      }

      for (i = 0; i < finalSize; i = i + 2) {
        int a;
        int b;
        int keep;
        a = finalv[i];
        b = finalv[i + 1];
        printf("%d %d\n", a, b);
        keep = a;
        if (table[b * MAXN + keep] == 1) keep = b;
        if (table[1 * MAXN + keep] == 1) {
          win2[win2Size] = keep;
          win2Size = win2Size + 1;
        } else {
          lose2[lose2Size] = keep;
          lose2Size = lose2Size + 1;
        }
      }

      winSize = win2Size;
      loseSize = lose2Size;
      for (i = 0; i < winSize; i = i + 1) win[i] = win2[i];
      for (i = 0; i < loseSize; i = i + 1) lose[i] = lose2[i];
    }
  }

  return 0;
}
