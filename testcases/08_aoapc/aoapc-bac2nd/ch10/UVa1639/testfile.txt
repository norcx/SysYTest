/* Description:
 *   Strict SysY testcase (int-only) adapted from:
 *     UVa1639/LA6163 Candy (Rujia Liu)
 *
 *   Original code uses floating-point log/exp to avoid underflow for large n.
 *   This testcase scales n down (use n <= 10) and replaces floating-point with
 *   fixed-point arithmetic.
 *
 *   Input (repeated):
 *     n
 *     p
 *   where p is an integer in [0, 10000] representing probability p/10000.
 *   Terminate with n < 0 (sentinel included in in.txt).
 *
 *   Output:
 *     Case k: ans
 *   where ans is the computed expectation scaled by 10000.
 */

const int SCALE = 10000;

int pow_fixed(int base, int exp) {
  int res;
  int i;
  res = SCALE;
  for (i = 0; i < exp; i = i + 1) {
    res = res * base / SCALE;
  }
  return res;
}

int comb_small(int n, int k) {
  int kk;
  int res;
  int i;
  if (k < 0) return 0;
  if (k > n) return 0;
  kk = k;
  if (kk > n - kk) kk = n - kk;
  res = 1;
  for (i = 1; i <= kk; i = i + 1) {
    res = res * (n - kk + i) / i;
  }
  return res;
}

int solve(int n, int p) {
  int ans;
  int q;
  int i;
  ans = 0;
  q = SCALE - p;
  for (i = 0; i <= n; i = i + 1) {
    int c;
    int p1;
    int q1;
    int prob1;
    int term1;
    int p2;
    int q2;
    int prob2;
    int term2;
    int x;

    c = comb_small(2 * n - i, n);

    p1 = pow_fixed(p, n + 1);
    q1 = pow_fixed(q, n - i);
    prob1 = p1 * q1 / SCALE;
    term1 = c * prob1;

    q2 = pow_fixed(q, n + 1);
    p2 = pow_fixed(p, n - i);
    prob2 = q2 * p2 / SCALE;
    term2 = c * prob2;

    x = term1 + term2;
    ans = ans + i * x;
  }
  return ans;
}

int main() {
  int kase;
  int n;
  int p;
  int dummy;

  kase = 0;
  for (dummy = 0; dummy == 0; dummy = 0) {
    n = getint();
    if (n < 0) {
      break;
    } else {
      p = getint();
      if (p < 0) p = 0;
      if (p > SCALE) p = SCALE;
      kase = kase + 1;
      printf("Case %d: %d\n", kase, solve(n, p));
    }
  }
  return 0;
}
