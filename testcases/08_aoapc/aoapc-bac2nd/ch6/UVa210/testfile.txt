/* Description:
 *   SysY adaptation of "UVa 210 - Concurrency Simulator".
 *
 *   Input encoding (all integers, one per line):
 *     T
 *     repeat T times:
 *       n
 *       c0 c1 c2 c3 c4 (each on its own line)
 *       quantum
 *       repeat n times (per program pid = 0..n-1):
 *         m  (number of instructions, including a final END)
 *         then m instructions:
 *           op
 *           if op==0 (ASSIGN): var value
 *           if op==1 (PRINT):  var
 *           if op==2 (LOCK):   (no args)
 *           if op==3 (UNLOCK): (no args)
 *           if op==4 (END):    (no args)
 *
 *   Opcodes:
 *     0: ASSIGN, 1: PRINT, 2: LOCK, 3: UNLOCK, 4: END
 */

const int MAXP = 50;
const int MAXINST = 2000;
const int QCAP = 256;

int n;
int quantum;
int c0;
int c1;
int c2;
int c3;
int c4;

int var[26];
int ip[MAXP];
int locked;

int instType[MAXINST];
int instVar[MAXINST];
int instVal[MAXINST];

int readyArr[QCAP];
int readyHead;
int readyTail;
int readySize;

int blockArr[QCAP];
int blockHead;
int blockTail;
int blockSize;

void readyInit() {
    readyHead = 0;
    readyTail = 0;
    readySize = 0;
}

int readyEmpty() {
    if (readySize == 0) return 1;
    return 0;
}

void readyPushBack(int x) {
    readyArr[readyTail] = x;
    readyTail = readyTail + 1;
    if (readyTail == QCAP) readyTail = 0;
    readySize = readySize + 1;
}

void readyPushFront(int x) {
    readyHead = readyHead - 1;
    if (readyHead < 0) readyHead = readyHead + QCAP;
    readyArr[readyHead] = x;
    readySize = readySize + 1;
}

int readyPopFront() {
    int x;
    x = readyArr[readyHead];
    readyHead = readyHead + 1;
    if (readyHead == QCAP) readyHead = 0;
    readySize = readySize - 1;
    return x;
}

void blockInit() {
    blockHead = 0;
    blockTail = 0;
    blockSize = 0;
}

int blockEmpty() {
    if (blockSize == 0) return 1;
    return 0;
}

void blockPush(int x) {
    blockArr[blockTail] = x;
    blockTail = blockTail + 1;
    if (blockTail == QCAP) blockTail = 0;
    blockSize = blockSize + 1;
}

int blockPop() {
    int x;
    x = blockArr[blockHead];
    blockHead = blockHead + 1;
    if (blockHead == QCAP) blockHead = 0;
    blockSize = blockSize - 1;
    return x;
}

void run(int pid) {
    int q;
    int t;
    int v;
    int val;
    int pid2;

    q = quantum;
    for (; q > 0; ) {
        t = instType[ip[pid]];
        if (t == 0) {
            v = instVar[ip[pid]];
            val = instVal[ip[pid]];
            var[v] = val;
            q = q - c0;
            ip[pid] = ip[pid] + 1;
        } else if (t == 1) {
            v = instVar[ip[pid]];
            printf("%d: %d\n", pid + 1, var[v]);
            q = q - c1;
            ip[pid] = ip[pid] + 1;
        } else if (t == 2) {
            if (locked == 1) {
                blockPush(pid);
                return;
            }
            locked = 1;
            q = q - c2;
            ip[pid] = ip[pid] + 1;
        } else if (t == 3) {
            locked = 0;
            if (blockEmpty() == 0) {
                pid2 = blockPop();
                readyPushFront(pid2);
            }
            q = q - c3;
            ip[pid] = ip[pid] + 1;
        } else {
            return;
        }
    }
    readyPushBack(pid);
}

int main() {
    int T;
    int tc;
    int i;
    int j;
    int m;
    int op;
    int line;
    int pid;

    T = getint();
    tc = 0;
    for (; tc < T; tc = tc + 1) {
        n = getint();
        c0 = getint();
        c1 = getint();
        c2 = getint();
        c3 = getint();
        c4 = getint();
        quantum = getint();

        i = 0;
        for (; i < 26; i = i + 1) var[i] = 0;

        readyInit();
        blockInit();
        locked = 0;

        line = 0;
        i = 0;
        for (; i < n; i = i + 1) {
            m = getint();
            ip[i] = line;
            j = 0;
            for (; j < m; j = j + 1) {
                op = getint();
                instType[line] = op;
                if (op == 0) {
                    instVar[line] = getint();
                    instVal[line] = getint();
                } else if (op == 1) {
                    instVar[line] = getint();
                    instVal[line] = 0;
                } else {
                    instVar[line] = 0;
                    instVal[line] = 0;
                }
                line = line + 1;
            }
            readyPushBack(i);
        }

        for (; readyEmpty() == 0; ) {
            pid = readyPopFront();
            run(pid);
        }

        if (tc != T - 1) printf("\n");
    }
    return 0;
}
