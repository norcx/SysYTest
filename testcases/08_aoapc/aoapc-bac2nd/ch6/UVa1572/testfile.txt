// UVa1572 Self-Assembly (Strict SysY, int-only input)
// Input format (integers, one per line):
// Repeated testcases:
//   n
//   then n pieces, each with 4 integers b0..b3 (border IDs or -1 for none)
//   border ID encoding: (letter_index*2 + sign), sign: '+' -> 0, '-' -> 1
// Terminated by n = 0.
//
// Output:
//   "unbounded" if there is a reachable cycle in the implication graph
//   else "bounded"

const int N = 52;

int G[N * N];
int color[N];

int complement(int id) {
  if (id < 0) return -1;
  if (id % 2 == 0) return id + 1;
  return id - 1;
}

void clear_graph() {
  int i;
  for (i = 0; i < N * N; i = i + 1) {
    G[i] = 0;
  }
}

void connect_border(int a, int b) {
  int u;
  int v;
  if (a < 0 || b < 0) return;
  u = complement(a);
  v = b;
  G[u * N + v] = 1;
}

int dfs(int u) {
  int v;
  color[u] = -1;
  for (v = 0; v < N; v = v + 1) {
    if (G[u * N + v] != 0) {
      if (color[v] < 0) return 1;
      if (color[v] == 0) {
        if (dfs(v) != 0) return 1;
      }
    }
  }
  color[u] = 1;
  return 0;
}

int find_cycle() {
  int i;
  for (i = 0; i < N; i = i + 1) {
    color[i] = 0;
  }
  for (i = 0; i < N; i = i + 1) {
    if (color[i] == 0) {
      if (dfs(i) != 0) return 1;
    }
  }
  return 0;
}

int main() {
  int n;
  int piece;
  int i;
  int j;
  int b[4];
  for (;;) {
    n = getint();
    if (n == 0) break;
    clear_graph();

    for (piece = 0; piece < n; piece = piece + 1) {
      for (i = 0; i < 4; i = i + 1) {
        b[i] = getint();
      }
      for (i = 0; i < 4; i = i + 1) {
        for (j = 0; j < 4; j = j + 1) {
          if (i != j) {
            connect_border(b[i], b[j]);
          }
        }
      }
    }

    if (find_cycle() != 0) printf("unbounded\n");
    else printf("bounded\n");
  }
  return 0;
}
