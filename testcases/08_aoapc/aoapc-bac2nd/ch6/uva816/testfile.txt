/* Description:
 *   Strict SysY conversion of UVa816 "Abbott's Revenge".
 *
 *   Input encoding (integers, one per line):
 *     T
 *     For each case:
 *       case_id
 *       r0
 *       c0
 *       dir0          (0=N, 1=E, 2=S, 3=W)
 *       r2
 *       c2
 *       K             (# of edge specs)
 *       Repeat K times:
 *         r
 *         c
 *         dir          (0=N, 1=E, 2=S, 3=W)
 *         allowF       (0/1)
 *         allowL       (0/1)
 *         allowR       (0/1)
 *
 *   Notes:
 *     - The first move from (r0,c0) to (r1,c1) is forced by dir0.
 *     - Edges are defined for states (r,c,dir) and turns (F/L/R).
 */

const int GRID = 10;
const int DIRS = 4;
const int TURNS = 3;
const int STATE_N = 10 * 10 * 4;
const int EDGE_N = 10 * 10 * 4 * 3;

int has_edge[EDGE_N];
int dist_arr[STATE_N];
int prev_arr[STATE_N];

int dr[4] = {-1, 0, 1, 0};
int dc[4] = {0, 1, 0, -1};

int path_r[500];
int path_c[500];

int idx_state(int r, int c, int dir) {
  return (r * 10 + c) * 4 + dir;
}

int idx_edge(int r, int c, int dir, int turn) {
  return ((r * 10 + c) * 4 + dir) * 3 + turn;
}

int pack_node(int r, int c, int dir) {
  return r * 100 + c * 10 + dir;
}

int node_r(int id) {
  return id / 100;
}

int node_c(int id) {
  int t;
  t = id / 10;
  return t % 10;
}

int node_dir(int id) {
  return id % 10;
}

int inside(int r, int c) {
  if (r < 1) return 0;
  if (r > 9) return 0;
  if (c < 1) return 0;
  if (c > 9) return 0;
  return 1;
}

void print_ans(int goal_id, int r0, int c0, int dir0) {
  int len;
  int u;
  int ur;
  int uc;
  int udir;
  int uidx;
  int i;
  int cnt;

  len = 0;
  u = goal_id;
  for (;;) {
    ur = node_r(u);
    uc = node_c(u);
    udir = node_dir(u);
    path_r[len] = ur;
    path_c[len] = uc;
    len = len + 1;

    uidx = idx_state(ur, uc, udir);
    if (dist_arr[uidx] == 0) break;
    u = prev_arr[uidx];
  }

  path_r[len] = r0;
  path_c[len] = c0;
  len = len + 1;

  cnt = 0;
  for (i = len - 1; i >= 0; i = i - 1) {
    if (cnt % 10 == 0) printf(" ");
    printf(" (%d,%d)", path_r[i], path_c[i]);
    cnt = cnt + 1;
    if (cnt % 10 == 0) printf("\n");
  }
  if (len % 10 != 0) printf("\n");
}

void solve_case(int case_id, int r0, int c0, int dir0, int r2, int c2) {
  int i;
  int q[500];
  int head;
  int tail;
  int r1;
  int c1;

  int u_id;
  int u_r;
  int u_c;
  int u_dir;
  int uidx;

  int turn;
  int v_r;
  int v_c;
  int v_dir;
  int vidx;
  int eidx;

  printf("Case %d\n", case_id);

  for (i = 0; i < STATE_N; i = i + 1) dist_arr[i] = -1;

  r1 = r0 + dr[dir0];
  c1 = c0 + dc[dir0];
  if (inside(r1, c1) == 0) {
    printf("  No Solution Possible\n");
    return;
  }

  head = 0;
  tail = 0;
  u_id = pack_node(r1, c1, dir0);
  u_r = r1;
  u_c = c1;
  u_dir = dir0;
  uidx = idx_state(u_r, u_c, u_dir);
  dist_arr[uidx] = 0;
  q[tail] = u_id;
  tail = tail + 1;

  for (; head < tail; head = head + 1) {
    u_id = q[head];
    u_r = node_r(u_id);
    u_c = node_c(u_id);
    u_dir = node_dir(u_id);

    if (u_r == r2 && u_c == c2) {
      print_ans(u_id, r0, c0, dir0);
      return;
    }

    uidx = idx_state(u_r, u_c, u_dir);
    for (turn = 0; turn < 3; turn = turn + 1) {
      eidx = idx_edge(u_r, u_c, u_dir, turn);
      if (has_edge[eidx] == 0) {
      } else {
        v_dir = u_dir;
        if (turn == 1) v_dir = u_dir + 3;
        if (turn == 2) v_dir = u_dir + 1;
        v_dir = v_dir % 4;
        v_r = u_r + dr[v_dir];
        v_c = u_c + dc[v_dir];
        if (inside(v_r, v_c) == 0) {
        } else {
          vidx = idx_state(v_r, v_c, v_dir);
          if (dist_arr[vidx] < 0) {
            dist_arr[vidx] = dist_arr[uidx] + 1;
            prev_arr[vidx] = u_id;
            q[tail] = pack_node(v_r, v_c, v_dir);
            tail = tail + 1;
          }
        }
      }
    }
  }

  printf("  No Solution Possible\n");
  return;
}

int main() {
  int T;
  int ci;

  int case_id;
  int r0;
  int c0;
  int dir0;
  int r2;
  int c2;

  int K;
  int i;
  int r;
  int c;
  int dir;
  int f;
  int l;
  int rr;

  T = getint();
  for (ci = 0; ci < T; ci = ci + 1) {
    case_id = getint();
    r0 = getint();
    c0 = getint();
    dir0 = getint();
    r2 = getint();
    c2 = getint();

    for (i = 0; i < EDGE_N; i = i + 1) has_edge[i] = 0;
    K = getint();
    for (i = 0; i < K; i = i + 1) {
      r = getint();
      c = getint();
      dir = getint();
      f = getint();
      l = getint();
      rr = getint();
      has_edge[idx_edge(r, c, dir, 0)] = f;
      has_edge[idx_edge(r, c, dir, 1)] = l;
      has_edge[idx_edge(r, c, dir, 2)] = rr;
    }

    solve_case(case_id, r0, c0, dir0, r2, c2);
  }

  return 0;
}
