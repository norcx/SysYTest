// UVa12105 Bigger is Better (Strict SysY adaptation)
// Input (newline-separated integers): repeated pairs n, m, terminated by n = -1
// Output: "Case k: " followed by the maximal-length (then lexicographically largest)
// number constructible with at most n matches whose value % m == 0, or -1 if none.

const int MAXN = 100 + 5;
const int MAXM = 3000 + 5;

// Encode state (i, j) into one int to save memory:
// -1: unreachable
//  0: reachable with length 0 (stop; no next digit)
// >0: value = len*10 + digit + 1  (len>=1, digit in [0..9])
int best[MAXN * MAXM];

int needs[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};

int main() {
  int n;
  int m;
  int kase;
  int i;
  int j;
  int d;
  int j2;
  int idx;
  int ansLen;
  int bestDigit;
  int child;
  int tLen;
  int val;
  int curI;
  int curJ;
  int step;
  int digit;

  for (kase = 0; kase < 1000000; kase = kase + 1) {
    n = getint();
    if (n == -1) break;
    m = getint();

    printf("Case %d: ", kase + 1);

    for (i = 0; i <= n; i = i + 1) {
      for (j = 0; j < m; j = j + 1) {
        ansLen = -1;
        bestDigit = -1;
        if (j == 0) ansLen = 0;

        for (d = 9; d >= 0; d = d - 1) {
          if (i >= needs[d]) {
            j2 = (j * 10 + d) % m;
            child = best[(i - needs[d]) * MAXM + j2];
            if (child >= 0) {
              tLen = 0;
              if (child > 0) tLen = (child - 1) / 10;
              if (tLen + 1 > ansLen) {
                ansLen = tLen + 1;
                bestDigit = d;
              }
            }
          }
        }

        idx = i * MAXM + j;
        if (ansLen < 0) {
          best[idx] = -1;
        } else {
          if (bestDigit < 0) best[idx] = 0;
          else best[idx] = ansLen * 10 + bestDigit + 1;
        }
      }
    }

    val = best[n * MAXM];
    if (val <= 0) {
      printf("-1\n");
    } else {
      curI = n;
      curJ = 0;
      for (step = 0; step < 1000000; step = step + 1) {
        val = best[curI * MAXM + curJ];
        if (val <= 0) break;
        digit = (val - 1) % 10;
        printf("%d", digit);
        curI = curI - needs[digit];
        curJ = (curJ * 10 + digit) % m;
      }
      printf("\n");
    }
  }

  return 0;
}
