/* UVa1204 Fun Game (converted to Strict SysY)
 * Input format (integers, one per line):
 *   n
 *   For each of n strings: L then L symbols (as integers)
 * Repeats until n == 0.
 */
const int MAXN = 12;
const int MAXLEN = 32;
const int MAXMASK = 4096;

int n;

int tmp_len[MAXN];
int tmp_s[MAXN * MAXLEN];
int tmp_rev[MAXN * MAXLEN];

int len2[MAXN];
int s2[MAXN * 2 * MAXLEN];

int overlap2[MAXN * MAXN * 2 * 2];

int dp[MAXMASK * MAXN * 2];

int pow2[MAXN + 1];

void init_pow2() {
  int i;
  pow2[0] = 1;
  for (i = 1; i <= MAXN; i = i + 1) pow2[i] = pow2[i - 1] * 2;
}

int get_s2(int i, int x, int k) {
  return s2[(i * 2 + x) * MAXLEN + k];
}

void set_s2(int i, int x, int k, int v) {
  s2[(i * 2 + x) * MAXLEN + k] = v;
}

int get_overlap(int i, int j, int x, int y) {
  return overlap2[(((i * MAXN + j) * 2 + x) * 2 + y)];
}

void set_overlap(int i, int j, int x, int y, int v) {
  overlap2[(((i * MAXN + j) * 2 + x) * 2 + y)] = v;
}

int get_dp(int mask, int i, int x) {
  return dp[((mask * MAXN + i) * 2 + x)];
}

void set_dp(int mask, int i, int x, int v) {
  dp[((mask * MAXN + i) * 2 + x)] = v;
}

int is_substring(int small_off, int small_len, int big_off, int big_len, int big_arr[]) {
  int pos;
  int k;
  if (small_len > big_len) return 0;
  for (pos = 0; pos + small_len <= big_len; pos = pos + 1) {
    int ok;
    ok = 1;
    for (k = 0; k < small_len; k = k + 1) {
      if (tmp_s[small_off + k] != big_arr[big_off + pos + k]) {
        ok = 0;
        k = small_len;
      }
    }
    if (ok == 1) return 1;
  }
  return 0;
}

int calc_overlap(int a_off, int a_len, int b_off, int b_len, int a_arr[], int b_arr[]) {
  int i;
  int j;
  for (i = 1; i < a_len; i = i + 1) {
    if (b_len + i <= a_len) {
      continue;
    }
    {
      int ok;
      ok = 1;
      for (j = 0; i + j < a_len; j = j + 1) {
        if (a_arr[a_off + i + j] != b_arr[b_off + j]) {
          ok = 0;
          j = a_len;
        }
      }
      if (ok == 1) return a_len - i;
    }
  }
  return 0;
}

void swap_items(int i, int j) {
  int k;
  int t;
  t = tmp_len[i];
  tmp_len[i] = tmp_len[j];
  tmp_len[j] = t;
  for (k = 0; k < MAXLEN; k = k + 1) {
    t = tmp_s[i * MAXLEN + k];
    tmp_s[i * MAXLEN + k] = tmp_s[j * MAXLEN + k];
    tmp_s[j * MAXLEN + k] = t;

    t = tmp_rev[i * MAXLEN + k];
    tmp_rev[i * MAXLEN + k] = tmp_rev[j * MAXLEN + k];
    tmp_rev[j * MAXLEN + k] = t;
  }
}

void sort_by_length() {
  int i;
  int j;
  for (i = 0; i < n; i = i + 1) {
    int best;
    best = i;
    for (j = i + 1; j < n; j = j + 1) {
      if (tmp_len[j] < tmp_len[best]) best = j;
    }
    if (best != i) swap_items(i, best);
  }
}

void init_case() {
  int i;
  int j;
  int k;

  for (i = 0; i < n; i = i + 1) {
    int L;
    L = getint();
    tmp_len[i] = L;
    for (k = 0; k < L; k = k + 1) {
      tmp_s[i * MAXLEN + k] = getint();
    }
    for (k = 0; k < L; k = k + 1) {
      tmp_rev[i * MAXLEN + k] = tmp_s[i * MAXLEN + (L - 1 - k)];
    }
  }

  sort_by_length();

  {
    int n_keep;
    n_keep = 0;
    for (i = 0; i < n; i = i + 1) {
      int need;
      need = 1;
      for (j = i + 1; j < n; j = j + 1) {
        if (is_substring(i * MAXLEN, tmp_len[i], j * MAXLEN, tmp_len[j], tmp_s) == 1) {
          need = 0;
          j = n;
        } else if (is_substring(i * MAXLEN, tmp_len[i], j * MAXLEN, tmp_len[j], tmp_rev) == 1) {
          need = 0;
          j = n;
        }
      }
      if (need == 1) {
        len2[n_keep] = tmp_len[i];
        for (k = 0; k < tmp_len[i]; k = k + 1) {
          set_s2(n_keep, 0, k, tmp_s[i * MAXLEN + k]);
          set_s2(n_keep, 1, k, tmp_rev[i * MAXLEN + k]);
        }
        n_keep = n_keep + 1;
      }
    }
    n = n_keep;
  }

  for (i = 0; i < n; i = i + 1) {
    for (j = 0; j < n; j = j + 1) {
      int x;
      int y;
      for (x = 0; x < 2; x = x + 1) {
        for (y = 0; y < 2; y = y + 1) {
          int ov;
          ov = calc_overlap((i * 2 + x) * MAXLEN, len2[i], (j * 2 + y) * MAXLEN, len2[j], s2, s2);
          set_overlap(i, j, x, y, ov);
        }
      }
    }
  }
}

void update_min(int mask, int i, int x, int v) {
  int cur;
  cur = get_dp(mask, i, x);
  if (cur < 0) {
    set_dp(mask, i, x, v);
    return;
  }
  if (v < cur) set_dp(mask, i, x, v);
}

void solve_case() {
  int full;
  int mask;
  int i;
  int x;
  int j;
  int y;

  for (mask = 0; mask < MAXMASK; mask = mask + 1) {
    for (i = 0; i < MAXN; i = i + 1) {
      for (x = 0; x < 2; x = x + 1) {
        set_dp(mask, i, x, -1);
      }
    }
  }

  if (n <= 0) return;

  set_dp(1, 0, 0, len2[0]);
  full = pow2[n] - 1;

  for (mask = 1; mask < full; mask = mask + 1) {
    for (i = 0; i < n; i = i + 1) {
      for (x = 0; x < 2; x = x + 1) {
        int cur;
        cur = get_dp(mask, i, x);
        if (cur >= 0) {
          for (j = 1; j < n; j = j + 1) {
            if ((mask / pow2[j]) % 2 == 0) {
              for (y = 0; y < 2; y = y + 1) {
                int next_mask;
                int val;
                next_mask = mask + pow2[j];
                val = cur + len2[j] - get_overlap(i, j, x, y);
                update_min(next_mask, j, y, val);
              }
            }
          }
        }
      }
    }
  }

  {
    int ans;
    ans = -1;
    for (i = 0; i < n; i = i + 1) {
      for (x = 0; x < 2; x = x + 1) {
        int cur;
        cur = get_dp(full, i, x);
        if (cur >= 0) {
          int v;
          v = cur - get_overlap(i, 0, x, 0);
          if (ans < 0) ans = v;
          else if (v < ans) ans = v;
        }
      }
    }
    if (ans <= 1) ans = 2;
    printf("%d\n", ans);
  }
}

int main() {
  init_pow2();
  for (;;) {
    n = getint();
    if (n == 0) break;
    init_case();
    solve_case();
  }
  return 0;
}
