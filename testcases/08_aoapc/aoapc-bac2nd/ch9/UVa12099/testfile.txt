/* Description:
 *   UVa12099 - The Bookcase (scaled-down for Strict SysY).
 *   Input:
 *     T
 *     For each case:
 *       n
 *       n lines of: h w
 *   Output: minimal area (w*h) for 3 levels.
 */

const int MAXN = 20;
const int MAXS = 200;
const int STRIDE = 201;
const int DP_SIZE = 40401;
const int INF = 1000000000;

int bh[MAXN];
int bw[MAXN];
int prefix[MAXN + 1];
int dp0[DP_SIZE];
int dp1[DP_SIZE];

int idx(int j, int k) {
  return j * STRIDE + k;
}

int f(int width_before, int h) {
  int inc;
  inc = 0;
  if (width_before == 0) inc = h;
  return inc;
}

int upd(int cur, int cand) {
  if (cur < 0) return cand;
  if (cand < cur) return cand;
  return cur;
}

int max2(int a, int b) {
  if (a > b) return a;
  return b;
}

int max3(int a, int b, int c) {
  return max2(max2(a, b), c);
}

void sort_books(int n) {
  int i;
  int j;
  int th;
  int tw;
  for (i = 0; i < n; i = i + 1) {
    for (j = i + 1; j < n; j = j + 1) {
      if (bh[j] > bh[i] || bh[j] == bh[i] && bw[j] > bw[i]) {
        th = bh[i];
        bh[i] = bh[j];
        bh[j] = th;
        tw = bw[i];
        bw[i] = bw[j];
        bw[j] = tw;
      }
    }
  }
}

int main() {
  int T;
  int tc;
  T = getint();

  for (tc = 0; tc < T; tc = tc + 1) {
    int n;
    int i;
    int j;
    int k;
    int total;
    int ans;

    n = getint();
    for (i = 0; i < n; i = i + 1) {
      bh[i] = getint();
      bw[i] = getint();
    }

    sort_books(n);

    prefix[0] = 0;
    for (i = 0; i < n; i = i + 1) prefix[i + 1] = prefix[i] + bw[i];
    total = prefix[n];

    for (i = 0; i < DP_SIZE; i = i + 1) dp0[i] = -1;
    dp0[0] = 0;

    for (i = 1; i < n; i = i + 1) {
      int curw;
      int cur;
      int nj;
      int nk;

      for (j = 0; j < DP_SIZE; j = j + 1) dp1[j] = -1;

      curw = prefix[i];
      for (j = 0; j <= curw; j = j + 1) {
        for (k = 0; k <= curw - j; k = k + 1) {
          cur = dp0[idx(j, k)];
          if (cur >= 0) {
            dp1[idx(j, k)] = upd(dp1[idx(j, k)], cur);

            nj = j + bw[i];
            dp1[idx(nj, k)] = upd(dp1[idx(nj, k)], cur + f(j, bh[i]));

            nk = k + bw[i];
            dp1[idx(j, nk)] = upd(dp1[idx(j, nk)], cur + f(k, bh[i]));
          }
        }
      }

      for (j = 0; j < DP_SIZE; j = j + 1) dp0[j] = dp1[j];
    }

    ans = INF;
    for (j = 1; j <= total - 2; j = j + 1) {
      for (k = 1; k <= total - j - 1; k = k + 1) {
        int v;
        int w1;
        int w;
        int h;
        int area;

        v = dp0[idx(j, k)];
        if (v >= 0) {
          w1 = total - j - k;
          w = max3(j, k, w1);
          h = bh[0] + v;
          area = w * h;
          if (area < ans) ans = area;
        }
      }
    }

    printf("%d\n", ans);
  }

  return 0;
}
