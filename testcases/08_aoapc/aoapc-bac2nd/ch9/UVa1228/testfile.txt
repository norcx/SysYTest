/* Description:
 *   Strict SysY version of UVa 1228 (Integer Transmission), scaled to int.
 *   Input format (newline-separated integers):
 *     n
 *     d
 *     k
 *     ... repeats ...
 *     0            (sentinel to end)
 */

const int MAXN = 32;
const int STRIDE = 33;

int n;
int d;
int K[MAXN];

int zcnt;
int ocnt;
int Z[MAXN];
int O[MAXN];

int f[1089];
int minv;
int maxv;

int can_receive_zero(int i, int j) {
    if (i + 1 > zcnt) return 0;
    if (j == ocnt) return 1;
    if (O[j] + d >= Z[i]) return 1;
    return 0;
}

int can_receive_one(int i, int j) {
    if (j + 1 > ocnt) return 0;
    if (i == zcnt) return 1;
    if (Z[i] + d >= O[j]) return 1;
    return 0;
}

void greedy() {
    int i;
    int j;

    minv = 0;
    maxv = 0;

    i = 0;
    j = 0;
    for (; i < zcnt || j < ocnt;) {
        if (can_receive_zero(i, j) == 1) {
            i = i + 1;
            minv = minv * 2;
        } else {
            j = j + 1;
            minv = minv * 2 + 1;
        }
    }

    i = 0;
    j = 0;
    for (; i < zcnt || j < ocnt;) {
        if (can_receive_one(i, j) == 1) {
            j = j + 1;
            maxv = maxv * 2 + 1;
        } else {
            i = i + 1;
            maxv = maxv * 2;
        }
    }
}

void solve() {
    int i;
    int j;

    ocnt = 0;
    zcnt = 0;
    for (i = 0; i < n; i = i + 1) {
        if (K[i] == 1) {
            O[ocnt] = i;
            ocnt = ocnt + 1;
        } else {
            Z[zcnt] = i;
            zcnt = zcnt + 1;
        }
    }

    greedy();

    for (i = 0; i < 1089; i = i + 1) f[i] = 0;
    f[0] = 1;

    for (i = 0; i <= zcnt; i = i + 1) {
        for (j = 0; j <= ocnt; j = j + 1) {
            int cur;
            cur = f[i * STRIDE + j];
            if (cur != 0) {
                if (can_receive_zero(i, j) == 1)
                    f[(i + 1) * STRIDE + j] = f[(i + 1) * STRIDE + j] + cur;
                if (can_receive_one(i, j) == 1)
                    f[i * STRIDE + (j + 1)] = f[i * STRIDE + (j + 1)] + cur;
            }
        }
    }

    printf("%d %d %d\n", f[zcnt * STRIDE + ocnt], minv, maxv);
}

int main() {
    int kase;
    int running;

    kase = 0;
    running = 1;
    for (; running == 1;) {
        int k;
        int i;

        n = getint();
        if (n == 0) {
            running = 0;
        } else {
            d = getint();
            k = getint();

            for (i = 0; i < n; i = i + 1) {
                K[n - i - 1] = k % 2;
                k = k / 2;
            }

            kase = kase + 1;
            printf("Case %d: ", kase);
            solve();
        }
    }
    return 0;
}
