/* UVa1412 Fund Management (integer SysY adaptation)
 * - Uses integer "cents" for money and prices
 * - Outputs action codes per day: 0=HOLD, +i=BUY stock i, -i=SELL stock i (1-based i)
 */
const int MAXN = 5;
const int MAXM = 20;
const int MAXK = 5;
const int MAXSTATE = 1000;
const int MAXKEY = 8000;
const int INF_NEG = -1000000000;

int c;
int m;
int n;
int kk;

int k[MAXN];
int mul[MAXN];

int state_cnt;
int state_lots[MAXSTATE * MAXN];
int key_of_state[MAXSTATE];
int totlot_of_state[MAXSTATE];
int id[MAXKEY];

int buy_next[MAXSTATE * MAXN];
int sell_next[MAXSTATE * MAXN];

int price[MAXN * MAXM];

int d[(MAXM + 1) * MAXSTATE];
int opt[(MAXM + 1) * MAXSTATE];
int prev_state[(MAXM + 1) * MAXSTATE];

void dfs(int stock, int lots[], int totlot, int key) {
  int i;
  int idx;
  if(stock == n) {
    idx = state_cnt;
    state_cnt = state_cnt + 1;
    key_of_state[idx] = key;
    totlot_of_state[idx] = totlot;
    for(i = 0; i < n; i = i + 1) state_lots[idx * MAXN + i] = lots[i];
    id[key] = idx;
    return;
  }
  for(i = 0; i <= k[stock]; i = i + 1) {
    if(totlot + i <= kk) {
      lots[stock] = i;
      dfs(stock + 1, lots, totlot + i, key + i * mul[stock]);
    }
  }
  lots[stock] = 0;
  return;
}

void init_states() {
  int i;
  int s;
  int tot;
  int key2;
  int lots[MAXN];
  int maxkey;

  mul[0] = 1;
  for(i = 1; i < n; i = i + 1) mul[i] = mul[i - 1] * (k[i - 1] + 1);
  maxkey = mul[n - 1] * (k[n - 1] + 1);

  for(i = 0; i < MAXKEY; i = i + 1) id[i] = -1;
  for(i = 0; i < n; i = i + 1) lots[i] = 0;

  state_cnt = 0;
  dfs(0, lots, 0, 0);

  for(s = 0; s < state_cnt; s = s + 1) {
    tot = totlot_of_state[s];
    for(i = 0; i < n; i = i + 1) {
      buy_next[s * MAXN + i] = -1;
      sell_next[s * MAXN + i] = -1;

      if(state_lots[s * MAXN + i] < k[i] && tot < kk) {
        key2 = key_of_state[s] + mul[i];
        if(key2 >= 0 && key2 < maxkey) buy_next[s * MAXN + i] = id[key2];
      }
      if(state_lots[s * MAXN + i] > 0) {
        key2 = key_of_state[s] - mul[i];
        if(key2 >= 0 && key2 < maxkey) sell_next[s * MAXN + i] = id[key2];
      }
    }
  }
  return;
}

void update(int day, int s, int s2, int v, int o) {
  int idx;
  idx = (day + 1) * MAXSTATE + s2;
  if(v > d[idx]) {
    d[idx] = v;
    opt[idx] = o;
    prev_state[idx] = s;
  }
  return;
}

int dp() {
  int day;
  int s;
  int i;
  int v;
  int s2;
  int idx;

  for(day = 0; day <= m; day = day + 1) {
    for(s = 0; s < state_cnt; s = s + 1) {
      d[day * MAXSTATE + s] = INF_NEG;
      opt[day * MAXSTATE + s] = 0;
      prev_state[day * MAXSTATE + s] = 0;
    }
  }

  d[0] = c;

  for(day = 0; day < m; day = day + 1) {
    for(s = 0; s < state_cnt; s = s + 1) {
      v = d[day * MAXSTATE + s];
      if(v >= INF_NEG / 2) {
        update(day, s, s, v, 0);
        for(i = 0; i < n; i = i + 1) {
          s2 = buy_next[s * MAXN + i];
          if(s2 >= 0) {
            if(v >= price[i * MAXM + day]) update(day, s, s2, v - price[i * MAXM + day], i + 1);
          }
          s2 = sell_next[s * MAXN + i];
          if(s2 >= 0) update(day, s, s2, v + price[i * MAXM + day], -i - 1);
        }
      }
    }
  }

  return d[m * MAXSTATE + 0];
}

void print_ans(int day, int s) {
  int idx;
  int o;
  if(day == 0) return;
  idx = day * MAXSTATE + s;
  print_ans(day - 1, prev_state[idx]);
  o = opt[idx];
  printf("%d\n", o);
  return;
}

int main() {
  int T;
  int tc;
  int i;
  int day;
  int ans;

  T = getint();
  for(tc = 0; tc < T; tc = tc + 1) {
    c = getint();
    m = getint();
    n = getint();
    kk = getint();

    for(i = 0; i < n; i = i + 1) {
      k[i] = getint();
    }

    for(i = 0; i < n; i = i + 1) {
      for(day = 0; day < m; day = day + 1) {
        price[i * MAXM + day] = getint();
      }
    }

    init_states();
    ans = dp();
    printf("%d\n", ans);
    print_ans(m, 0);
    if(tc != T - 1) printf("\n");
  }

  return 0;
}
