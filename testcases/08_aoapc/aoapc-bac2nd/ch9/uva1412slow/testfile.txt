/* Description:
 * Converted from a C++ DP-with-encoding example (UVa 1412 style) into Strict SysY.
 * Uses integer cash/prices, flattened arrays, and full-state DP (no maps).
 *
 * Input (all integers, 1 per line):
 *   Repeated testcases:
 *     c
 *     m
 *     n
 *     kk
 *     for i in [0..n-1]:
 *       s[i]
 *       k[i]
 *       prices[i][0..m-1]
 *   Terminator: c == 0
 *
 * Output:
 *   final_cash
 *   then m lines of actions: HOLD / BUY id / SELL id
 */

const int MAXN = 3;
const int MAXM = 8;
const int MAXSTATES = 729;
const int NEG_INF = -1000000000;

int m;
int n;
int kk;
int c;

int s[MAXN];
int k[MAXN];
int price[MAXN * MAXM];

int states;
int dp_cur[MAXSTATES];
int dp_next[MAXSTATES];
int prev_state[(MAXM + 1) * MAXSTATES];
int opt_action[(MAXM + 1) * MAXSTATES];

int pow9(int x) {
  int r;
  int i;
  r = 1;
  for(i = 0; i < x; i = i + 1) r = r * 9;
  return r;
}

int encode(int p[]) {
  int h;
  int i;
  h = 0;
  for(i = 0; i < n; i = i + 1) h = h * 9 + p[i];
  return h;
}

int decode(int h, int p[]) {
  int tot;
  int i;
  tot = 0;
  for(i = n - 1; i >= 0; i = i - 1) {
    p[i] = h % 9;
    tot = tot + p[i];
    h = h / 9;
  }
  return tot;
}

void update(int oldh, int day, int h, int v, int o) {
  int idx;
  if (dp_next[h] < v) {
    dp_next[h] = v;
    idx = day * MAXSTATES + h;
    prev_state[idx] = oldh;
    opt_action[idx] = o;
  }
}

int run_dp() {
  int day;
  int h;
  int i;
  int v;
  int totlot;
  int p[MAXN];
  int nh;

  for(h = 0; h < states; h = h + 1) dp_cur[h] = NEG_INF;
  dp_cur[0] = c;

  for(day = 0; day <= m; day = day + 1)
    for(h = 0; h < states; h = h + 1) {
      prev_state[day * MAXSTATES + h] = 0;
      opt_action[day * MAXSTATES + h] = 0;
    }

  for(day = 0; day < m; day = day + 1) {
    for(h = 0; h < states; h = h + 1) dp_next[h] = NEG_INF;

    for(h = 0; h < states; h = h + 1) {
      v = dp_cur[h];
      if (v == NEG_INF) {
      } else {
        totlot = decode(h, p);
        update(h, day + 1, h, v, 0);

        for(i = 0; i < n; i = i + 1) {
          if (p[i] < k[i] && totlot < kk && v >= price[i * MAXM + day]) {
            p[i] = p[i] + 1;
            nh = encode(p);
            update(h, day + 1, nh, v - price[i * MAXM + day], i + 1);
            p[i] = p[i] - 1;
          }
          if (p[i] > 0) {
            p[i] = p[i] - 1;
            nh = encode(p);
            update(h, day + 1, nh, v + price[i * MAXM + day], -i - 1);
            p[i] = p[i] + 1;
          }
        }
      }
    }

    for(h = 0; h < states; h = h + 1) dp_cur[h] = dp_next[h];
  }

  return dp_cur[0];
}

void print_plan() {
  int ops[MAXM + 1];
  int day;
  int h;
  int o;

  h = 0;
  for(day = m; day >= 1; day = day - 1) {
    ops[day] = opt_action[day * MAXSTATES + h];
    h = prev_state[day * MAXSTATES + h];
  }

  for(day = 1; day <= m; day = day + 1) {
    o = ops[day];
    if (o == 0) printf("HOLD\n");
    else if (o > 0) printf("BUY %d\n", o);
    else printf("SELL %d\n", -o);
  }
}

int main() {
  int kase;
  int case_id;
  int i;
  int day;
  int basep;
  int ans;

  kase = 0;
  for(case_id = 0; case_id < 16; case_id = case_id + 1) {
    c = getint();
    if (c == 0) break;
    m = getint();
    n = getint();
    kk = getint();

    states = pow9(n);

    for(i = 0; i < n; i = i + 1) {
      s[i] = getint();
      k[i] = getint();
      for(day = 0; day < m; day = day + 1) {
        basep = getint();
        price[i * MAXM + day] = basep * s[i];
      }
    }

    if (kase > 0) printf("\n");
    kase = kase + 1;

    ans = run_dp();
    printf("%d\n", ans);
    print_plan();
  }

  return 0;
}
