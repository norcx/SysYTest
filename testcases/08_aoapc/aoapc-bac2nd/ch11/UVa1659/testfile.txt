/* Description:
 *   Strict SysY conversion of UVa1659 "Help Little Laura" core logic.
 *   - Only int/void, for-loops only, 1D arrays only, no structs/vectors.
 *   - Integer-only math: choose testcase coordinates so all distances are integers.
 *   - Output prints 2 decimals via manual formatting (no %f / %.2lf).
 */

const int MAXN = 110;
const int MAXV = 130;
const int MAXE = 2000;
const int INF = 1000000000;

int x[MAXN];
int y[MAXN];

int adj_head[MAXN];
int adj_to[MAXE];
int adj_next[MAXE];
int adj_cnt;

int c1[MAXN];
int c2[MAXN];

int head[MAXV];
int to[MAXE];
int nxt[MAXE];
int cap[MAXE];
int cost[MAXE];
int edge_cnt;
int V;

int dista[MAXV];
int preV[MAXV];
int preE[MAXV];
int avail[MAXV];

int min_int(int a, int b) {
  if (a < b) return a;
  return b;
}

int abs_int(int a) {
  if (a < 0) return -a;
  return a;
}

int isqrt_int(int s) {
  int i;
  for (i = 0; i <= 5000; i = i + 1) {
    if (i * i > s) return i - 1;
  }
  return 5000;
}

int rev_edge(int e) {
  if (e % 2 == 0) return e + 1;
  return e - 1;
}

void adj_init(int n) {
  int i;
  adj_cnt = 0;
  for (i = 0; i < n; i = i + 1) adj_head[i] = -1;
}

void adj_add(int u, int v) {
  adj_to[adj_cnt] = v;
  adj_next[adj_cnt] = adj_head[u];
  adj_head[u] = adj_cnt;
  adj_cnt = adj_cnt + 1;
}

void graph_init(int n) {
  int i;
  V = n;
  edge_cnt = 0;
  for (i = 0; i < V; i = i + 1) head[i] = -1;
}

void graph_add_edge(int u, int v, int c, int w) {
  to[edge_cnt] = v;
  cap[edge_cnt] = c;
  cost[edge_cnt] = w;
  nxt[edge_cnt] = head[u];
  head[u] = edge_cnt;
  edge_cnt = edge_cnt + 1;

  to[edge_cnt] = u;
  cap[edge_cnt] = 0;
  cost[edge_cnt] = -w;
  nxt[edge_cnt] = head[v];
  head[v] = edge_cnt;
  edge_cnt = edge_cnt + 1;
}

int bellman_ford(int s, int t) {
  int i;
  int k;
  int u;
  int e;
  int updated;

  for (i = 0; i < V; i = i + 1) {
    dista[i] = INF;
    preV[i] = -1;
    preE[i] = -1;
    avail[i] = 0;
  }
  dista[s] = 0;
  avail[s] = INF;

  for (k = 0; k < V - 1; k = k + 1) {
    updated = 0;
    for (u = 0; u < V; u = u + 1) {
      if (dista[u] == INF) {
      } else {
        for (e = head[u]; e != -1; e = nxt[e]) {
          if (cap[e] > 0) {
            if (dista[to[e]] > dista[u] + cost[e]) {
              dista[to[e]] = dista[u] + cost[e];
              preV[to[e]] = u;
              preE[to[e]] = e;
              avail[to[e]] = min_int(avail[u], cap[e]);
              updated = 1;
            }
          }
        }
      }
    }
    if (updated == 0) break;
  }

  if (preE[t] == -1) return 0;
  return 1;
}

int mincost_maxflow_cost(int s, int t) {
  int total_cost;
  int iter;
  int aug;
  int v;
  int e;
  int re;

  total_cost = 0;
  for (iter = 0; iter < 1000; iter = iter + 1) {
    if (bellman_ford(s, t) == 0) break;
    aug = avail[t];
    total_cost = total_cost + dista[t] * aug;
    for (v = t; v != s; v = preV[v]) {
      e = preE[v];
      re = rev_edge(e);
      cap[e] = cap[e] - aug;
      cap[re] = cap[re] + aug;
    }
  }
  return total_cost;
}

int main() {
  int T;
  int kase;
  int n;
  int a;
  int b;
  int u;
  int v;
  int t;
  int i;
  int eidx;
  int s;
  int dx;
  int dy;
  int sq;
  int d;
  int edge_cost;
  int sum;
  int flow_cost;
  int ans;
  int frac;

  T = getint();
  for (kase = 1; kase <= T; kase = kase + 1) {
    n = getint();
    a = getint();
    b = getint();

    adj_init(n);
    for (u = 0; u < n; u = u + 1) {
      x[u] = getint();
      y[u] = getint();
      for (t = 0; t < n + 5; t = t + 1) {
        v = getint();
        if (v == 0) break;
        adj_add(u, v - 1);
      }
    }

    for (i = 0; i < n; i = i + 1) {
      c1[i] = 0;
      c2[i] = 0;
    }

    graph_init(n + 2);
    sum = 0;
    for (u = 0; u < n; u = u + 1) {
      for (eidx = adj_head[u]; eidx != -1; eidx = adj_next[eidx]) {
        v = adj_to[eidx];
        dx = x[u] - x[v];
        dy = y[u] - y[v];
        sq = dx * dx + dy * dy;
        d = isqrt_int(sq);
        edge_cost = -d * a + b;
        if (edge_cost >= 0) {
          graph_add_edge(u, v, 1, edge_cost);
        } else {
          graph_add_edge(v, u, 1, -edge_cost);
          c1[v] = c1[v] + 1;
          c2[u] = c2[u] + 1;
          sum = sum + (-edge_cost);
        }
      }
    }

    s = n;
    for (u = 0; u < n; u = u + 1) {
      if (c1[u] > c2[u]) graph_add_edge(s, u, c1[u] - c2[u], 0);
      if (c2[u] > c1[u]) graph_add_edge(u, n + 1, c2[u] - c1[u], 0);
    }

    flow_cost = mincost_maxflow_cost(n, n + 1);
    ans = sum - flow_cost;
    if (ans < 0) ans = 0;

    printf("Case %d: %d", kase, ans);
    printf(".");
    frac = 0;
    if (frac < 10) printf("0");
    printf("%d\n", frac);
  }
  return 0;
}
