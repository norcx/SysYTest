/* Description:
 *   UVa247 Calling Circles (numeric variant)
 *   Input is integer-only:
 *     n
 *     m
 *     u1
 *     v1
 *     ...
 *     um
 *     vm
 *     ... (repeat datasets)
 *     0   (sentinel: terminates)
 *   Nodes are 1..n.
 *   Output prints calling circles using node indices.
 */

const int MAXN = 30;

int n;
int m;
int vis[MAXN];
int d[MAXN * MAXN];

void reset_vis() {
  int i;
  for (i = 0; i < MAXN; i = i + 1) vis[i] = 0;
}

void reset_d() {
  int i;
  for (i = 0; i < MAXN * MAXN; i = i + 1) d[i] = 0;
}

void dfs(int u) {
  int v;
  vis[u] = 1;
  for (v = 0; v < n; v = v + 1) {
    if (vis[v] == 0 && d[u * MAXN + v] == 1 && d[v * MAXN + u] == 1) {
      printf(", %d", v + 1);
      dfs(v);
    }
  }
}

int main() {
  int kase;
  int i;
  int j;
  int k;
  int u;
  int v;

  kase = 0;
  for (;;) {
    n = getint();
    if (n == 0) break;
    m = getint();

    reset_d();
    for (i = 0; i < n; i = i + 1) d[i * MAXN + i] = 1;

    for (i = 0; i < m; i = i + 1) {
      u = getint();
      v = getint();
      u = u - 1;
      v = v - 1;
      d[u * MAXN + v] = 1;
    }

    for (k = 0; k < n; k = k + 1) {
      for (i = 0; i < n; i = i + 1) {
        for (j = 0; j < n; j = j + 1) {
          if (d[i * MAXN + k] == 1 && d[k * MAXN + j] == 1) d[i * MAXN + j] = 1;
        }
      }
    }

    if (kase > 0) printf("\n");
    kase = kase + 1;
    printf("Calling circles for data set %d:\n", kase);

    reset_vis();
    for (i = 0; i < n; i = i + 1) {
      if (vis[i] == 0) {
        printf("%d", i + 1);
        dfs(i);
        printf("\n");
      }
    }
  }
  return 0;
}
