/* Description:
 *   Strict SysY port of UVa12096 (SetStack Computer).
 *   Input is integer-encoded operations:
 *     0=PUSH, 1=DUP, 2=UNION, 3=INTERSECT, 4=ADD
 */

const int OP_PUSH = 0;
const int OP_DUP = 1;
const int OP_UNION = 2;
const int OP_INTER = 3;
const int OP_ADD = 4;

const int MAX_SETS = 512;
const int MAX_POOL = 20000;
const int MAX_TMP = 512;
const int MAX_STACK = 512;

int setStart[MAX_SETS];
int setLen[MAX_SETS];
int setElems[MAX_POOL];
int numSets;
int poolPtr;

int tmpArr[MAX_TMP];

int elemAt(int setId, int pos) {
    return setElems[setStart[setId] + pos];
}

int equalToTmp(int setId, int a[], int len) {
    int i;
    if (setLen[setId] != len) return 0;
    for (i = 0; i < len; i = i + 1) {
        if (elemAt(setId, i) != a[i]) return 0;
    }
    return 1;
}

int internSet(int a[], int len) {
    int id;
    int i;
    for (id = 0; id < numSets; id = id + 1) {
        if (equalToTmp(id, a, len) == 1) return id;
    }

    setStart[numSets] = poolPtr;
    setLen[numSets] = len;
    for (i = 0; i < len; i = i + 1) {
        setElems[poolPtr + i] = a[i];
    }
    poolPtr = poolPtr + len;
    numSets = numSets + 1;
    return numSets - 1;
}

int makeUnion(int id1, int id2) {
    int len1;
    int len2;
    int i;
    int j;
    int tlen;
    int step;
    int a;
    int b;

    len1 = setLen[id1];
    len2 = setLen[id2];
    i = 0;
    j = 0;
    tlen = 0;

    for (step = 0; step < MAX_TMP; step = step + 1) {
        if (i >= len1 && j >= len2) break;
        if (i >= len1) {
            tmpArr[tlen] = elemAt(id2, j);
            j = j + 1;
            tlen = tlen + 1;
        } else if (j >= len2) {
            tmpArr[tlen] = elemAt(id1, i);
            i = i + 1;
            tlen = tlen + 1;
        } else {
            a = elemAt(id1, i);
            b = elemAt(id2, j);
            if (a < b) {
                tmpArr[tlen] = a;
                i = i + 1;
                tlen = tlen + 1;
            } else if (a > b) {
                tmpArr[tlen] = b;
                j = j + 1;
                tlen = tlen + 1;
            } else {
                tmpArr[tlen] = a;
                i = i + 1;
                j = j + 1;
                tlen = tlen + 1;
            }
        }
    }

    return internSet(tmpArr, tlen);
}

int makeInter(int id1, int id2) {
    int len1;
    int len2;
    int i;
    int j;
    int tlen;
    int step;
    int a;
    int b;

    len1 = setLen[id1];
    len2 = setLen[id2];
    i = 0;
    j = 0;
    tlen = 0;

    for (step = 0; step < MAX_TMP; step = step + 1) {
        if (i >= len1 || j >= len2) break;
        a = elemAt(id1, i);
        b = elemAt(id2, j);
        if (a < b) {
            i = i + 1;
        } else if (a > b) {
            j = j + 1;
        } else {
            tmpArr[tlen] = a;
            tlen = tlen + 1;
            i = i + 1;
            j = j + 1;
        }
    }

    return internSet(tmpArr, tlen);
}

int makeAdd(int elem, int baseId) {
    int len;
    int i;
    int tlen;
    int inserted;
    int v;

    len = setLen[baseId];
    tlen = 0;
    inserted = 0;

    for (i = 0; i < len; i = i + 1) {
        v = elemAt(baseId, i);
        if (inserted == 0 && elem < v) {
            tmpArr[tlen] = elem;
            tlen = tlen + 1;
            inserted = 1;
        }
        if (v == elem) inserted = 1;
        tmpArr[tlen] = v;
        tlen = tlen + 1;
    }

    if (inserted == 0) {
        tmpArr[tlen] = elem;
        tlen = tlen + 1;
    }

    return internSet(tmpArr, tlen);
}

int main() {
    int T;
    int tc;
    int n;
    int i;
    int op;

    int st[MAX_STACK];
    int sp;

    int aId;
    int bId;
    int resId;

    numSets = 1;
    poolPtr = 0;
    setStart[0] = 0;
    setLen[0] = 0;

    T = getint();
    for (tc = 0; tc < T; tc = tc + 1) {
        n = getint();
        sp = 0;
        for (i = 0; i < n; i = i + 1) {
            op = getint();
            if (op == OP_PUSH) {
                st[sp] = 0;
                sp = sp + 1;
            } else if (op == OP_DUP) {
                st[sp] = st[sp - 1];
                sp = sp + 1;
            } else {
                aId = st[sp - 1];
                sp = sp - 1;
                bId = st[sp - 1];
                sp = sp - 1;

                if (op == OP_UNION) resId = makeUnion(aId, bId);
                else if (op == OP_INTER) resId = makeInter(aId, bId);
                else resId = makeAdd(aId, bId);

                st[sp] = resId;
                sp = sp + 1;
            }

            printf("%d\n", setLen[st[sp - 1]]);
        }
        printf("***\n");
    }
    return 0;
}
