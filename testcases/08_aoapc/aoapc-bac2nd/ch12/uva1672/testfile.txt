/* Description:
 *   Strict SysY adaptation of UVa1672 "Disjoint Regular Expressions":
 *   build epsilon-NFA from a regex, remove epsilon transitions, then BFS
 *   the product automaton to find a non-empty common string (if any).
 *
 *   Input encoding (integers, 1 per line):
 *     T
 *     For each case:
 *       lenA, then lenA tokens
 *       lenB, then lenB tokens
 *
 *   Tokens:
 *     letters: 1..26 (a..z)
 *     '('=27, ')'=28, '|'=29, '*'=30
 *
 *   Output:
 *     "Correct\n" if disjoint; otherwise "Wrong\n" and one witness string as
 *     letter-codes separated by single spaces on the next line.
 */

const int MAXS = 128;
const int MAXTOK = 128;
const int MAXNODE = 512;
const int MAXOUT = 32;
const int MAXQ = 20000;

const int NODE_A = 1;
const int NODE_STAR = 2;
const int NODE_OR = 3;
const int NODE_CONCAT = 4;

const int TOK_LP = 27;
const int TOK_RP = 28;
const int TOK_OR = 29;
const int TOK_STAR = 30;
const int TOK_CONCAT = 31;

const int EPS = -1;

int regexLen[2];
int regexTok[2 * MAXTOK];

int nodeType[MAXNODE];
int nodeVal[MAXNODE];
int nodeL[MAXNODE];
int nodeR[MAXNODE];
int nodeCnt;

int nodeStack[MAXTOK];
int opStack[MAXTOK];
int nodeTop;
int opTop;

int nStates[2];
int outCount[2 * MAXS];
int outCh[2 * MAXS * MAXOUT];
int outNext[2 * MAXS * MAXOUT];
int ssCount[2];
int ssList[2 * MAXS];

int closure[MAXS * MAXS];
int closureQ[MAXS];

int tmpOutCount[MAXS];
int tmpCh[MAXS * MAXOUT];
int tmpNext[MAXS * MAXOUT];

int qS1[MAXQ];
int qS2[MAXQ];
int qFa[MAXQ];
int qCh[MAXQ];
int visProd[MAXS * MAXS];
int pathChars[MAXQ];

int stateIndex(int which, int s) {
  return which * MAXS + s;
}

int transIndex(int which, int s, int k) {
  return (which * MAXS + s) * MAXOUT + k;
}

int tokAt(int which, int pos) {
  return regexTok[which * MAXTOK + pos];
}

int newNode(int type, int l, int r, int val) {
  int idx;
  idx = nodeCnt;
  nodeCnt = nodeCnt + 1;
  nodeType[idx] = type;
  nodeL[idx] = l;
  nodeR[idx] = r;
  nodeVal[idx] = val;
  return idx;
}

int prec(int op) {
  if (op == TOK_OR) return 1;
  if (op == TOK_CONCAT) return 2;
  return 0;
}

void applyBinaryOp(int op) {
  int right;
  int left;
  if (nodeTop < 2) return;
  right = nodeStack[nodeTop - 1];
  left = nodeStack[nodeTop - 2];
  nodeTop = nodeTop - 2;
  if (op == TOK_OR) nodeStack[nodeTop] = newNode(NODE_OR, left, right, 0);
  else nodeStack[nodeTop] = newNode(NODE_CONCAT, left, right, 0);
  nodeTop = nodeTop + 1;
}

int parseRegexToTree(int which) {
  int i;
  int t;
  int prevAtom;
  int needConcat;

  nodeCnt = 1;
  nodeTop = 0;
  opTop = 0;
  prevAtom = 0;

  for (i = 0; i < regexLen[which]; i = i + 1) {
    t = tokAt(which, i);

    needConcat = 0;
    if (prevAtom == 1) {
      if (t >= 1 && t <= 26 || t == TOK_LP) needConcat = 1;
    }
    if (needConcat == 1) {
      for (; opTop > 0 && opStack[opTop - 1] != TOK_LP && prec(opStack[opTop - 1]) >= prec(TOK_CONCAT); ) {
        applyBinaryOp(opStack[opTop - 1]);
        opTop = opTop - 1;
      }
      opStack[opTop] = TOK_CONCAT;
      opTop = opTop + 1;
    }

    if (t >= 1 && t <= 26) {
      nodeStack[nodeTop] = newNode(NODE_A, 0, 0, t);
      nodeTop = nodeTop + 1;
      prevAtom = 1;
    } else if (t == TOK_LP) {
      opStack[opTop] = TOK_LP;
      opTop = opTop + 1;
      prevAtom = 0;
    } else if (t == TOK_RP) {
      for (; opTop > 0 && opStack[opTop - 1] != TOK_LP; ) {
        applyBinaryOp(opStack[opTop - 1]);
        opTop = opTop - 1;
      }
      if (opTop > 0 && opStack[opTop - 1] == TOK_LP) opTop = opTop - 1;
      prevAtom = 1;
    } else if (t == TOK_OR) {
      for (; opTop > 0 && opStack[opTop - 1] != TOK_LP && prec(opStack[opTop - 1]) >= prec(TOK_OR); ) {
        applyBinaryOp(opStack[opTop - 1]);
        opTop = opTop - 1;
      }
      opStack[opTop] = TOK_OR;
      opTop = opTop + 1;
      prevAtom = 0;
    } else if (t == TOK_STAR) {
      if (nodeTop > 0) {
        nodeStack[nodeTop - 1] = newNode(NODE_STAR, nodeStack[nodeTop - 1], 0, 0);
      }
      prevAtom = 1;
    }
  }

  for (; opTop > 0; ) {
    if (opStack[opTop - 1] == TOK_LP) opTop = opTop - 1;
    else {
      applyBinaryOp(opStack[opTop - 1]);
      opTop = opTop - 1;
    }
  }

  if (nodeTop == 0) return 0;
  return nodeStack[0];
}

void clearNFA(int which) {
  int s;
  nStates[which] = 0;
  for (s = 0; s < MAXS; s = s + 1) outCount[stateIndex(which, s)] = 0;
  ssCount[which] = 0;
}

void addTrans(int which, int s, int t, int ch) {
  int si;
  int k;
  si = stateIndex(which, s);
  k = outCount[si];
  if (k >= MAXOUT) return;
  outCh[transIndex(which, s, k)] = ch;
  outNext[transIndex(which, s, k)] = t;
  outCount[si] = k + 1;
}

void processNode(int which, int u) {
  int st;
  int m;

  st = nStates[which];
  nStates[which] = nStates[which] + 1;

  if (nodeType[u] == NODE_A) {
    addTrans(which, st, nStates[which], nodeVal[u]);
  } else if (nodeType[u] == NODE_STAR) {
    processNode(which, nodeL[u]);
    addTrans(which, st, st + 1, EPS);
    addTrans(which, st, nStates[which], EPS);
    addTrans(which, nStates[which] - 1, st, EPS);
  } else if (nodeType[u] == NODE_OR) {
    processNode(which, nodeL[u]);
    m = nStates[which];
    processNode(which, nodeR[u]);
    addTrans(which, st, st + 1, EPS);
    addTrans(which, st, m, EPS);
    addTrans(which, m - 1, nStates[which], EPS);
    addTrans(which, nStates[which] - 1, nStates[which], EPS);
  } else if (nodeType[u] == NODE_CONCAT) {
    addTrans(which, st, st + 1, EPS);
    processNode(which, nodeL[u]);
    addTrans(which, nStates[which] - 1, nStates[which], EPS);
    processNode(which, nodeR[u]);
    addTrans(which, nStates[which] - 1, nStates[which], EPS);
  }

  nStates[which] = nStates[which] + 1;
}

void initNFA(int which) {
  int root;
  clearNFA(which);
  root = parseRegexToTree(which);
  if (root != 0) processNode(which, root);
}

void addUniqueTmp(int from, int ch, int to) {
  int k;
  int idx;
  for (k = 0; k < tmpOutCount[from]; k = k + 1) {
    idx = from * MAXOUT + k;
    if (tmpCh[idx] == ch && tmpNext[idx] == to) return;
  }
  if (tmpOutCount[from] >= MAXOUT) return;
  idx = from * MAXOUT + tmpOutCount[from];
  tmpCh[idx] = ch;
  tmpNext[idx] = to;
  tmpOutCount[from] = tmpOutCount[from] + 1;
}

void removeEpsilon(int which) {
  int n;
  int i;
  int j;
  int head;
  int tail;
  int s;
  int k;
  int ch;
  int x;
  int t;
  int cnt;
  int si;
  int idx;

  n = nStates[which];

  for (i = 0; i < MAXS * MAXS; i = i + 1) closure[i] = 0;

  for (i = 0; i < n; i = i + 1) {
    head = 0;
    tail = 0;
    closure[i * MAXS + i] = 1;
    closureQ[tail] = i;
    tail = tail + 1;

    for (; head < tail; head = head + 1) {
      s = closureQ[head];
      cnt = outCount[stateIndex(which, s)];
      for (k = 0; k < cnt; k = k + 1) {
        idx = transIndex(which, s, k);
        if (outCh[idx] == EPS) {
          x = outNext[idx];
          if (closure[i * MAXS + x] == 0) {
            closure[i * MAXS + x] = 1;
            closureQ[tail] = x;
            tail = tail + 1;
          }
        }
      }
    }
  }

  ssCount[which] = 0;
  for (j = 0; j < n; j = j + 1) {
    if (closure[j] == 1) {
      ssList[which * MAXS + ssCount[which]] = j;
      ssCount[which] = ssCount[which] + 1;
    }
  }

  for (i = 0; i < n; i = i + 1) tmpOutCount[i] = 0;

  for (i = 0; i < n; i = i + 1) {
    for (s = 0; s < n; s = s + 1) {
      if (closure[i * MAXS + s] == 0) continue;
      cnt = outCount[stateIndex(which, s)];
      for (k = 0; k < cnt; k = k + 1) {
        idx = transIndex(which, s, k);
        ch = outCh[idx];
        if (ch == EPS) continue;
        x = outNext[idx];
        for (t = 0; t < n; t = t + 1) {
          if (closure[x * MAXS + t] == 1) addUniqueTmp(i, ch, t);
        }
      }
    }
  }

  for (i = 0; i < n; i = i + 1) {
    si = stateIndex(which, i);
    outCount[si] = tmpOutCount[i];
    for (k = 0; k < tmpOutCount[i]; k = k + 1) {
      outCh[transIndex(which, i, k)] = tmpCh[i * MAXOUT + k];
      outNext[transIndex(which, i, k)] = tmpNext[i * MAXOUT + k];
    }
  }
}

void printWitness(int found) {
  int len;
  int i;
  int t;
  len = 0;
  t = found;
  for (; t != -1; ) {
    if (qFa[t] != -1) {
      pathChars[len] = qCh[t];
      len = len + 1;
    }
    t = qFa[t];
  }
  for (i = len - 1; i >= 0; i = i - 1) {
    printf("%d", pathChars[i]);
    if (i != 0) printf(" ");
  }
  printf("\n");
}

void solveCase() {
  int i;
  int j;
  int head;
  int tail;
  int s1;
  int s2;
  int endA;
  int endB;
  int aCnt;
  int bCnt;
  int ai;
  int bi;
  int ch1;
  int ch2;
  int ns1;
  int ns2;
  int idx1;
  int idx2;
  int found;

  removeEpsilon(0);
  removeEpsilon(1);

  for (i = 0; i < MAXS * MAXS; i = i + 1) visProd[i] = 0;

  endA = nStates[0] - 1;
  endB = nStates[1] - 1;

  head = 0;
  tail = 0;
  for (i = 0; i < ssCount[0]; i = i + 1) {
    s1 = ssList[0 * MAXS + i];
    for (j = 0; j < ssCount[1]; j = j + 1) {
      s2 = ssList[1 * MAXS + j];
      if (s1 != endA || s2 != endB) visProd[s1 * MAXS + s2] = 1;
      qS1[tail] = s1;
      qS2[tail] = s2;
      qFa[tail] = -1;
      qCh[tail] = 0;
      tail = tail + 1;
    }
  }

  found = -1;

  for (; head < tail; head = head + 1) {
    s1 = qS1[head];
    s2 = qS2[head];
    if (s1 == endA && s2 == endB && qFa[head] != -1) {
      found = head;
      head = tail;
    } else {
      aCnt = outCount[stateIndex(0, s1)];
      bCnt = outCount[stateIndex(1, s2)];
      for (ai = 0; ai < aCnt; ai = ai + 1) {
        idx1 = transIndex(0, s1, ai);
        ch1 = outCh[idx1];
        ns1 = outNext[idx1];
        for (bi = 0; bi < bCnt; bi = bi + 1) {
          idx2 = transIndex(1, s2, bi);
          ch2 = outCh[idx2];
          if (ch1 == ch2) {
            ns2 = outNext[idx2];
            if (visProd[ns1 * MAXS + ns2] == 0) {
              visProd[ns1 * MAXS + ns2] = 1;
              if (tail < MAXQ) {
                qS1[tail] = ns1;
                qS2[tail] = ns2;
                qFa[tail] = head;
                qCh[tail] = ch1;
                tail = tail + 1;
              }
            }
          }
        }
      }
    }
  }

  if (found != -1) {
    printf("Wrong\n");
    printWitness(found);
  } else {
    printf("Correct\n");
  }
}

void readRegex(int which) {
  int len;
  int i;
  len = getint();
  if (len < 0) len = 0;
  if (len >= MAXTOK) len = MAXTOK - 1;
  regexLen[which] = len;
  for (i = 0; i < len; i = i + 1) regexTok[which * MAXTOK + i] = getint();
  regexTok[which * MAXTOK + len] = 0;
}

int main() {
  int T;
  int c;
  T = getint();
  if (T < 0) T = 0;

  for (c = 0; c < T; c = c + 1) {
    readRegex(0);
    readRegex(1);
    initNFA(0);
    initNFA(1);
    solveCase();
  }
  return 0;
}
