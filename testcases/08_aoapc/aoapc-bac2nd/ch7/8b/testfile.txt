/* Description:
 *   8-puzzle BFS with hash table (scaled for strict SysY limits).
 *   Input: 18 integers (start 9, goal 9), one per line.
 *   Output: minimum moves or -1.
 */

const int MAXSTATE = 30000;
const int MAXHASHSIZE = 30011;

int st[MAXSTATE * 9];
int goal[9];
int dist[MAXSTATE];

int head[MAXHASHSIZE];
int next[MAXSTATE];

const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

void init_lookup_table() {
    int i;
    for (i = 0; i < MAXHASHSIZE; i = i + 1) head[i] = 0;
    return;
}

int states_equal(int a, int b) {
    int i;
    for (i = 0; i < 9; i = i + 1) {
        if (st[a * 9 + i] != st[b * 9 + i]) return 0;
    }
    return 1;
    return 0;
}

int state_equal_to_goal(int s) {
    int i;
    for (i = 0; i < 9; i = i + 1) {
        if (st[s * 9 + i] != goal[i]) return 0;
    }
    return 1;
    return 0;
}

int hash_state(int s) {
    int v;
    int i;
    v = 0;
    for (i = 0; i < 9; i = i + 1) v = v * 10 + st[s * 9 + i];
    return v % MAXHASHSIZE;
    return 0;
}

int try_to_insert(int s) {
    int h;
    int u;
    h = hash_state(s);
    for (u = head[h]; u != 0; u = next[u]) {
        if (states_equal(u, s) == 1) return 0;
    }
    next[s] = head[h];
    head[h] = s;
    return 1;
    return 0;
}

int bfs() {
    int front;
    int rear;
    int z;
    int x;
    int y;
    int d;
    int newx;
    int newy;
    int newz;
    int i;

    init_lookup_table();
    try_to_insert(1);
    rear = 2;

    for (front = 1; front < rear; front = front + 1) {
        if (state_equal_to_goal(front) == 1) return front;

        for (z = 0; z < 9; z = z + 1) {
            if (st[front * 9 + z] == 0) break;
        }
        x = z / 3;
        y = z - x * 3;

        for (d = 0; d < 4; d = d + 1) {
            newx = x + dx[d];
            newy = y + dy[d];
            if (newx >= 0 && newx < 3 && newy >= 0 && newy < 3) {
                if (rear >= MAXSTATE) return 0;
                newz = newx * 3 + newy;

                for (i = 0; i < 9; i = i + 1) {
                    st[rear * 9 + i] = st[front * 9 + i];
                }
                st[rear * 9 + newz] = st[front * 9 + z];
                st[rear * 9 + z] = st[front * 9 + newz];

                dist[rear] = dist[front] + 1;
                if (try_to_insert(rear) == 1) rear = rear + 1;
            }
        }
    }

    return 0;
}

int main() {
    int i;
    int ans;

    for (i = 0; i < 9; i = i + 1) st[1 * 9 + i] = getint();
    for (i = 0; i < 9; i = i + 1) goal[i] = getint();

    ans = bfs();
    if (ans > 0) printf("%d\n", dist[ans]);
    else printf("%d\n", -1);
    return 0;
}
