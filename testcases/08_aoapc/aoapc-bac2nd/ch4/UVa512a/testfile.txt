/* Description:
 *   Converted from UVa512 "Spreadsheet Tracking".
 *   Commands encoded as integers in input:
 *     1: EX  r1 c1 r2 c2
 *     2: DR  a x1..xa
 *     3: DC  a x1..xa
 *     4: IR  a x1..xa
 *     5: IC  a x1..xa
 *
 *   Input terminates with r = 0 (still provides c and n).
 */

const int MAXD = 110;
const int BIG = 10000;
const int SIZE = 12100;

int r, c, n;
int d[12100];
int d2[12100];
int ans[12100];
int cols[110];

int idx(int i, int j) {
    return i * MAXD + j;
}

void clear_int_array(int arr[], int len) {
    int i;
    for (i = 0; i < len; i = i + 1) {
        arr[i] = 0;
    }
    return;
}

void copy_all(int dst[], int src[], int len) {
    int i;
    for (i = 0; i < len; i = i + 1) {
        dst[i] = src[i];
    }
    return;
}

void copy_line(int isRow, int p, int q) {
    int i;
    if (isRow == 1) {
        for (i = 1; i <= c; i = i + 1) {
            d[idx(p, i)] = d2[idx(q, i)];
        }
    } else {
        for (i = 1; i <= r; i = i + 1) {
            d[idx(i, p)] = d2[idx(i, q)];
        }
    }
    return;
}

void del_op(int isRow) {
    int total;
    int newCount;
    int i;
    copy_all(d2, d, SIZE);
    if (isRow == 1) total = r;
    else total = c;

    newCount = 0;
    for (i = 1; i <= total; i = i + 1) {
        if (cols[i] == 0) {
            newCount = newCount + 1;
            copy_line(isRow, newCount, i);
        }
    }
    if (isRow == 1) r = newCount;
    else c = newCount;
    return;
}

void ins_op(int isRow) {
    int total;
    int newCount;
    int i;
    copy_all(d2, d, SIZE);
    if (isRow == 1) total = r;
    else total = c;

    newCount = 0;
    for (i = 1; i <= total; i = i + 1) {
        if (cols[i] != 0) {
            newCount = newCount + 1;
            copy_line(isRow, newCount, 0);
        }
        newCount = newCount + 1;
        copy_line(isRow, newCount, i);
    }
    if (isRow == 1) r = newCount;
    else c = newCount;
    return;
}

int main() {
    int r1, c1, r2, c2;
    int q;
    int kase;
    int op;
    int cmd;
    int a;
    int k;
    int x;
    int i;
    int j;
    int v;
    int origR;
    int origC;

    kase = 0;
    clear_int_array(d, SIZE);

    for (op = 0; op < 1000; op = op + 1) {
        r = getint();
        c = getint();
        n = getint();
        if (r == 0) break;

        for (i = 1; i <= r; i = i + 1) {
            for (j = 1; j <= c; j = j + 1) {
                d[idx(i, j)] = i * BIG + j;
            }
        }

        for (k = 0; k < n; k = k + 1) {
            cmd = getint();
            if (cmd == 1) {
                r1 = getint();
                c1 = getint();
                r2 = getint();
                c2 = getint();
                v = d[idx(r1, c1)];
                d[idx(r1, c1)] = d[idx(r2, c2)];
                d[idx(r2, c2)] = v;
            } else {
                a = getint();
                clear_int_array(cols, MAXD);
                for (i = 0; i < a; i = i + 1) {
                    x = getint();
                    cols[x] = 1;
                }
                if (cmd == 2) del_op(1);
                else if (cmd == 3) del_op(0);
                else if (cmd == 4) ins_op(1);
                else ins_op(0);
            }
        }

        clear_int_array(ans, SIZE);
        for (i = 1; i <= r; i = i + 1) {
            for (j = 1; j <= c; j = j + 1) {
                v = d[idx(i, j)];
                origR = v / BIG;
                origC = v % BIG;
                ans[idx(origR, origC)] = i * BIG + j;
            }
        }

        if (kase > 0) printf("\n");
        kase = kase + 1;
        printf("Spreadsheet #%d\n", kase);

        q = getint();
        for (i = 0; i < q; i = i + 1) {
            r1 = getint();
            c1 = getint();
            printf("Cell data in (%d,%d) ", r1, c1);
            v = ans[idx(r1, c1)];
            if (v == 0) printf("GONE\n");
            else printf("moved to (%d,%d)\n", v / BIG, v % BIG);
        }
    }

    return 0;
}
