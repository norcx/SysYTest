/* Description:
 *   Converted from `codes/2023fa/exam/E3/J.c`.
 *   Finds the maximum subarray sum with length <= m on a circular array.
 *   Uses a monotonic queue over prefix sums (O(n)).
 */

int a[256];
int s[256];
int q[256];

int main() {
    int n;
    int m;
    int i;
    int head;
    int tail;
    int ans;
    int total;

    n = getint();
    m = getint();
    if (m > n) {
        m = n;
    }

    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
        a[n + i] = a[i];
        a[2 * n + i] = a[i];
    }

    total = 3 * n;
    s[0] = 0;
    for (i = 1; i <= total; i = i + 1) {
        s[i] = s[i - 1] + a[i];
    }

    head = 1;
    tail = 1;
    q[1] = 0;
    ans = -1000000000;

    for (i = 1; i <= total; i = i + 1) {
        for (; head <= tail && q[head] < i - m; head = head + 1) {
        }

        if (ans < s[i] - s[q[head]]) {
            ans = s[i] - s[q[head]];
        }

        for (; head <= tail && s[q[tail]] >= s[i]; tail = tail - 1) {
        }
        tail = tail + 1;
        q[tail] = i;
    }

    printf("%d\n", ans);
    return 0;
}
