/* Description:
 *   Converted from codes/2023fa/exam/E7/D.c into Strict SysY.
 *
 *   Original behavior (C):
 *     - read a line `str`
 *     - read a scanf-style `format`
 *     - read k, x
 *     - extract one token with `sscanf(str, format, s)`
 *     - print it using "%k.xs" (width k, precision x)
 *
 *   Strict SysY has no strings, so we encode both strings as ASCII codes.
 *
 *   Input format (integers; one per line):
 *     n_str
 *     str[0..n_str-1]   (ASCII codes; spaces are 32)
 *     n_fmt
 *     fmt[0..n_fmt-1]   (ASCII codes)
 *     k
 *     x
 *
 *   Supported `format` subset: some "%*s" skips, then a "%s" capture.
 *   Output is the resulting printed characters as ASCII codes, 1 per line.
 */

int parse_format_skip_count(int fmt[], int n_fmt) {
    int i;
    int skips;
    skips = 0;
    for (i = 0; i < n_fmt; i = i + 1) {
        if (fmt[i] == 37) { /* '%' */
            if (i + 2 < n_fmt && fmt[i + 1] == 42 && fmt[i + 2] == 115) { /* "*s" */
                skips = skips + 1;
                i = i + 2;
            } else if (i + 1 < n_fmt && fmt[i + 1] == 115) { /* "s" */
                return skips;
            }
        }
    }
    return -1;
}

int extract_token_ascii(int str[], int n_str, int token_index, int out[], int out_max) {
    int i;
    int token;
    int in_token;
    int out_len;
    token = 0;
    in_token = 0;
    out_len = 0;
    for (i = 0; i < n_str; i = i + 1) {
        int c;
        c = str[i];
        if (c != 32) {
            if (in_token == 0) {
                in_token = 1;
            }
            if (token == token_index) {
                if (out_len < out_max) {
                    out[out_len] = c;
                    out_len = out_len + 1;
                }
            }
        } else {
            if (in_token == 1) {
                in_token = 0;
                token = token + 1;
            }
        }
    }
    return out_len;
}

int main() {
    int str[1100];
    int fmt[300];
    int out[1100];
    int n_str;
    int n_fmt;
    int i;
    int k;
    int x;

    n_str = getint();
    if (n_str < 0) n_str = 0;
    if (n_str > 1100) n_str = 1100;
    for (i = 0; i < n_str; i = i + 1) {
        str[i] = getint();
    }

    n_fmt = getint();
    if (n_fmt < 0) n_fmt = 0;
    if (n_fmt > 300) n_fmt = 300;
    for (i = 0; i < n_fmt; i = i + 1) {
        fmt[i] = getint();
    }

    k = getint();
    x = getint();
    if (x < 0) x = 0;

    {
        int skip_count;
        int out_len;
        int trunc_len;
        int pad;

        skip_count = parse_format_skip_count(fmt, n_fmt);
        if (skip_count < 0) {
            return 0;
        }

        out_len = extract_token_ascii(str, n_str, skip_count, out, 1100);
        trunc_len = out_len;
        if (trunc_len > x) trunc_len = x;

        pad = k - trunc_len;
        if (pad < 0) pad = 0;

        for (i = 0; i < pad; i = i + 1) {
            printf("%d\n", 32);
        }
        for (i = 0; i < trunc_len; i = i + 1) {
            printf("%d\n", out[i]);
        }
    }

    return 0;
}
