/* Description:
 *   Converted from codes/2023fa/contest/C6/D.c
 *   Original logic: for each (x,y,z), print max(popcount(x xor y), popcount(x xor z), popcount(y xor z)).
 *   Strict SysY constraints: no bitwise ops; compute popcount(xor) via /2 and %2 per bit.
 *
 * Input format (strict):
 *   t
 *   x1
 *   y1
 *   z1
 *   ...
 *   xt
 *   yt
 *   zt
 */

int max2(int a, int b) {
    if (a > b) return a;
    return b;
}

int popcount_xor(int a, int b) {
    int cnt;
    int i;
    int aa;
    int bb;
    int ba;
    int bb2;

    cnt = 0;
    aa = a;
    bb = b;

    i = 0;
    for (i = 0; i < 31; i = i + 1) {
        ba = aa % 2;
        bb2 = bb % 2;
        if (ba != bb2) cnt = cnt + 1;
        aa = aa / 2;
        bb = bb / 2;
    }
    return cnt;
}

int main() {
    int t;
    int i;
    int x;
    int y;
    int z;
    int a;
    int b;
    int c;

    t = getint();
    i = 0;
    for (i = 0; i < t; i = i + 1) {
        x = getint();
        y = getint();
        z = getint();
        a = popcount_xor(y, z);
        b = popcount_xor(x, y);
        c = popcount_xor(x, z);
        printf("%d\n", max2(a, max2(b, c)));
    }
    return 0;
}
