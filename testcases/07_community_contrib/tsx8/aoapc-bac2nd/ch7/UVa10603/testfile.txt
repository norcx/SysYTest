/* UVa 10603 - Fill (scaled/translated to Strict SysY)
 * Dijkstra on jug states (a,b) with total water = c.
 */

const int MAX = 205;

int cap[3];
int mark[MAX * MAX];
int dista[MAX * MAX];
int ans[MAX];

int idx(int x, int y) {
    return x * MAX + y;
}

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

void update_ans(int x, int y, int d) {
    int z;
    z = cap[2] - x - y;

    if (ans[x] < 0 || d < ans[x]) ans[x] = d;
    if (ans[y] < 0 || d < ans[y]) ans[y] = d;
    if (ans[z] < 0 || d < ans[z]) ans[z] = d;
}

void solve(int a, int b, int c, int d) {
    int i;
    int j;
    int x;
    int y;
    int bestDist;
    int bestX;
    int bestY;
    int curDist;
    int z;
    int id;

    cap[0] = a;
    cap[1] = b;
    cap[2] = c;

    for (i = 0; i < MAX; i = i + 1) ans[i] = -1;
    for (i = 0; i < MAX * MAX; i = i + 1) {
        mark[i] = 0;
        dista[i] = -1;
    }

    dista[idx(0, 0)] = 0;

    for (;;) {
        bestDist = -1;
        bestX = 0;
        bestY = 0;

        for (x = 0; x <= cap[0]; x = x + 1) {
            for (y = 0; y <= cap[1]; y = y + 1) {
                if (x + y > cap[2]) continue;
                id = idx(x, y);
                if (mark[id] != 0) continue;
                curDist = dista[id];
                if (curDist < 0) continue;
                if (bestDist < 0 || curDist < bestDist) {
                    bestDist = curDist;
                    bestX = x;
                    bestY = y;
                }
            }
        }

        if (bestDist < 0) break;

        id = idx(bestX, bestY);
        if (mark[id] != 0) continue;
        mark[id] = 1;

        update_ans(bestX, bestY, bestDist);
        if (d >= 0 && d < MAX && ans[d] >= 0) break;

        z = cap[2] - bestX - bestY;
        for (i = 0; i < 3; i = i + 1) {
            for (j = 0; j < 3; j = j + 1) {
                int v[3];
                int amount;
                int nid;
                int nd;

                if (i == j) continue;

                v[0] = bestX;
                v[1] = bestY;
                v[2] = z;

                if (v[i] == 0) continue;
                if (v[j] == cap[j]) continue;

                amount = min2(v[i], cap[j] - v[j]);
                v[i] = v[i] - amount;
                v[j] = v[j] + amount;

                nid = idx(v[0], v[1]);
                nd = bestDist + amount;
                if (dista[nid] < 0 || nd < dista[nid]) dista[nid] = nd;
            }
        }
    }

    for (;d >= 0;) {
        if (d < MAX && ans[d] >= 0) {
            printf("%d %d\n", ans[d], d);
            return;
        }
        d = d - 1;
    }
}

int main() {
    int T;
    int a;
    int b;
    int c;
    int d;
    T = getint();
    for (;T > 0;) {
        a = getint();
        b = getint();
        c = getint();
        d = getint();
        solve(a, b, c, d);
        T = T - 1;
    }
    return 0;
}
