/* Description:
 *   [Add description here]
 */
// 8-puzzle BFS (scaled for SysY constraints)
const int MAXSTATE = 20000;

int st[MAXSTATE * 9];
int dist[MAXSTATE];
int goal[9];
int goalKey;

int visKey[MAXSTATE];
int visCount;

void init_lookup_table() {
  visCount = 0;
}

int try_to_insert_key(int key) {
  int i;
  for (i = 0; i < visCount; i = i + 1) {
    if (visKey[i] == key) return 0;
  }
  if (visCount >= MAXSTATE) return 0;
  visKey[visCount] = key;
  visCount = visCount + 1;
  return 1;
}

int bfs() {
  int front;
  int rear;
  int i;
  int z;
  int x;
  int y;
  int d;
  int newx;
  int newy;
  int newz;
  int tmp;
  int key;

  init_lookup_table();

  front = 0;
  rear = 1;

  dist[0] = 0;
  key = 0;
  for (i = 0; i < 9; i = i + 1) key = key * 10 + st[i];
  try_to_insert_key(key);

  for (front = 0; front < rear; front = front + 1) {
    key = 0;
    z = 0;
    for (i = 0; i < 9; i = i + 1) {
      tmp = st[front * 9 + i];
      key = key * 10 + tmp;
      if (tmp == 0) z = i;
    }
    if (key == goalKey) return front;

    x = z / 3;
    y = z - x * 3;

    for (d = 0; d < 4; d = d + 1) {
      newx = x;
      newy = y;
      if (d == 0) newx = x - 1;
      if (d == 1) newx = x + 1;
      if (d == 2) newy = y - 1;
      if (d == 3) newy = y + 1;

      if (newx >= 0 && newx < 3 && newy >= 0 && newy < 3) {
        if (rear >= MAXSTATE) return -1;
        newz = newx * 3 + newy;

        for (i = 0; i < 9; i = i + 1) {
          st[rear * 9 + i] = st[front * 9 + i];
        }

        tmp = st[rear * 9 + newz];
        st[rear * 9 + newz] = st[rear * 9 + z];
        st[rear * 9 + z] = tmp;

        dist[rear] = dist[front] + 1;

        key = 0;
        for (i = 0; i < 9; i = i + 1) {
          key = key * 10 + st[rear * 9 + i];
        }

        if (try_to_insert_key(key) == 1) {
          rear = rear + 1;
        }
      }
    }
  }

  return -1;
}

int main() {
  int i;
  int ans;

  for (i = 0; i < 9; i = i + 1) st[i] = getint();
  goalKey = 0;
  for (i = 0; i < 9; i = i + 1) {
    goal[i] = getint();
    goalKey = goalKey * 10 + goal[i];
  }

  ans = bfs();
  if (ans >= 0) printf("%d\n", dist[ans]);
  else printf("-1\n");

  return 0;
}
