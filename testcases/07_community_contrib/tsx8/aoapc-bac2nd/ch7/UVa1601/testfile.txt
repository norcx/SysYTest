/* Description:
 *   SysY testcase: 3-ghost grid BFS with collision constraints.
 */
// Converted to Strict SysY from UVa1601 "The Morning after Halloween"
// Input encoding:
// - First line per case: w, h, n (3 ghosts max). Terminate with n == 0.
// - Then h*w integers (row-major):
//   0 = wall
//   1 = empty
//   2/3/4 = start of ghost a/b/c
//   5/6/7 = target of ghost A/B/C

const int MAXS = 20;
const int MAXGRID = 400; // 20*20
const int MAXC = 30;     // max empty cells (+2 fakes) used by this testcase
const int MAXSTATE = 27000; // MAXC^3

const int DX0 = 1;
const int DY0 = 0;
const int DX1 = -1;
const int DY1 = 0;
const int DX2 = 0;
const int DY2 = 1;
const int DX3 = 0;
const int DY3 = -1;
const int DX4 = 0;
const int DY4 = 0;

int s0, s1, s2;
int t0, t1, t2;

int deg[MAXC];
int G[MAXC * 5];

int cellType[MAXGRID];
int posToId[MAXGRID];
int xPos[MAXC];
int yPos[MAXC];

int distArr[MAXSTATE];
int qArr[MAXSTATE];

int qa[MAXSTATE];
int qb[MAXSTATE];
int qc[MAXSTATE];

int aMul[MAXC];
int bMul[MAXC];
int gBase[MAXC];

int bfs(int cnt) {
  int total;
  int cc;
  int i;
  int head;
  int tail;
  int start;

  cc = cnt * cnt;
  total = cc * cnt;
  for (i = 0; i < total; i = i + 1) distArr[i] = -1;

  for (i = 0; i < cnt; i = i + 1) {
    aMul[i] = i * cc;
    bMul[i] = i * cnt;
    gBase[i] = i * 5;
  }

  head = 0;
  tail = 0;
  start = aMul[s0] + bMul[s1] + s2;
  distArr[start] = 0;
  qArr[tail] = start;
  qa[tail] = s0;
  qb[tail] = s1;
  qc[tail] = s2;
  tail = tail + 1;

  for (; head < tail; ) {
    int u;
    int a;
    int b;
    int c;
    int da;
    int iMove;
    int jMove;
    int kMove;

    u = qArr[head];
    a = qa[head];
    b = qb[head];
    c = qc[head];
    head = head + 1;

    if (a == t0 && b == t1 && c == t2) return distArr[u];

    da = distArr[u] + 1;

    for (iMove = 0; iMove < deg[a]; iMove = iMove + 1) {
      int a2;
      a2 = G[gBase[a] + iMove];
      for (jMove = 0; jMove < deg[b]; jMove = jMove + 1) {
        int b2;
        b2 = G[gBase[b] + jMove];
        if (a2 == b2) continue;
        if (a2 == b && b2 == a) continue;
        for (kMove = 0; kMove < deg[c]; kMove = kMove + 1) {
          int c2;
          int v;
          c2 = G[gBase[c] + kMove];
          if (a2 == c2) continue;
          if (a2 == c && c2 == a) continue;
          if (b2 == c2) continue;
          if (b2 == c && c2 == b) continue;
          v = aMul[a2] + bMul[b2] + c2;
          if (distArr[v] != -1) continue;
          distArr[v] = da;
          qArr[tail] = v;
          qa[tail] = a2;
          qb[tail] = b2;
          qc[tail] = c2;
          tail = tail + 1;
        }
      }
    }
  }

  return -1;
}

int main() {
  int w;
  int h;
  int n;

  for (; ; ) {
    int i;
    int j;
    int cnt;

    w = getint();
    h = getint();
    n = getint();
    if (n == 0) break;

    for (i = 0; i < MAXGRID; i = i + 1) {
      cellType[i] = 0;
      posToId[i] = -1;
    }

    s0 = -1;
    s1 = -1;
    s2 = -1;
    t0 = -1;
    t1 = -1;
    t2 = -1;

    for (i = 0; i < h; i = i + 1) {
      for (j = 0; j < w; j = j + 1) {
        int p;
        p = i * w + j;
        cellType[p] = getint();
      }
    }

    cnt = 0;
    for (i = 0; i < h; i = i + 1) {
      for (j = 0; j < w; j = j + 1) {
        int p;
        int v;
        p = i * w + j;
        v = cellType[p];
        if (v != 0) {
          if (cnt < MAXC) {
            xPos[cnt] = i;
            yPos[cnt] = j;
            posToId[p] = cnt;
            if (v == 2) s0 = cnt;
            if (v == 3) s1 = cnt;
            if (v == 4) s2 = cnt;
            if (v == 5) t0 = cnt;
            if (v == 6) t1 = cnt;
            if (v == 7) t2 = cnt;
            cnt = cnt + 1;
          }
        }
      }
    }

    for (i = 0; i < cnt; i = i + 1) {
      int dir;
      deg[i] = 0;
      for (dir = 0; dir < 5; dir = dir + 1) {
        int nx;
        int ny;
        int np;
        int ok;

        nx = xPos[i];
        ny = yPos[i];
        if (dir == 0) { nx = nx + DX0; ny = ny + DY0; }
        if (dir == 1) { nx = nx + DX1; ny = ny + DY1; }
        if (dir == 2) { nx = nx + DX2; ny = ny + DY2; }
        if (dir == 3) { nx = nx + DX3; ny = ny + DY3; }
        if (dir == 4) { nx = nx + DX4; ny = ny + DY4; }

        ok = 0;
        if (nx >= 0 && nx < h && ny >= 0 && ny < w) ok = 1;
        if (ok == 1) {
          np = nx * w + ny;
          if (cellType[np] != 0) {
            G[i * 5 + deg[i]] = posToId[np];
            deg[i] = deg[i] + 1;
          }
        }
      }
    }

    if (n <= 2) {
      deg[cnt] = 1;
      G[cnt * 5 + 0] = cnt;
      s2 = cnt;
      t2 = cnt;
      cnt = cnt + 1;
    }
    if (n <= 1) {
      deg[cnt] = 1;
      G[cnt * 5 + 0] = cnt;
      s1 = cnt;
      t1 = cnt;
      cnt = cnt + 1;
    }

    if (s0 < 0) s0 = 0;
    if (s1 < 0) s1 = 0;
    if (s2 < 0) s2 = 0;
    if (t0 < 0) t0 = 0;
    if (t1 < 0) t1 = 0;
    if (t2 < 0) t2 = 0;

    printf("%d\n", bfs(cnt));
  }

  return 0;
}
