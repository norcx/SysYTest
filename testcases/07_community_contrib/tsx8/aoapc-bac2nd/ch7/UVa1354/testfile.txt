// Converted from UVa1354 "Mobile Computing" to Strict SysY (int-only).
// Distances are handled with fixed-point integers (SCALE units).

const int MAXN = 6;
const int MAXSUB = 64;
const int SCALE = 10000;
const int MAXS = 2048;

int n;
int rS;
int w[MAXN];
int pow2[MAXN + 1];
int sumW[MAXSUB];
int vis[MAXSUB];
int cnt[MAXSUB];
int Ls[MAXSUB * MAXS];
int Rs[MAXSUB * MAXS];

int max_int(int a, int b) {
  if (a > b) return a;
  return b;
}

void dfs(int subset) {
  if (vis[subset] != 0) return;
  vis[subset] = 1;
  cnt[subset] = 0;

  int have_children = 0;
  int left;
  for (left = 1; left < subset; left = left + 1) {
    int ok = 1;
    int i;
    for (i = 0; i < n; i = i + 1) {
      int bleft = (left / pow2[i]) % 2;
      int bsub = (subset / pow2[i]) % 2;
      if (bleft != 0 && bsub == 0) ok = 0;
    }
    if (ok != 0) {
      int right = subset - left;
      if (right != 0) {
        have_children = 1;
        dfs(left);
        dfs(right);

        int d1 = sumW[right] * SCALE / sumW[subset];
        int d2 = sumW[left] * SCALE / sumW[subset];

        int i2;
        for (i2 = 0; i2 < cnt[left]; i2 = i2 + 1) {
          int j2;
          for (j2 = 0; j2 < cnt[right]; j2 = j2 + 1) {
            int L1 = Ls[left * MAXS + i2];
            int R1 = Rs[left * MAXS + i2];
            int L2 = Ls[right * MAXS + j2];
            int R2 = Rs[right * MAXS + j2];

            int tL = max_int(L1 + d1, L2 - d2);
            int tR = max_int(R2 + d2, R1 - d1);

            if (tL + tR < rS) {
              if (cnt[subset] < MAXS) {
                int idx = subset * MAXS + cnt[subset];
                Ls[idx] = tL;
                Rs[idx] = tR;
                cnt[subset] = cnt[subset] + 1;
              }
            }
          }
        }
      }
    }
  }

  if (have_children == 0) {
    Ls[subset * MAXS] = 0;
    Rs[subset * MAXS] = 0;
    cnt[subset] = 1;
  }
}

int main() {
  int T;
  T = getint();
  int tc;
  for (tc = 0; tc < T; tc = tc + 1) {
    rS = getint();
    n = getint();

    int i;
    for (i = 0; i < n; i = i + 1) w[i] = getint();

    pow2[0] = 1;
    for (i = 1; i <= n; i = i + 1) pow2[i] = pow2[i - 1] * 2;

    int totalSub = pow2[n];
    int s;
    for (s = 0; s < totalSub; s = s + 1) {
      sumW[s] = 0;
      for (i = 0; i < n; i = i + 1) {
        if (((s / pow2[i]) % 2) != 0) sumW[s] = sumW[s] + w[i];
      }
      vis[s] = 0;
      cnt[s] = 0;
    }

    int root = totalSub - 1;
    dfs(root);

    int ans = -1;
    for (i = 0; i < cnt[root]; i = i + 1) {
      int width = Ls[root * MAXS + i] + Rs[root * MAXS + i];
      if (width > ans) ans = width;
    }
    printf("%d\n", ans);
  }
  return 0;
}
