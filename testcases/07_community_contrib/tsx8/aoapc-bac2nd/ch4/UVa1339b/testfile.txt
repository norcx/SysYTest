/* UVa1339 Ancient Cipher (Strict SysY)
 *
 * This is a SysY-friendly reformulation of the classic "Ancient Cipher".
 *
 * Input (newline-separated integers only):
 *   n
 *   s1[0..n-1]   each in [0, 25] for 'A'..'Z'
 *   s2[0..n-1]   each in [0, 25] for 'A'..'Z'
 *   repeat...
 *   0            terminator (do not rely on EOF)
 *
 * Output:
 *   1 if the two strings are anagrams under a substitution cipher (multiset of
 *   letter frequencies matches), else 0. One line per case.
 */

void sort26(int a[]) {
  int i;
  int j;
  int t;
  for (i = 0; i < 26; i = i + 1) {
    for (j = i + 1; j < 26; j = j + 1) {
      if (a[i] > a[j]) {
        t = a[i];
        a[i] = a[j];
        a[j] = t;
      }
    }
  }
  return;
}

int main() {
  int n;
  int i;
  int x;
  int ok;
  int cnt1[26];
  int cnt2[26];

  for (;;) {
    n = getint();
    if (n == 0) break;

    for (i = 0; i < 26; i = i + 1) {
      cnt1[i] = 0;
      cnt2[i] = 0;
    }

    for (i = 0; i < n; i = i + 1) {
      x = getint();
      cnt1[x] = cnt1[x] + 1;
    }
    for (i = 0; i < n; i = i + 1) {
      x = getint();
      cnt2[x] = cnt2[x] + 1;
    }

    sort26(cnt1);
    sort26(cnt2);

    ok = 1;
    for (i = 0; i < 26; i = i + 1) {
      if (cnt1[i] != cnt2[i]) ok = 0;
    }
    printf("%d\n", ok);
  }

  return 0;
}
