// Converted from UVa1380 "A Scheduling Problem" (Rujia Liu)
// Input format (integer-only):
// T
// For each testcase:
//   M
//   M lines: a b dir
//     dir = 0 (undirected), 1 (a->b), 2 (b->a)

const int MAXN = 210;
const int MAXE = 1000;
const int INF = 1000000000;

int head[210];
int to[1000];
int edDir[1000];
int nxt[1000];
int ecnt;

int n;
int root;
int maxlen;

int f[210];
int g[210];
int haveFather[210];

int dfsVis[210];
int dfsMemo[210];

int undW[44100];
int undF[44100];
int undG[44100];
int suffixBuf[44100];

int max2(int a, int b) {
  if (a > b) return a;
  return b;
}

int min2(int a, int b) {
  if (a < b) return a;
  return b;
}

void clear_case() {
  int i;
  i = 0;
  for (i = 0; i < MAXN; i = i + 1) {
    head[i] = -1;
    haveFather[i] = 0;
    dfsVis[i] = 0;
    f[i] = 0;
    g[i] = 0;
  }
  ecnt = 0;
  n = 0;
  root = 1;
}

void add_edge(int u, int v, int d) {
  to[ecnt] = v;
  edDir[ecnt] = d;
  nxt[ecnt] = head[u];
  head[u] = ecnt;
  ecnt = ecnt + 1;
}

int dfs(int u) {
  int ans;
  int e;
  int v;
  int cand;
  if (dfsVis[u] == 1) return dfsMemo[u];
  dfsVis[u] = 1;

  ans = 0;
  e = -1;
  for (e = head[u]; e != -1; e = nxt[e]) {
    if (edDir[e] == 1) {
      v = to[e];
      cand = dfs(v) + 1;
      ans = max2(ans, cand);
    }
  }

  dfsMemo[u] = ans;
  return ans;
}

void swap3(int idx1, int idx2) {
  int t;
  t = undW[idx1]; undW[idx1] = undW[idx2]; undW[idx2] = t;
  t = undF[idx1]; undF[idx1] = undF[idx2]; undF[idx2] = t;
  t = undG[idx1]; undG[idx1] = undG[idx2]; undG[idx2] = t;
}

void sort_by_f(int base, int s) {
  int i;
  int j;
  int best;
  i = 0;
  for (i = 0; i < s; i = i + 1) {
    best = i;
    j = i + 1;
    for (j = i + 1; j < s; j = j + 1) {
      if (undF[base + j] < undF[base + best]) best = j;
    }
    if (best != i) swap3(base + i, base + best);
  }
}

void sort_by_g(int base, int s) {
  int i;
  int j;
  int best;
  i = 0;
  for (i = 0; i < s; i = i + 1) {
    best = i;
    j = i + 1;
    for (j = i + 1; j < s; j = j + 1) {
      if (undG[base + j] < undG[base + best]) best = j;
    }
    if (best != i) swap3(base + i, base + best);
  }
}

int dp(int i, int fa) {
  int e;
  int w;
  int d;
  int s;
  int base;
  int f0;
  int g0;
  int k;
  int p;
  int ff;
  int gg;

  s = 0;
  f0 = 0;
  g0 = 0;

  e = -1;
  for (e = head[i]; e != -1; e = nxt[e]) {
    w = to[e];
    if (w != fa) {
      dp(w, i);
      d = edDir[e];
      if (d == 0) {
        base = i * MAXN;
        undW[base + s] = w;
        undF[base + s] = f[w];
        undG[base + s] = g[w];
        s = s + 1;
      } else if (d == 1) {
        g0 = max2(g0, g[w] + 1);
      } else {
        f0 = max2(f0, f[w] + 1);
      }
    }
  }

  if (s == 0) {
    f[i] = f0;
    g[i] = g0;
    if (f[i] + g[i] > maxlen) {
      f[i] = INF;
      g[i] = INF;
    }
    if (f[i] < INF) return 1;
    return 0;
  }

  f[i] = INF;
  g[i] = INF;

  base = i * MAXN;

  sort_by_f(base, s);
  suffixBuf[base + s - 1] = undG[base + s - 1];
  k = s - 2;
  for (k = s - 2; k >= 0; k = k - 1) {
    suffixBuf[base + k] = max2(undG[base + k], suffixBuf[base + k + 1]);
  }
  p = 0;
  for (p = 0; p <= s; p = p + 1) {
    ff = f0;
    gg = g0;
    if (p > 0) ff = max2(ff, undF[base + p - 1] + 1);
    if (p < s) gg = max2(gg, suffixBuf[base + p] + 1);
    if (ff + gg <= maxlen) f[i] = min2(f[i], ff);
  }

  sort_by_g(base, s);
  suffixBuf[base + s - 1] = undF[base + s - 1];
  k = s - 2;
  for (k = s - 2; k >= 0; k = k - 1) {
    suffixBuf[base + k] = max2(undF[base + k], suffixBuf[base + k + 1]);
  }
  p = 0;
  for (p = 0; p <= s; p = p + 1) {
    ff = f0;
    gg = g0;
    if (p > 0) gg = max2(gg, undG[base + p - 1] + 1);
    if (p < s) ff = max2(ff, suffixBuf[base + p] + 1);
    if (ff + gg <= maxlen) g[i] = min2(g[i], gg);
  }

  if (f[i] < INF) return 1;
  return 0;
}

void read_case() {
  int m;
  int i;
  int a;
  int b;
  int d;

  clear_case();
  m = getint();
  i = 0;
  for (i = 0; i < m; i = i + 1) {
    a = getint();
    b = getint();
    d = getint();
    if (a > n) n = a;
    if (b > n) n = b;
    haveFather[b] = 1;
    if (d == 1) {
      add_edge(a, b, 1);
      add_edge(b, a, 2);
    } else if (d == 2) {
      add_edge(a, b, 2);
      add_edge(b, a, 1);
    } else {
      add_edge(a, b, 0);
    }
  }

  root = 1;
  i = 1;
  for (i = 1; i <= n; i = i + 1) {
    if (haveFather[i] == 0) {
      root = i;
      break;
    }
  }
}

int main() {
  int T;
  int tc;
  int i;
  int ok;

  T = getint();
  tc = 0;
  for (tc = 0; tc < T; tc = tc + 1) {
    read_case();

    maxlen = 0;
    i = 1;
    for (i = 1; i <= n; i = i + 1) {
      maxlen = max2(maxlen, dfs(i));
    }

    ok = dp(root, -1);
    if (ok == 1) printf("%d\n", maxlen + 1);
    else printf("%d\n", maxlen + 2);
  }
  return 0;
}
