/* Description:
 *   Converted from UVa10618 "Tango Tango Insurrection" DP solution.
 *   Input format (integers, 1 per line):
 *     Repeated testcases:
 *       n            (0 terminates)
 *       s0..s(n-1)   each is 0='.', 1='U', 2='L', 3='R', 4='D'
 *   Output:
 *     For each testcase, output n lines, each is the chosen foot:
 *       0 = no move, 1 = left foot, 2 = right foot
 *     Then output -1 as testcase separator.
 */

const int UP = 0;
const int LEFT = 1;
const int RIGHT = 2;
const int DOWN = 3;

const int MAXN = 80;

int d[MAXN * 4 * 4 * 3];
int actArr[MAXN * 4 * 4 * 3];
int seqArr[MAXN];
int mapPos[5];

int idx(int i, int a, int b, int s) {
    return ((i * 4 + a) * 4 + b) * 3 + s;
}

int energy_move(int from, int to) {
    if (from == to) return 3;
    if (from + to == 3) return 7;
    return 5;
}

void try_update(int i, int a, int b, int s, int f, int t) {
    int ta;
    int tb;
    int e;
    int cost;
    int nextIdx;
    int curIdx;

    ta = a;
    tb = b;
    if (f == 1) ta = t;
    else if (f == 2) tb = t;

    if (ta == tb) return;
    if (ta == RIGHT && tb == LEFT) return;
    if (a == RIGHT && tb != b) return;
    if (b == LEFT && ta != a) return;

    if (f == 0) e = 0;
    else if (f != s) e = 1;
    else {
        if (f == 1) e = energy_move(a, ta);
        else e = energy_move(b, tb);
    }

    nextIdx = idx(i + 1, ta, tb, f);
    curIdx = idx(i, a, b, s);
    cost = d[nextIdx] + e;
    if (cost < d[curIdx]) {
        d[curIdx] = cost;
        actArr[curIdx] = f * 4 + t;
    }
}

int main() {
    int n;
    int i;
    int a;
    int b;
    int s;
    int t;

    mapPos[0] = 0;
    mapPos[1] = UP;
    mapPos[2] = LEFT;
    mapPos[3] = RIGHT;
    mapPos[4] = DOWN;

    for (;;) {
        n = getint();
        if (n == 0) break;

        if (n > MAXN - 1) n = MAXN - 1;
        for (i = 0; i < n; i = i + 1) seqArr[i] = getint();

        for (a = 0; a < 4; a = a + 1)
            for (b = 0; b < 4; b = b + 1)
                for (s = 0; s < 3; s = s + 1) d[idx(n, a, b, s)] = 0;

        for (i = n - 1; i >= 0; i = i - 1)
            for (a = 0; a < 4; a = a + 1)
                for (b = 0; b < 4; b = b + 1)
                    if (a != b)
                        for (s = 0; s < 3; s = s + 1) {
                            d[idx(i, a, b, s)] = 10 * n;
                            actArr[idx(i, a, b, s)] = 0;

                            if (seqArr[i] == 0) {
                                try_update(i, a, b, s, 0, 0);
                                for (t = 0; t < 4; t = t + 1) {
                                    try_update(i, a, b, s, 1, t);
                                    try_update(i, a, b, s, 2, t);
                                }
                            } else {
                                t = mapPos[seqArr[i]];
                                try_update(i, a, b, s, 1, t);
                                try_update(i, a, b, s, 2, t);
                            }
                        }

        a = LEFT;
        b = RIGHT;
        s = 0;
        for (i = 0; i < n; i = i + 1) {
            int act;
            int f;
            int pos;

            act = actArr[idx(i, a, b, s)];
            f = act / 4;
            pos = act % 4;
            printf("%d\n", f);

            s = f;
            if (f == 1) a = pos;
            else if (f == 2) b = pos;
        }
        printf("%d\n", -1);
    }

    return 0;
}
