/* Description:
 *   UVa12170 Easy Climb (scaled to int / Strict SysY)
 *   DP on "useful" heights with sorting + sliding-window minimum.
 */

const int MAXN = 105;
const int MAXX = MAXN * MAXN * 2;
const int INF = 1000000000;

int h[MAXN];
int x[MAXX];
int dp0[MAXX];
int dp1[MAXX];

int abs_int(int v) {
  if (v < 0) return 0 - v;
  return v;
}

void swap_x(int i, int j) {
  int tmp;
  tmp = x[i];
  x[i] = x[j];
  x[j] = tmp;
}

void quicksort_x(int l, int r) {
  int i;
  int j;
  int pivot;
  if (l >= r) return;
  i = l;
  j = r;
  pivot = x[(l + r) / 2];
  for (; i <= j; ) {
    for (; x[i] < pivot; i = i + 1) { }
    for (; x[j] > pivot; j = j - 1) { }
    if (i <= j) {
      swap_x(i, j);
      i = i + 1;
      j = j - 1;
    }
  }
  if (l < j) quicksort_x(l, j);
  if (i < r) quicksort_x(i, r);
  return;
}

int unique_x(int n) {
  int i;
  int m;
  if (n <= 0) return 0;
  m = 1;
  for (i = 1; i < n; i = i + 1) {
    if (x[i] != x[m - 1]) {
      x[m] = x[i];
      m = m + 1;
    }
  }
  return m;
}

int main() {
  int T;
  int tc;
  T = getint();
  for (tc = 0; tc < T; tc = tc + 1) {
    int n;
    int d;
    int i;
    int j;
    int nx;
    int diff;
    int t;
    n = getint();
    d = getint();
    for (i = 0; i < n; i = i + 1) h[i] = getint();

    diff = abs_int(h[0] - h[n - 1]);
    if (diff > (n - 1) * d) {
      printf("impossible\n");
      continue;
    }

    nx = 0;
    for (i = 0; i < n; i = i + 1) {
      int k;
      k = 0 - n + 1;
      for (; k <= n - 1; k = k + 1) {
        x[nx] = h[i] + k * d;
        nx = nx + 1;
      }
    }

    if (nx > 1) quicksort_x(0, nx - 1);
    nx = unique_x(nx);

    for (i = 0; i < nx; i = i + 1) {
      dp0[i] = INF;
      if (x[i] == h[0]) dp0[i] = 0;
    }

    t = 0;
    for (i = 1; i < n; i = i + 1) {
      int k;
      k = 0;

      if (t == 0) {
        for (j = 0; j < nx; j = j + 1) {
          int left;
          int right;
          int best;
          int cost;
          int add;

          left = x[j] - d;
          right = x[j] + d;

          for (; k < nx && x[k] < left; k = k + 1) { }
          for (; k + 1 < nx && x[k + 1] <= right && dp0[k + 1] <= dp0[k]; k = k + 1) { }

          best = dp0[k];
          if (best == INF) dp1[j] = INF;
          else {
            add = abs_int(x[j] - h[i]);
            cost = best + add;
            dp1[j] = cost;
          }
        }
      } else {
        for (j = 0; j < nx; j = j + 1) {
          int left;
          int right;
          int best;
          int cost;
          int add;

          left = x[j] - d;
          right = x[j] + d;

          for (; k < nx && x[k] < left; k = k + 1) { }
          for (; k + 1 < nx && x[k + 1] <= right && dp1[k + 1] <= dp1[k]; k = k + 1) { }

          best = dp1[k];
          if (best == INF) dp0[j] = INF;
          else {
            add = abs_int(x[j] - h[i]);
            cost = best + add;
            dp0[j] = cost;
          }
        }
      }

      t = 1 - t;
    }

    for (i = 0; i < nx; i = i + 1) {
      if (x[i] == h[n - 1]) {
        if (t == 0) printf("%d\n", dp0[i]);
        else printf("%d\n", dp1[i]);
      }
    }
  }
  return 0;
}
