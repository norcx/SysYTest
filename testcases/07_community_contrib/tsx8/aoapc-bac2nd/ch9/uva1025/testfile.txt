/* Description:
 *   Converted from UVa1025 "A Spy in the Metro" (DP).
 *   Strict SysY subset: int/void only, for-loops only, 1D arrays only.
 *
 *   Input format (newline-separated integers):
 *     Repeated testcases:
 *       n
 *       T
 *       t1..t(n-1)
 *       M1
 *       M1 departure times (right)
 *       M2
 *       M2 departure times (left)
 *     Terminator:
 *       0
 *       0
 */

int t_global[55];
int has_right_global[205 * 55];
int has_left_global[205 * 55];
int dp_global[205 * 55];

int idx(int time, int station) {
  return time * 55 + station;
}

int main() {
  int INF;
  int kase;
  int n;
  int T;
  int i;
  int j;
  int M1;
  int M2;
  int d0;
  int d;
  int time;
  int station;
  int base;
  int cand;

  INF = 1000000000;
  kase = 0;

  for (;; ) {
    n = getint();
    T = getint();
    if (n == 0) break;

    for (i = 1; i <= n - 1; i = i + 1) t_global[i] = getint();

    for (time = 0; time <= T; time = time + 1) {
      for (station = 1; station <= n; station = station + 1) {
        has_right_global[idx(time, station)] = 0;
        has_left_global[idx(time, station)] = 0;
        dp_global[idx(time, station)] = INF;
      }
    }

    M1 = getint();
    for (i = 0; i < M1; i = i + 1) {
      d0 = getint();
      d = d0;
      for (j = 1; j <= n - 1; j = j + 1) {
        if (d <= T) has_right_global[idx(d, j)] = 1;
        d = d + t_global[j];
      }
    }

    M2 = getint();
    for (i = 0; i < M2; i = i + 1) {
      d0 = getint();
      d = d0;
      for (j = n - 1; j >= 1; j = j - 1) {
        if (d <= T) has_left_global[idx(d, j + 1)] = 1;
        d = d + t_global[j];
      }
    }

    dp_global[idx(T, n)] = 0;

    for (time = T - 1; time >= 0; time = time - 1) {
      for (station = 1; station <= n; station = station + 1) {
        base = dp_global[idx(time + 1, station)] + 1;
        dp_global[idx(time, station)] = base;

        if (station < n && has_right_global[idx(time, station)] != 0 && time + t_global[station] <= T) {
          cand = dp_global[idx(time + t_global[station], station + 1)];
          if (cand < dp_global[idx(time, station)]) dp_global[idx(time, station)] = cand;
        }

        if (station > 1 && has_left_global[idx(time, station)] != 0 && time + t_global[station - 1] <= T) {
          cand = dp_global[idx(time + t_global[station - 1], station - 1)];
          if (cand < dp_global[idx(time, station)]) dp_global[idx(time, station)] = cand;
        }
      }
    }

    kase = kase + 1;
    printf("Case Number %d: ", kase);
    if (dp_global[idx(0, 1)] >= INF) printf("impossible\n");
    else printf("%d\n", dp_global[idx(0, 1)]);
  }

  return 0;
}
