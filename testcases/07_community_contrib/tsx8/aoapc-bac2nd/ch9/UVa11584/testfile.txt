/* Description:
 *   Minimal palindrome partitioning (UVa11584 style), rewritten in Strict SysY.
 *
 * Input format (integers only, one per line):
 *   T
 *   For each testcase:
 *     n
 *     a1
 *     a2
 *     ...
 *     an
 *
 * Where a1..an encode the original string's characters (e.g., a=1..z=26).
 *
 * Output:
 *   For each testcase, print the minimum number of palindromic substrings
 *   that partition the sequence.
 */

const int MAXN = 205;

int a[MAXN];
int pal[MAXN * MAXN];
int d[MAXN];

int idx(int i, int j) {
    return i * MAXN + j;
}

int main() {
    int T;
    int kase;
    int n;
    int i;
    int j;
    int len;

    T = getint();

    for (kase = 1; kase <= T; kase = kase + 1) {
        n = getint();

        for (i = 1; i <= n; i = i + 1) {
            a[i] = getint();
        }

        for (i = 1; i <= n; i = i + 1) {
            pal[idx(i, i)] = 1;
        }

        for (len = 2; len <= n; len = len + 1) {
            for (i = 1; i + len - 1 <= n; i = i + 1) {
                j = i + len - 1;
                if (a[i] == a[j]) {
                    if (len == 2) {
                        pal[idx(i, j)] = 1;
                    } else {
                        if (pal[idx(i + 1, j - 1)] == 1) {
                            pal[idx(i, j)] = 1;
                        } else {
                            pal[idx(i, j)] = 0;
                        }
                    }
                } else {
                    pal[idx(i, j)] = 0;
                }
            }
        }

        d[0] = 0;
        for (i = 1; i <= n; i = i + 1) {
            d[i] = n + 1;
            for (j = 0; j < i; j = j + 1) {
                if (pal[idx(j + 1, i)] == 1) {
                    if (d[j] + 1 < d[i]) {
                        d[i] = d[j] + 1;
                    }
                }
            }
        }

        printf("%d\n", d[n]);
    }

    return 0;
}
