/* Description:
 *   Converted from UVa1252 "Twenty Questions" reference solution.
 *   Input format (integers, one per line):
 *     Repeat:
 *       m
 *       n
 *       n lines: object feature masks (0..2^m-1)
 *     Terminate with n = 0 (still provide m then n).
 *   Output:
 *     For each case, minimal worst-case questions.
 */

const int MAXM = 8;
const int MAXN = 128;
const int MAXS = 256;
const int MAXSS = 65536;

int kase;
int n;
int m;
int size;

int pow2[MAXM + 1];
int features_list[MAXN];

int vis[MAXSS];
int d[MAXSS];
int cnt[MAXSS];

int idx(int s, int a) {
  return s * size + a;
}

int hasBit(int mask, int k) {
  int t;
  t = mask / pow2[k];
  t = t % 2;
  if (t == 0) return 0;
  return 1;
}

int interMask(int s, int features) {
  int k;
  int res;
  res = 0;
  k = 0;
  for (k = 0; k < m; k = k + 1) {
    if (hasBit(s, k) == 1 && hasBit(features, k) == 1) {
      res = res + pow2[k];
    }
  }
  return res;
}

int imax(int a, int b) {
  if (a > b) return a;
  return b;
}

int dp(int s, int a) {
  int c;
  int k;
  int ans;
  int s2;
  int a2;
  int need;
  int v1;
  int v2;

  c = cnt[idx(s, a)];
  if (c <= 1) return 0;
  if (c == 2) return 1;

  if (vis[idx(s, a)] == kase) return d[idx(s, a)];
  vis[idx(s, a)] = kase;

  ans = m;
  for (k = 0; k < m; k = k + 1) {
    if (hasBit(s, k) == 0) {
      s2 = s + pow2[k];
      a2 = a + pow2[k];
      if (cnt[idx(s2, a2)] >= 1 && cnt[idx(s2, a)] >= 1) {
        v1 = dp(s2, a2);
        v2 = dp(s2, a);
        need = imax(v1, v2) + 1;
        if (need < ans) ans = need;
      }
    }
  }

  d[idx(s, a)] = ans;
  return ans;
}

void init() {
  int i;
  int s;
  int f;
  int inter;
  int total;

  total = size * size;
  for (i = 0; i < total; i = i + 1) cnt[i] = 0;

  for (i = 0; i < n; i = i + 1) {
    f = features_list[i];
    for (s = 0; s < size; s = s + 1) {
      inter = interMask(s, f);
      cnt[idx(s, inter)] = cnt[idx(s, inter)] + 1;
    }
  }
}

int main() {
  int i;

  kase = 0;

  for (;;) {
    m = getint();
    n = getint();
    if (n == 0) break;

    if (m > MAXM) m = MAXM;

    kase = kase + 1;

    pow2[0] = 1;
    for (i = 1; i <= m; i = i + 1) pow2[i] = pow2[i - 1] * 2;
    size = pow2[m];

    for (i = 0; i < n; i = i + 1) features_list[i] = getint();

    init();
    printf("%d\n", dp(0, 0));
  }

  return 0;
}
