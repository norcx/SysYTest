/* UVa1375 "The Best Name for Your Baby" (encoded input) */
const int MAXN = 60;
const int MAXS = 200;
const int MAXSYMLEN = 8;
const int MAXL = 10;
const int MAXE = 2000;

int n;
int L;

int ns;
int symLen[MAXS];
int symData[MAXS * MAXSYMLEN];

int carArr[MAXS];
int cdrArr[MAXS];

int headEdge[MAXS];
int toArr[MAXE];
int emptyArr[MAXE];
int nextArr[MAXE];
int ecnt;

int dpOk[MAXS * (MAXL + 1)];
int dpStr[MAXS * (MAXL + 1) * MAXL];

int tmpSeq[MAXSYMLEN];
int tmpLen;

int tmpStr[MAXL];

int dpOkIndex(int id, int len) {
  return id * (MAXL + 1) + len;
}

int dpStrBase(int id, int len) {
  return (id * (MAXL + 1) + len) * MAXL;
}

int isAllTerminalSym(int id) {
  int base;
  int i;
  base = id * MAXSYMLEN;
  i = 0;
  for (i = 0; i < symLen[id]; i = i + 1) {
    if (symData[base + i] < 0) return 0;
    if (symData[base + i] >= 26) return 0;
  }
  return 1;
}

int getIdFromTmp() {
  int i;
  int j;
  int base;
  i = 0;
  for (i = 0; i < ns; i = i + 1) {
    if (symLen[i] != tmpLen) {
    } else {
      base = i * MAXSYMLEN;
      j = 0;
      for (j = 0; j < tmpLen; j = j + 1) {
        if (symData[base + j] != tmpSeq[j]) {
          j = tmpLen + 1;
        }
      }
      if (j == tmpLen) return i;
    }
  }

  symLen[ns] = tmpLen;
  base = ns * MAXSYMLEN;
  j = 0;
  for (j = 0; j < tmpLen; j = j + 1) symData[base + j] = tmpSeq[j];
  carArr[ns] = 0;
  cdrArr[ns] = 0;
  headEdge[ns] = -1;
  ns = ns + 1;
  return ns - 1;
}

void addEdge(int from, int target, int emptySym) {
  toArr[ecnt] = target;
  emptyArr[ecnt] = emptySym;
  nextArr[ecnt] = headEdge[from];
  headEdge[from] = ecnt;
  ecnt = ecnt + 1;
}

void addIntermediateFromTmp() {
  int s;
  int oldLen;
  int h;
  int t;
  int baseS;
  int j;
  int first;

  oldLen = tmpLen;
  s = getIdFromTmp();
  if (oldLen < 2) return;

  baseS = s * MAXSYMLEN;
  first = symData[baseS];

  tmpLen = 1;
  tmpSeq[0] = first;
  h = getIdFromTmp();

  tmpLen = oldLen - 1;
  j = 0;
  for (j = 0; j < tmpLen; j = j + 1) tmpSeq[j] = symData[baseS + 1 + j];
  t = getIdFromTmp();

  addEdge(h, s, t);
  addEdge(t, s, h);
  carArr[s] = h;
  cdrArr[s] = t;
}

int dpLess(int aId, int bId, int len) {
  int i;
  int abase;
  int bbase;
  abase = dpStrBase(aId, len);
  bbase = dpStrBase(bId, len);
  i = 0;
  for (i = 0; i < len; i = i + 1) {
    if (dpStr[abase + i] < dpStr[bbase + i]) return 1;
    if (dpStr[abase + i] > dpStr[bbase + i]) return 0;
  }
  return 0;
}

int bufLessThanDp(int buf[], int dpId, int len) {
  int i;
  int base;
  base = dpStrBase(dpId, len);
  i = 0;
  for (i = 0; i < len; i = i + 1) {
    if (buf[i] < dpStr[base + i]) return 1;
    if (buf[i] > dpStr[base + i]) return 0;
  }
  return 0;
}

void copyDp(int srcId, int dstId, int len) {
  int i;
  int sbase;
  int dbase;
  sbase = dpStrBase(srcId, len);
  dbase = dpStrBase(dstId, len);
  i = 0;
  for (i = 0; i < len; i = i + 1) dpStr[dbase + i] = dpStr[sbase + i];
}

void copyBufToDp(int buf[], int dstId, int len) {
  int i;
  int dbase;
  dbase = dpStrBase(dstId, len);
  i = 0;
  for (i = 0; i < len; i = i + 1) dpStr[dbase + i] = buf[i];
}

void setDpFromSym(int symId, int len) {
  int i;
  int sbase;
  int dbase;
  sbase = symId * MAXSYMLEN;
  dbase = dpStrBase(symId, len);
  i = 0;
  for (i = 0; i < len; i = i + 1) dpStr[dbase + i] = symData[sbase + i];
  dpOk[dpOkIndex(symId, len)] = 1;
}

void searchClosure(int len) {
  int iter;
  int changed;
  int x;
  int edge;
  int target;
  int emptySym;
  int okEmpty;

  iter = 0;
  for (iter = 0; iter < MAXS; iter = iter + 1) {
    changed = 0;
    x = 0;
    for (x = 0; x < ns; x = x + 1) {
      if (dpOk[dpOkIndex(x, len)] == 0) {
      } else {
        edge = headEdge[x];
        for (edge = headEdge[x]; edge != -1; edge = nextArr[edge]) {
          target = toArr[edge];
          emptySym = emptyArr[edge];
          okEmpty = dpOk[dpOkIndex(emptySym, 0)];
          if (okEmpty == 0) {
          } else {
            if (dpOk[dpOkIndex(target, len)] == 0) {
              copyDp(x, target, len);
              dpOk[dpOkIndex(target, len)] = 1;
              changed = 1;
            } else {
              if (dpLess(x, target, len) != 0) {
                copyDp(x, target, len);
                dpOk[dpOkIndex(target, len)] = 1;
                changed = 1;
              }
            }
          }
        }
      }
    }
    if (changed == 0) return;
  }
}

void solveCase() {
  int i;
  int j;
  int k;
  int leftCode;
  int rightLen;
  int ruleSeq[MAXSYMLEN];
  int leftId;
  int rightId;
  int emptyId;
  int start;
  int p;
  int s1;
  int s2;
  int abase;
  int bbase;
  int curOk;
  int sid;
  int outBase;

  ns = 0;
  ecnt = 0;

  i = 0;
  for (i = 0; i < MAXS; i = i + 1) {
    headEdge[i] = -1;
    carArr[i] = 0;
    cdrArr[i] = 0;
    symLen[i] = 0;
  }

  tmpLen = 0;
  emptyId = getIdFromTmp();

  i = 0;
  for (i = 0; i < n; i = i + 1) {
    leftCode = getint();
    rightLen = getint();

    tmpLen = 1;
    tmpSeq[0] = leftCode;
    leftId = getIdFromTmp();

    p = 0;
    for (p = 0; p < rightLen; p = p + 1) {
      ruleSeq[p] = getint();
    }

    tmpLen = rightLen;
    p = 0;
    for (p = 0; p < rightLen; p = p + 1) tmpSeq[p] = ruleSeq[p];
    rightId = getIdFromTmp();

    addEdge(rightId, leftId, emptyId);

    start = 0;
    for (start = 0; start < rightLen; start = start + 1) {
      tmpLen = rightLen - start;
      if (tmpLen < 2) {
      } else {
        p = 0;
        for (p = 0; p < tmpLen; p = p + 1) tmpSeq[p] = ruleSeq[start + p];
        addIntermediateFromTmp();
      }
    }
  }

  i = 0;
  for (i = 0; i < ns; i = i + 1) {
    j = 0;
    for (j = 0; j <= MAXL; j = j + 1) dpOk[dpOkIndex(i, j)] = 0;
  }
  dpOk[dpOkIndex(emptyId, 0)] = 1;

  j = 0;
  for (j = 0; j <= L; j = j + 1) {
    i = 0;
    for (i = 0; i < ns; i = i + 1) {
      if (symLen[i] == j && isAllTerminalSym(i) != 0) {
        setDpFromSym(i, j);
      }

      if (symLen[i] < 2) {
      } else {
        s1 = carArr[i];
        s2 = cdrArr[i];
        k = 1;
        for (k = 1; k < j; k = k + 1) {
          if (dpOk[dpOkIndex(s1, k)] == 0 || dpOk[dpOkIndex(s2, j - k)] == 0) {
          } else {
            abase = dpStrBase(s1, k);
            bbase = dpStrBase(s2, j - k);
            p = 0;
            for (p = 0; p < k; p = p + 1) tmpStr[p] = dpStr[abase + p];
            p = 0;
            for (p = 0; p < j - k; p = p + 1) tmpStr[k + p] = dpStr[bbase + p];

            curOk = dpOk[dpOkIndex(i, j)];
            if (curOk == 0) {
              copyBufToDp(tmpStr, i, j);
              dpOk[dpOkIndex(i, j)] = 1;
            } else {
              if (bufLessThanDp(tmpStr, i, j) != 0) {
                copyBufToDp(tmpStr, i, j);
                dpOk[dpOkIndex(i, j)] = 1;
              }
            }
          }
        }
      }
    }
    searchClosure(j);
  }

  tmpLen = 1;
  tmpSeq[0] = 44;
  sid = getIdFromTmp();

  if (dpOk[dpOkIndex(sid, L)] == 0) {
    printf("%d\n", -1);
    return;
  }

  printf("%d\n", L);
  outBase = dpStrBase(sid, L);
  p = 0;
  for (p = 0; p < L; p = p + 1) {
    printf("%d\n", dpStr[outBase + p]);
  }
}

int main() {
  int inf;
  for (inf = 0; inf == 0; inf = 0) {
    n = getint();
    L = getint();
    if (n == 0) return 0;
    solveCase();
  }
  return 0;
}
