/* Description:
 *   UVa1152: 4 Values Whose Sum is Zero (scaled-down SysY testcase)
 *
 * Input:
 *   T
 *   For each case:
 *     n
 *     n lines of: A[i] B[i] C[i] D[i]  (provided via getint, one integer per line)
 *
 * Output:
 *   For each case, the number of tuples (i,j,k,l) such that
 *     A[i] + B[j] + C[k] + D[l] == 0
 *   Blank line between cases.
 */

int A[450];
int B[450];
int C[450];
int D[450];
int sums[202500];
int tmp[202500];

int lower_bound(int a[], int n, int x) {
  int l;
  int r;
  int m;
  l = 0;
  r = n;
  for (; l < r;) {
    m = (l + r) / 2;
    if (a[m] < x) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return l;
}

int upper_bound(int a[], int n, int x) {
  int l;
  int r;
  int m;
  l = 0;
  r = n;
  for (; l < r;) {
    m = (l + r) / 2;
    if (a[m] <= x) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return l;
}

void merge_sort(int a[], int n) {
  int width;
  int i;
  int left;
  int mid;
  int right;
  int p;
  int q;
  int k;

  for (width = 1; width < n; width = width * 2) {
    for (i = 0; i < n; i = i + 2 * width) {
      left = i;
      mid = i + width;
      right = i + 2 * width;
      if (mid > n) mid = n;
      if (right > n) right = n;

      p = left;
      q = mid;
      k = left;
      for (; p < mid && q < right;) {
        if (a[p] <= a[q]) {
          tmp[k] = a[p];
          p = p + 1;
        } else {
          tmp[k] = a[q];
          q = q + 1;
        }
        k = k + 1;
      }
      for (; p < mid; p = p + 1) {
        tmp[k] = a[p];
        k = k + 1;
      }
      for (; q < right; q = q + 1) {
        tmp[k] = a[q];
        k = k + 1;
      }
    }

    for (i = 0; i < n; i = i + 1) {
      a[i] = tmp[i];
    }
  }
}

int main() {
  int T;
  int t;
  int n;
  int i;
  int j;
  int c;
  int cnt;
  int target;
  int lb;
  int ub;

  T = getint();
  for (t = 0; t < T; t = t + 1) {
    n = getint();
    for (i = 0; i < n; i = i + 1) {
      A[i] = getint();
      B[i] = getint();
      C[i] = getint();
      D[i] = getint();
    }

    c = 0;
    for (i = 0; i < n; i = i + 1) {
      for (j = 0; j < n; j = j + 1) {
        sums[c] = A[i] + B[j];
        c = c + 1;
      }
    }
    merge_sort(sums, c);

    cnt = 0;
    for (i = 0; i < n; i = i + 1) {
      for (j = 0; j < n; j = j + 1) {
        target = -C[i] - D[j];
        lb = lower_bound(sums, c, target);
        ub = upper_bound(sums, c, target);
        cnt = cnt + (ub - lb);
      }
    }

    printf("%d\n", cnt);
    if (t != T - 1) printf("\n");
  }
  return 0;
}
