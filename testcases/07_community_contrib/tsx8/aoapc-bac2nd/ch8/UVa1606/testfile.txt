/* Description:
 *   Strict SysY testcase converted from:
 *     UVa1606 Amphiphilic Carbon Molecules (Rujia Liu)
 *
 *   Translation notes:
 *   - No floating point: polar-angle sorting is done with half-plane + cross product.
 *   - No structs: points/vectors are stored in parallel arrays.
 *   - Only `getint()` for input and `printf("%d\n", ...)` for output.
 */

const int MAXN = 1005;
const int MAXV = 2010;

int opx[MAXN];
int opy[MAXN];
int col[MAXN];

int vx[MAXN];
int vy[MAXN];
int vx2[MAXV];
int vy2[MAXV];

int n;

int halfplane(int x, int y) {
    if (y > 0) return 0;
    if (y == 0 && x >= 0) return 0;
    return 1;
}

int left_turn(int ax, int ay, int bx, int by) {
    int cross;
    cross = ax * by - ay * bx;
    if (cross >= 0) return 1;
    return 0;
}

int less_vec(int ax, int ay, int bx, int by) {
    int ha;
    int hb;
    int cross;
    int la;
    int lb;
    ha = halfplane(ax, ay);
    hb = halfplane(bx, by);
    if (ha < hb) return 1;
    if (ha > hb) return 0;

    cross = ax * by - ay * bx;
    if (cross > 0) return 1;
    if (cross < 0) return 0;

    la = ax * ax + ay * ay;
    lb = bx * bx + by * by;
    if (la < lb) return 1;
    return 0;
}

void swap_pair(int a[], int b[], int i, int j) {
    int t;
    t = a[i];
    a[i] = a[j];
    a[j] = t;
    t = b[i];
    b[i] = b[j];
    b[j] = t;
}

void qsort_vec(int a[], int b[], int l, int r) {
    int i;
    int j;
    int mid;
    int px;
    int py;
    if (l >= r) return;

    mid = (l + r) / 2;
    px = a[mid];
    py = b[mid];
    i = l;
    j = r;

    for (;;) {
        for (;;) {
            if (less_vec(a[i], b[i], px, py)) {
                i = i + 1;
            } else {
                break;
            }
        }
        for (;;) {
            if (less_vec(px, py, a[j], b[j])) {
                j = j - 1;
            } else {
                break;
            }
        }
        if (i <= j) {
            swap_pair(a, b, i, j);
            i = i + 1;
            j = j - 1;
        } else {
            break;
        }
    }

    if (l < j) qsort_vec(a, b, l, j);
    if (i < r) qsort_vec(a, b, i, r);
    return;
}

int solve() {
    int i;
    int j;
    int k;
    int ans;
    int dx;
    int dy;
    int t;
    int r;
    int total;
    if (n <= 2) return 2;
    ans = 0;

    for (i = 0; i < n; i = i + 1) {
        k = 0;
        for (j = 0; j < n; j = j + 1) {
            if (j != i) {
                dx = opx[j] - opx[i];
                dy = opy[j] - opy[i];
                if (col[j] != 0) {
                    dx = 0 - dx;
                    dy = 0 - dy;
                }
                vx[k] = dx;
                vy[k] = dy;
                k = k + 1;
            }
        }

        qsort_vec(vx, vy, 0, k - 1);

        for (t = 0; t < k; t = t + 1) {
            vx2[t] = vx[t];
            vy2[t] = vy[t];
            vx2[t + k] = vx[t];
            vy2[t + k] = vy[t];
        }

        r = 0;
        for (t = 0; t < k; t = t + 1) {
            if (r < t) r = t;
            if (r == t) r = t + 1;
            for (; r < t + k && left_turn(vx[t], vy[t], vx2[r], vy2[r]); r = r + 1) {
            }
            total = (r - t) + 1;
            if (total > ans) ans = total;
        }
    }
    return ans;
}

int main() {
    int i;
    for (;;) {
        n = getint();
        if (n == 0) break;
        for (i = 0; i < n; i = i + 1) {
            opx[i] = getint();
            opy[i] = getint();
            col[i] = getint();
        }
        printf("%d\n", solve());
    }
    return 0;
}
