// UVa1608 Non-boring sequences (Strict SysY)

const int MAXN = 50000 + 5;

int A[MAXN];
int B[MAXN];
int prevv[MAXN];
int nextv[MAXN];
int lastpos[MAXN];

int segL[MAXN];
int segR[MAXN];

void swapB(int i, int j) {
  int t;
  t = B[i];
  B[i] = B[j];
  B[j] = t;
  return;
}

void siftDownB(int start, int end) {
  int root;
  root = start;
  for (; root * 2 + 1 < end; ) {
    int child;
    int swapIdx;
    child = root * 2 + 1;
    swapIdx = root;
    if (B[swapIdx] < B[child]) swapIdx = child;
    if (child + 1 < end && B[swapIdx] < B[child + 1]) swapIdx = child + 1;
    if (swapIdx == root) {
      root = end;
    } else {
      swapB(root, swapIdx);
      root = swapIdx;
    }
  }
  return;
}

void heapSortB(int n) {
  int i;
  for (i = n / 2 - 1; i >= 0; i = i - 1) {
    siftDownB(i, n);
  }
  for (i = n - 1; i > 0; i = i - 1) {
    swapB(0, i);
    siftDownB(0, i);
  }
  return;
}

int lowerBoundB(int n, int x) {
  int l;
  int r;
  l = 0;
  r = n;
  for (; l < r; ) {
    int mid;
    mid = (l + r) / 2;
    if (B[mid] < x) l = mid + 1;
    else r = mid;
  }
  return l;
}

int isUnique(int p, int L, int R) {
  if (prevv[p] < L && nextv[p] > R) return 1;
  return 0;
}

int checkNonBoring(int n) {
  int top;
  top = 0;
  segL[0] = 0;
  segR[0] = n - 1;

  for (; top >= 0; ) {
    int L;
    int R;
    int found;
    int d;

    L = segL[top];
    R = segR[top];
    top = top - 1;

    if (L >= R) {
      found = 1;
    } else {
      found = 0;
      for (d = 0; L + d <= R - d; d = d + 1) {
        if (isUnique(L + d, L, R) == 1) {
          found = 1;
          top = top + 1;
          segL[top] = L;
          segR[top] = L + d - 1;
          top = top + 1;
          segL[top] = L + d + 1;
          segR[top] = R;
          d = R;
        } else {
          if (L + d == R - d) {
            d = R;
          } else {
            if (isUnique(R - d, L, R) == 1) {
              found = 1;
              top = top + 1;
              segL[top] = R - d + 1;
              segR[top] = R;
              top = top + 1;
              segL[top] = L;
              segR[top] = R - d - 1;
              d = R;
            }
          }
        }
      }
    }

    if (found == 0) return 0;
  }
  return 1;
}

int main() {
  int T;
  int t;
  T = getint();

  for (t = 0; t < T; t = t + 1) {
    int n;
    int i;
    int m;

    n = getint();

    for (i = 0; i < n; i = i + 1) {
      A[i] = getint();
      B[i] = A[i];
    }

    heapSortB(n);

    m = 0;
    for (i = 0; i < n; i = i + 1) {
      if (i == 0 || B[i] != B[i - 1]) {
        B[m] = B[i];
        m = m + 1;
      }
    }

    for (i = 0; i < m; i = i + 1) lastpos[i] = -1;
    for (i = 0; i < n; i = i + 1) {
      int id;
      id = lowerBoundB(m, A[i]);
      prevv[i] = lastpos[id];
      lastpos[id] = i;
    }

    for (i = 0; i < m; i = i + 1) lastpos[i] = n;
    for (i = n - 1; i >= 0; i = i - 1) {
      int id2;
      id2 = lowerBoundB(m, A[i]);
      nextv[i] = lastpos[id2];
      lastpos[id2] = i;
    }

    if (checkNonBoring(n) == 1) printf("non-boring\n");
    else printf("boring\n");
  }

  return 0;
}
