/* Description:
 *   UVa1671 History of Languages (scaled-down)
 *   Checks whether two DFAs recognize the same language by searching the
 *   product automaton for a reachable state where final flags differ.
 *
 *   Input format:
 *     Multiple cases, each starts with t (alphabet size). t==0 ends.
 *     Then DFA A, then DFA B:
 *       n
 *       for i=0..n-1:
 *         is_final
 *         t integers: next state index (0..n-1) or -1 for dead
 *
 *   Output:
 *     "Case #k: Yes" if equivalent, else "No"
 */

const int MAXN = 80;
const int MAXT = 26;
const int MAXP = MAXN * MAXN;

int t;
int kase;

int nA;
int isFinalA[MAXN];
int nextA[MAXN * MAXT];

int nB;
int isFinalB[MAXN];
int nextB[MAXN * MAXT];

int vis[MAXP];
int stk[MAXP];

int differ01(int a, int b) {
  if (a != b) return 1;
  return 0;
}

void readA(int tt) {
  int i;
  int c;
  nA = getint();
  isFinalA[0] = 0;
  for (c = 0; c < tt; c = c + 1) nextA[c] = 0;
  for (i = 1; i <= nA; i = i + 1) {
    isFinalA[i] = getint();
    for (c = 0; c < tt; c = c + 1) {
      int s;
      s = getint();
      nextA[i * MAXT + c] = s + 1;
    }
  }
}

void readB(int tt) {
  int i;
  int c;
  nB = getint();
  isFinalB[0] = 0;
  for (c = 0; c < tt; c = c + 1) nextB[c] = 0;
  for (i = 1; i <= nB; i = i + 1) {
    isFinalB[i] = getint();
    for (c = 0; c < tt; c = c + 1) {
      int s;
      s = getint();
      nextB[i * MAXT + c] = s + 1;
    }
  }
}

int dfs_mismatch() {
  int top;
  int start;
  int code;
  int s1;
  int s2;
  int i;

  start = 1 * MAXN + 1;
  top = 0;
  stk[top] = start;
  top = top + 1;
  vis[start] = kase;

  for (; top > 0;) {
    top = top - 1;
    code = stk[top];
    s1 = code / MAXN;
    s2 = code - s1 * MAXN;

    if (differ01(isFinalA[s1], isFinalB[s2]) == 1) return 1;

    for (i = 0; i < t; i = i + 1) {
      int na;
      int nb;
      int ncode;
      na = nextA[s1 * MAXT + i];
      nb = nextB[s2 * MAXT + i];
      ncode = na * MAXN + nb;
      if (vis[ncode] != kase) {
        vis[ncode] = kase;
        stk[top] = ncode;
        top = top + 1;
      }
    }
  }

  return 0;
}

int main() {
  int i;
  for (i = 0; i < MAXP; i = i + 1) vis[i] = 0;
  kase = 0;

  for (;;) {
    t = getint();
    if (t == 0) break;
    readA(t);
    readB(t);

    kase = kase + 1;
    printf("Case #%d: ", kase);
    if (dfs_mismatch() == 1) printf("No\n");
    else printf("Yes\n");
  }
  return 0;
}
