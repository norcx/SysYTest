/* Description:
 * Converted from UVa1673 str2int (DAWG/SAM approach) into Strict SysY.
 *
 * Input format (integers, 1 per line):
 *   Repeated testcases:
 *     n
 *     For i in [0..n-1]:
 *       len_i
 *       len_i digits (each 0..9), one per line
 *   A final n=0 terminates input.
 *
 * Output:
 *   One line per testcase: the computed answer modulo 2012.
 */

const int MAXC = 11;       // 0..9 digits and 10 as '$'
const int MOD = 2012;

// Scaled down for SysY memory limits: total concatenated length <= MAXL.
const int MAXL = 2000;
const int MAXNODE = MAXL * 2 + 5;

int nxt[MAXNODE * MAXC];
int fa[MAXNODE];
int nlen[MAXNODE];
int pos[MAXNODE];
int tot;
int root;
int last;

int topo[MAXNODE];
int topocnt[MAXL + 1];
int sumv[MAXNODE];
int cntv[MAXNODE];

int newnode(int L) {
  int id;
  int j;
  id = tot;
  tot = tot + 1;
  nlen[id] = L;
  fa[id] = -1;
  pos[id] = 0;
  for (j = 0; j < MAXC; j = j + 1) {
    nxt[id * MAXC + j] = -1;
  }
  return id;
}

int clonenode(int q) {
  int id;
  int j;
  id = tot;
  tot = tot + 1;
  nlen[id] = nlen[q];
  fa[id] = fa[q];
  pos[id] = pos[q];
  for (j = 0; j < MAXC; j = j + 1) {
    nxt[id * MAXC + j] = nxt[q * MAXC + j];
  }
  return id;
}

void init_dawg() {
  tot = 0;
  root = newnode(0);
  last = root;
  pos[root] = 0;
}

void add_edge(int x, int curlen) {
  int p;
  int np;
  int q;
  int nq;

  p = last;
  np = newnode(nlen[p] + 1);
  pos[np] = curlen;
  last = np;

  for (; p != -1 && nxt[p * MAXC + x] == -1; p = fa[p]) {
    nxt[p * MAXC + x] = np;
  }
  if (p == -1) {
    fa[np] = root;
    return;
  }

  q = nxt[p * MAXC + x];
  if (nlen[q] == nlen[p] + 1) {
    fa[np] = q;
    return;
  }

  nq = clonenode(q);
  nlen[nq] = nlen[p] + 1;
  fa[q] = nq;
  fa[np] = nq;
  for (; p != -1 && nxt[p * MAXC + x] == q; p = fa[p]) {
    nxt[p * MAXC + x] = nq;
  }
}

int main() {
  int n;
  int i;
  int j;
  int k;
  int len;
  int digit;
  int totlen;
  int ans;
  int nodei;
  int L;
  int idx;
  int son;

  for (; ; ) {
    n = getint();
    if (n == 0) {
      break;
    }

    init_dawg();
    totlen = 0;

    for (i = 0; i < n; i = i + 1) {
      len = getint();
      if (i > 0) {
        totlen = totlen + 1;
        add_edge(10, totlen);
      }
      for (j = 0; j < len; j = j + 1) {
        digit = getint();
        totlen = totlen + 1;
        add_edge(digit, totlen);
      }
    }

    for (i = 0; i <= totlen; i = i + 1) {
      topocnt[i] = 0;
    }
    for (i = 0; i < tot; i = i + 1) {
      L = nlen[i];
      topocnt[L] = topocnt[L] + 1;
    }
    for (i = 1; i <= totlen; i = i + 1) {
      topocnt[i] = topocnt[i] + topocnt[i - 1];
    }
    for (i = 0; i < tot; i = i + 1) {
      L = nlen[i];
      topocnt[L] = topocnt[L] - 1;
      topo[topocnt[L]] = i;
    }

    for (i = 0; i < tot; i = i + 1) {
      cntv[i] = 0;
      sumv[i] = 0;
    }
    cntv[root] = 1;
    ans = 0;

    for (idx = 0; idx < tot; idx = idx + 1) {
      nodei = topo[idx];
      for (k = 0; k < 10; k = k + 1) {
        if (idx == 0 && k == 0) {
        } else {
          son = nxt[nodei * MAXC + k];
          if (son != -1) {
            cntv[son] = (cntv[son] + cntv[nodei]) % MOD;
            sumv[son] = (sumv[son] + sumv[nodei] * 10 + cntv[nodei] * k) % MOD;
          }
        }
      }
      ans = (ans + sumv[nodei]) % MOD;
    }

    printf("%d\n", ans);
  }

  return 0;
}
