/* Description:
 *   Convert a mixed (directed/undirected) graph into an Euler circuit if possible.
 *   Input encoding change vs original C++:
 *     For each edge: read u, v, dirFlag (1=Directed, 0=Undirected), all 1-based vertices.
 */

const int INF = 1000000000;
const int MAXN = 110;
const int MAXM = 505;
const int MAXV = 120;
const int FLOW_MAXE = 4000;
const int EULER_MAXE = 600;

int n;
int m;
int U[MAXM];
int V[MAXM];
int directed[MAXM];
int id[MAXM];
int diff[MAXN];

int flow_n;
int flow_head[MAXV];
int flow_from[FLOW_MAXE];
int flow_to[FLOW_MAXE];
int flow_cap[FLOW_MAXE];
int flow_f[FLOW_MAXE];
int flow_next[FLOW_MAXE];
int flow_ecnt;

int bfs_a[MAXV];
int bfs_p[MAXV];
int bfs_q[MAXV];

int e_head[MAXN];
int e_to[EULER_MAXE];
int e_next[EULER_MAXE];
int e_used[EULER_MAXE];
int e_cur[MAXN];
int e_cnt;

int st[EULER_MAXE + MAXN];
int circuit[EULER_MAXE + MAXN];

int min2(int x, int y) {
  if (x < y) return x;
  return y;
}

int flow_rev(int idx) {
  if (idx % 2 == 0) return idx + 1;
  return idx - 1;
}

void flow_init(int nodes) {
  int i;
  flow_n = nodes;
  for (i = 0; i < flow_n; i = i + 1) flow_head[i] = -1;
  flow_ecnt = 0;
}

void flow_add_edge(int from, int to, int cap) {
  flow_from[flow_ecnt] = from;
  flow_to[flow_ecnt] = to;
  flow_cap[flow_ecnt] = cap;
  flow_f[flow_ecnt] = 0;
  flow_next[flow_ecnt] = flow_head[from];
  flow_head[from] = flow_ecnt;
  flow_ecnt = flow_ecnt + 1;

  flow_from[flow_ecnt] = to;
  flow_to[flow_ecnt] = from;
  flow_cap[flow_ecnt] = 0;
  flow_f[flow_ecnt] = 0;
  flow_next[flow_ecnt] = flow_head[to];
  flow_head[to] = flow_ecnt;
  flow_ecnt = flow_ecnt + 1;
}

int maxflow(int s, int t) {
  int total;
  int iter;
  total = 0;
  for (iter = 0; iter < 1000000; iter = iter + 1) {
    int i;
    int front;
    int back;

    for (i = 0; i < flow_n; i = i + 1) {
      bfs_a[i] = 0;
      bfs_p[i] = -1;
    }

    front = 0;
    back = 0;
    bfs_q[back] = s;
    back = back + 1;
    bfs_a[s] = INF;

    for (; front < back && bfs_a[t] == 0; front = front + 1) {
      int x;
      int e;
      x = bfs_q[front];
      for (e = flow_head[x]; e != -1 && bfs_a[t] == 0; e = flow_next[e]) {
        int y;
        y = flow_to[e];
        if (bfs_a[y] == 0 && flow_cap[e] > flow_f[e]) {
          int residual;
          bfs_p[y] = e;
          residual = flow_cap[e] - flow_f[e];
          bfs_a[y] = min2(bfs_a[x], residual);
          bfs_q[back] = y;
          back = back + 1;
        }
      }
    }

    if (bfs_a[t] == 0) break;

    {
      int u;
      u = t;
      for (; u != s; ) {
        int e;
        int r;
        e = bfs_p[u];
        flow_f[e] = flow_f[e] + bfs_a[t];
        r = flow_rev(e);
        flow_f[r] = flow_f[r] - bfs_a[t];
        u = flow_from[e];
      }
    }

    total = total + bfs_a[t];
  }
  return total;
}

void euler_add(int from, int to) {
  e_to[e_cnt] = to;
  e_next[e_cnt] = e_head[from];
  e_head[from] = e_cnt;
  e_used[e_cnt] = 0;
  e_cnt = e_cnt + 1;
}

void print_answer() {
  int i;

  for (i = 0; i < n; i = i + 1) e_head[i] = -1;
  e_cnt = 0;

  for (i = 0; i < m; i = i + 1) {
    int rev;
    int from;
    int to;
    rev = 0;
    if (directed[i] == 0 && flow_f[id[i]] > 0) rev = 1;
    if (rev == 0) {
      from = U[i];
      to = V[i];
    } else {
      from = V[i];
      to = U[i];
    }
    euler_add(from, to);
  }

  for (i = 0; i < n; i = i + 1) e_cur[i] = e_head[i];

  {
    int top;
    int clen;
    top = 0;
    clen = 0;
    st[top] = 0;
    top = top + 1;

    for (; top > 0; ) {
      int v;
      int e;
      v = st[top - 1];
      e = e_cur[v];
      for (; e != -1 && e_used[e] != 0; ) {
        e = e_next[e];
        e_cur[v] = e;
      }
      if (e == -1) {
        top = top - 1;
        circuit[clen] = v;
        clen = clen + 1;
      } else {
        e_used[e] = 1;
        e_cur[v] = e_next[e];
        st[top] = e_to[e];
        top = top + 1;
      }
    }

    printf("%d", circuit[clen - 1] + 1);
    for (i = clen - 2; i >= 0; i = i - 1) printf(" %d", circuit[i] + 1);
    printf("\n");
  }
}

int main() {
  int T;
  int case_i;

  T = getint();
  for (case_i = 0; case_i < T; case_i = case_i + 1) {
    int i;
    int ok;
    int s;
    int t;

    n = getint();
    m = getint();

    flow_init(n + 2);

    for (i = 0; i < n; i = i + 1) diff[i] = 0;

    for (i = 0; i < m; i = i + 1) {
      int uu;
      int vv;
      int dirFlag;

      uu = getint();
      vv = getint();
      dirFlag = getint();

      uu = uu - 1;
      vv = vv - 1;

      U[i] = uu;
      V[i] = vv;
      directed[i] = dirFlag;

      diff[uu] = diff[uu] + 1;
      diff[vv] = diff[vv] - 1;

      if (directed[i] == 0) {
        id[i] = flow_ecnt;
        flow_add_edge(uu, vv, 1);
      } else {
        id[i] = 0;
      }
    }

    ok = 1;
    for (i = 0; i < n; i = i + 1) {
      if (diff[i] % 2 != 0) {
        ok = 0;
        break;
      }
    }

    s = n;
    t = n + 1;
    if (ok != 0) {
      int sum;
      sum = 0;
      for (i = 0; i < n; i = i + 1) {
        if (diff[i] > 0) {
          flow_add_edge(s, i, diff[i] / 2);
          sum = sum + diff[i] / 2;
        }
        if (diff[i] < 0) flow_add_edge(i, t, (0 - diff[i]) / 2);
      }
      if (maxflow(s, t) != sum) ok = 0;
    }

    if (ok == 0) printf("No euler circuit exist\n");
    else print_answer();

    if (case_i != T - 1) printf("\n");
  }
  return 0;
}
