/* Description:
 *   SysY testcase converted from UVa 1395 "Slim Span".
 *   Computes the minimum possible (max edge - min edge) among all spanning trees,
 *   or -1 if the graph is disconnected.
 */

int n;
int m;

int pa[110];
int eu[5000];
int ev[5000];
int ed[5000];

int findset(int x) {
  if (pa[x] != x) pa[x] = findset(pa[x]);
  return pa[x];
}

void sort_edges() {
  int i;
  int j;
  for (i = 0; i < m; i = i + 1) {
    int best;
    best = i;
    for (j = i + 1; j < m; j = j + 1) {
      if (ed[j] < ed[best]) best = j;
    }
    if (best != i) {
      int tu;
      int tv;
      int td;
      tu = eu[i];
      tv = ev[i];
      td = ed[i];
      eu[i] = eu[best];
      ev[i] = ev[best];
      ed[i] = ed[best];
      eu[best] = tu;
      ev[best] = tv;
      ed[best] = td;
    }
  }
  return;
}

int solve() {
  int INF;
  int ans;
  int L;
  int R;
  int i;
  INF = 1000000000;
  ans = INF;

  sort_edges();

  for (L = 0; L < m; L = L + 1) {
    for (i = 1; i <= n; i = i + 1) pa[i] = i;
    int cnt;
    cnt = n;
    for (R = L; R < m; R = R + 1) {
      int u;
      int v;
      u = findset(eu[R]);
      v = findset(ev[R]);
      if (u != v) {
        pa[u] = v;
        cnt = cnt - 1;
        if (cnt == 1) {
          int tmp;
          tmp = ed[R] - ed[L];
          if (tmp < ans) ans = tmp;
          break;
        }
      }
    }
  }

  if (ans == INF) ans = -1;
  return ans;
}

int main() {
  for (;;) {
    int i;
    int u;
    int v;
    int d;
    n = getint();
    m = getint();
    if (n == 0) break;

    for (i = 0; i < m; i = i + 1) {
      u = getint();
      v = getint();
      d = getint();
      eu[i] = u;
      ev[i] = v;
      ed[i] = d;
    }

    printf("%d\n", solve());
  }
  return 0;
}
