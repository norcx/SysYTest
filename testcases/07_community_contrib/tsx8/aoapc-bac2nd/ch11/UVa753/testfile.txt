/* Description:
 *   Converted from UVa753 "A Plug for UNIX" (Edmonds-Karp + Floyd).
 *
 * Input mapping (strict SysY, integers only):
 *   T
 *   repeat T times:
 *     n
 *     n lines: socket_type
 *     m
 *     m lines: (device_id, device_plug_type)   // device_id is ignored
 *     k
 *     k lines: (from_type, to_type)            // converters
 *
 * Notes:
 * - Plug/socket types must be small non-negative integers < MAXV.
 * - This conversion follows the original logic strictly (no implicit type->same-type edge).
 */

const int MAXV = 70;
const int MAXNM = 70;
const int MAXE = 20000;
const int INF = 1000000000;

int d[MAXV * MAXV];
int target[MAXNM];
int device[MAXNM];

int head[MAXV + 2];
int edge_from[MAXE];
int edge_to[MAXE];
int edge_cap[MAXE];
int edge_flow[MAXE];
int edge_next[MAXE];
int edge_cnt;
int node_n;

int a[MAXV + 2];
int p_edge[MAXV + 2];
int q[MAXV + 2];

int min2(int x, int y) {
  if (x < y) return x;
  return y;
}

int d_index(int i, int j) {
  return i * MAXV + j;
}

int get_d(int i, int j) {
  return d[d_index(i, j)];
}

void set_d(int i, int j, int v) {
  d[d_index(i, j)] = v;
}

void clear_d() {
  int i;
  for (i = 0; i < MAXV * MAXV; i = i + 1) d[i] = 0;
}

void graph_init(int n) {
  int i;
  node_n = n;
  edge_cnt = 0;
  for (i = 0; i < n; i = i + 1) head[i] = -1;
}

void add_edge(int u, int v, int cap) {
  edge_from[edge_cnt] = u;
  edge_to[edge_cnt] = v;
  edge_cap[edge_cnt] = cap;
  edge_flow[edge_cnt] = 0;
  edge_next[edge_cnt] = head[u];
  head[u] = edge_cnt;
  edge_cnt = edge_cnt + 1;

  edge_from[edge_cnt] = v;
  edge_to[edge_cnt] = u;
  edge_cap[edge_cnt] = 0;
  edge_flow[edge_cnt] = 0;
  edge_next[edge_cnt] = head[v];
  head[v] = edge_cnt;
  edge_cnt = edge_cnt + 1;
}

int bfs(int s, int t) {
  int i;
  int qh;
  int qt;
  int x;
  int e;
  int to;
  int residual;
  int found;

  for (i = 0; i < node_n; i = i + 1) a[i] = 0;

  qh = 0;
  qt = 0;
  q[qt] = s;
  qt = qt + 1;
  a[s] = INF;
  found = 0;

  for (qh = 0; qh < qt && found == 0; qh = qh + 1) {
    x = q[qh];
    for (e = head[x]; e != -1; e = edge_next[e]) {
      to = edge_to[e];
      if (a[to] == 0) {
        if (edge_cap[e] > edge_flow[e]) {
          p_edge[to] = e;
          residual = edge_cap[e] - edge_flow[e];
          a[to] = min2(a[x], residual);
          q[qt] = to;
          qt = qt + 1;
          if (to == t) {
            found = 1;
          }
        }
      }
    }
  }

  return a[t];
}

int maxflow(int s, int t) {
  int flow;
  int aug;
  int u;
  int e;
  int rev;
  int cont;

  flow = 0;
  for (cont = 1; cont == 1; cont = cont) {
    aug = bfs(s, t);
    if (aug == 0) break;

    for (u = t; u != s; u = edge_from[p_edge[u]]) {
      e = p_edge[u];
      edge_flow[e] = edge_flow[e] + aug;
      rev = e + 1;
      if (e % 2 == 1) rev = e - 1;
      edge_flow[rev] = edge_flow[rev] - aug;
    }
    flow = flow + aug;
  }
  return flow;
}

int main() {
  int T;
  int case_i;
  int n;
  int m;
  int k;
  int i;
  int j;
  int u;
  int v;
  int t;
  int dummy;
  int type_max;
  int V;
  int source;
  int sink;
  int r;

  T = getint();
  for (case_i = 0; case_i < T; case_i = case_i + 1) {
    n = getint();
    type_max = -1;
    for (i = 0; i < n; i = i + 1) {
      t = getint();
      target[i] = t;
      if (t > type_max) type_max = t;
    }

    m = getint();
    for (i = 0; i < m; i = i + 1) {
      dummy = getint();
      t = getint();
      device[i] = t;
      if (t > type_max) type_max = t;
    }

    k = getint();
    clear_d();
    for (i = 0; i < k; i = i + 1) {
      u = getint();
      v = getint();
      if (u > type_max) type_max = u;
      if (v > type_max) type_max = v;
      set_d(u, v, 1);
    }

    V = type_max + 1;

    for (t = 0; t < V; t = t + 1)
      for (i = 0; i < V; i = i + 1)
        for (j = 0; j < V; j = j + 1)
          if (get_d(i, j) == 0)
            if (get_d(i, t) == 1)
              if (get_d(t, j) == 1) set_d(i, j, 1);

    source = V;
    sink = V + 1;
    graph_init(V + 2);

    for (i = 0; i < m; i = i + 1) add_edge(source, device[i], 1);
    for (i = 0; i < n; i = i + 1) add_edge(target[i], sink, 1);

    for (i = 0; i < m; i = i + 1)
      for (j = 0; j < n; j = j + 1)
        if (get_d(device[i], target[j]) == 1) add_edge(device[i], target[j], INF);

    r = maxflow(source, sink);
    printf("%d\n", m - r);
    if (case_i != T - 1) printf("\n");
  }
  return 0;
}
