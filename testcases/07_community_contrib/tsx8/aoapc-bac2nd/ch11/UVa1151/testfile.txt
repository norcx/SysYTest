/*
  UVa 1151 - Buy or Build
  Strict SysY solution (scaled for small tests).
*/

const int MAXN = 50;
const int MAXQ = 8;
const int MAXSUB = 400;
const int MAXE = 1300;

int n;
int q;
int x[MAXN];
int y[MAXN];
int cost[MAXQ];

int subStart[MAXQ];
int subLen[MAXQ];
int subData[MAXSUB];

int eu[MAXE];
int ev[MAXE];
int ed[MAXE];
int m;

int pa[MAXN];

int findset(int a) {
  for (; pa[a] != a; ) {
    pa[a] = pa[pa[a]];
    a = pa[a];
  }
  return a;
}

void sort_edges() {
  int i;
  int j;
  int minIdx;
  int tu;
  int tv;
  int td;
  for (i = 0; i < m; i = i + 1) {
    minIdx = i;
    for (j = i + 1; j < m; j = j + 1) {
      if (ed[j] < ed[minIdx]) {
        minIdx = j;
      }
    }
    if (minIdx != i) {
      tu = eu[i];
      tv = ev[i];
      td = ed[i];
      eu[i] = eu[minIdx];
      ev[i] = ev[minIdx];
      ed[i] = ed[minIdx];
      eu[minIdx] = tu;
      ev[minIdx] = tv;
      ed[minIdx] = td;
    }
  }
}

int mst_with_current_dsu(int cnt) {
  int ans;
  int i;
  int u;
  int v;
  ans = 0;
  for (i = 0; i < m && cnt > 1; i = i + 1) {
    u = findset(eu[i]);
    v = findset(ev[i]);
    if (u != v) {
      pa[u] = v;
      ans = ans + ed[i];
      cnt = cnt - 1;
    }
  }
  return ans;
}

int main() {
  int T;
  int tc;
  int i;
  int j;
  int k;
  int dx;
  int dy;
  int cnt;
  int u;
  int subPos;
  int limit;
  int mask;
  int pow2[MAXQ];
  int best;
  int total;
  int base;
  int ru;
  int rb;

  T = getint();
  for (tc = 0; tc < T; tc = tc + 1) {
    n = getint();
    q = getint();

    subPos = 0;
    for (i = 0; i < q; i = i + 1) {
      subLen[i] = getint();
      cost[i] = getint();
      subStart[i] = subPos;
      for (j = 0; j < subLen[i]; j = j + 1) {
        u = getint();
        u = u - 1;
        subData[subPos] = u;
        subPos = subPos + 1;
      }
    }

    for (i = 0; i < n; i = i + 1) {
      x[i] = getint();
      y[i] = getint();
    }

    m = 0;
    for (i = 0; i < n; i = i + 1) {
      for (j = i + 1; j < n; j = j + 1) {
        dx = x[i] - x[j];
        dy = y[i] - y[j];
        eu[m] = i;
        ev[m] = j;
        ed[m] = dx * dx + dy * dy;
        m = m + 1;
      }
    }
    sort_edges();

    pow2[0] = 1;
    for (i = 1; i < q; i = i + 1) {
      pow2[i] = pow2[i - 1] * 2;
    }
    limit = 1;
    for (i = 0; i < q; i = i + 1) {
      limit = limit * 2;
    }

    best = 1000000000;
    for (mask = 0; mask < limit; mask = mask + 1) {
      for (i = 0; i < n; i = i + 1) {
        pa[i] = i;
      }
      cnt = n;
      total = 0;

      for (i = 0; i < q; i = i + 1) {
        if (mask / pow2[i] % 2 == 1) {
          total = total + cost[i];
          base = subData[subStart[i]];
          for (j = 1; j < subLen[i]; j = j + 1) {
            u = subData[subStart[i] + j];
            ru = findset(u);
            rb = findset(base);
            if (ru != rb) {
              pa[ru] = rb;
              cnt = cnt - 1;
            }
          }
        }
      }

      total = total + mst_with_current_dsu(cnt);
      if (total < best) {
        best = total;
      }
    }

    printf("%d\n", best);
    if (tc != T - 1) {
      printf("\n");
    }
  }
  return 0;
}
