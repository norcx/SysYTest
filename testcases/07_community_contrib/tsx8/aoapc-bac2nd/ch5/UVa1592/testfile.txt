/*
  UVa1592 Database (converted to Strict SysY)

  Original input is CSV strings. Strict SysY only supports `getint()`, so this testcase
  uses the equivalent integer form:
    - For each dataset: read `n`, `m`, then `n*m` integers (table cells, already-IDed).
    - Dataset terminator: `n == 0` (explicitly included in `in.txt`).

  Output matches the original:
    - "YES" if no duplicate pair exists for any column pair
    - Otherwise:
        NO
        r1 r2
        c1 c2
*/

const int MAXR = 80;
const int MAXC = 12;
const int HSZ = 4096;

int n;
int m;
int db[MAXR * MAXC];

int tag;
int vis[HSZ];
int key1[HSZ];
int key2[HSZ];
int val[HSZ];

int hash_pair(int a, int b) {
    int h;
    h = a * 10007 + b;
    h = h % HSZ;
    if (h < 0) h = h + HSZ;
    return h;
}

int find_conflict() {
    int c1;
    int c2;
    int i;
    int a;
    int b;
    int pos;
    int rprev;
    int h;
    int probe;

    for (c1 = 0; c1 < m; c1 = c1 + 1) {
        for (c2 = c1 + 1; c2 < m; c2 = c2 + 1) {
            tag = tag + 1;
            for (i = 0; i < n; i = i + 1) {
                a = db[i * MAXC + c1];
                b = db[i * MAXC + c2];
                h = hash_pair(a, b);
                pos = h;
                for (probe = 0; probe < HSZ; probe = probe + 1) {
                    if (vis[pos] == tag && key1[pos] != a || vis[pos] == tag && key2[pos] != b) {
                        pos = pos + 1;
                        if (pos == HSZ) pos = 0;
                    } else {
                        break;
                    }
                }
                if (vis[pos] == tag && key1[pos] == a && key2[pos] == b) {
                    rprev = val[pos];
                    printf("NO\n");
                    printf("%d %d\n", rprev + 1, i + 1);
                    printf("%d %d\n", c1 + 1, c2 + 1);
                    return 0;
                }
                vis[pos] = tag;
                key1[pos] = a;
                key2[pos] = b;
                val[pos] = i;
            }
        }
    }

    printf("YES\n");
    return 0;
}

int main() {
    int i;
    int j;

    tag = 0;
    for (;;) {
        n = getint();
        if (n == 0) break;
        m = getint();

        for (i = 0; i < n; i = i + 1) {
            for (j = 0; j < m; j = j + 1) {
                db[i * MAXC + j] = getint();
            }
        }

        find_conflict();
    }

    return 0;
}
