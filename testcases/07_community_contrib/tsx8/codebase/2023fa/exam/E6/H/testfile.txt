/* Description:
 *   Converted from `codes/2023fa/exam/E6/H.c`.
 *   Original uses `double` + `log10` to binary-search the inverse of f(x)=x*log10(x).
 *   Strict SysY has `int` only, so this uses a fixed-point approximation:
 *     log10(x) ~= (digits(x)-2) + log10(leading_2_digits(x))
 *   where log10(10..99) is a small lookup table scaled by 1000.
 *
 *   Scale-down note: original MAXX=255431605 is reduced to 255431 to keep `int`
 *   intermediates within 32-bit when using fixed-point scaling.
 */

const int MAXX = 255431;

/* round(log10(m) * 1000) for m in [10, 99], index by m */
const int LOG10_10_99[100] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1000, 1041, 1079, 1114, 1146, 1176, 1204, 1230, 1255, 1279,
    1301, 1322, 1342, 1362, 1380, 1398, 1415, 1431, 1447, 1462,
    1477, 1491, 1505, 1519, 1531, 1544, 1556, 1568, 1580, 1591,
    1602, 1613, 1623, 1633, 1643, 1653, 1663, 1672, 1681, 1690,
    1699, 1708, 1716, 1724, 1732, 1740, 1748, 1756, 1763, 1771,
    1778, 1785, 1792, 1799, 1806, 1813, 1820, 1826, 1833, 1839,
    1845, 1851, 1857, 1863, 1869, 1875, 1881, 1886, 1892, 1898,
    1903, 1908, 1914, 1919, 1924, 1929, 1934, 1940, 1944, 1949,
    1954, 1959, 1964, 1968, 1973, 1978, 1982, 1987, 1991, 1996
};

int pow10(int e) {
    int p = 1;
    int i = 0;
    for (i = 0; i < e; i = i + 1) {
        p = p * 10;
    }
    return p;
}

/* Approximate log10(x) * 1000 (fixed-point, scale=1000) */
int log10_times1000(int x) {
    int k = 0;
    int t = x;
    int i = 0;
    if (x < 10) return 0;
    for (i = 0; t >= 10; i = i + 1) {
        t = t / 10;
        k = k + 1;
    }
    /* k = digits(x)-1, so divisor=10^(k-1) to get leading 2 digits */
    int divisor = pow10(k - 1);
    int m = x / divisor;
    if (m < 10) m = 10;
    if (m > 99) m = 99;
    return (k - 1) * 1000 + LOG10_10_99[m];
}

/* Approximate f(x) = x * log10(x), scaled by 1000 */
int f_times1000(int x) {
    int lg = log10_times1000(x);
    return x * lg;
}

int main() {
    int n = getint(); /* n is scaled by 1000 */
    int l = 1;
    int r = MAXX;
    int m = (l + r) / 2;

    for (; l <= r;) {
        int res = f_times1000(m);
        if (res > n) r = m - 1;
        else if (res < n) l = m + 1;
        else {
            l = m;
            break;
        }
        m = (l + r) / 2;
    }

    printf("%d\n", m);
    return 0;
}
