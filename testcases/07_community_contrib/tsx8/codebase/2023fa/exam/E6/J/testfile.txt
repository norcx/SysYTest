/* Description:
 *   Converted from codes/2023fa/exam/E6/J.c into Strict SysY.
 *
 *   Original behavior:
 *     Read n and an array a[0..n-1], output the inversion count:
 *       #{ (i, j) | 0 <= i < j < n, a[i] > a[j] }.
 *
 *   Notes for strict SysY:
 *     - Uses getint() for input (one integer per line in in.txt).
 *     - Uses int-only arithmetic, so we keep n small enough that the
 *       inversion count fits in 32-bit signed int.
 */

int num[600];
int L[600];
int R[600];
int ans;

void Merge(int l, int mid, int r) {
    int n1;
    int n2;
    int i;
    int j;
    int k;
    int m;

    n1 = mid - l + 1;
    n2 = r - mid;

    for (i = 0; i < n1; i = i + 1) {
        L[i] = num[l + i];
    }
    for (i = 0; i < n2; i = i + 1) {
        R[i] = num[mid + 1 + i];
    }

    m = 0;
    for (i = 0; i < n2; i = i + 1) {
        for (; m < n1 && L[m] <= R[i]; m = m + 1) {
        }
        ans = ans + (n1 - m);
    }

    i = 0;
    j = 0;
    k = l;
    for (; i < n1 && j < n2;) {
        if (L[i] < R[j]) {
            num[k] = L[i];
            i = i + 1;
        } else {
            num[k] = R[j];
            j = j + 1;
        }
        k = k + 1;
    }
    for (; i < n1; i = i + 1) {
        num[k] = L[i];
        k = k + 1;
    }
    for (; j < n2; j = j + 1) {
        num[k] = R[j];
        k = k + 1;
    }
    return;
}

void Merge_Sort(int l, int r) {
    if (l < r) {
        int mid;
        mid = (l + r) / 2;
        Merge_Sort(l, mid);
        Merge_Sort(mid + 1, r);
        Merge(l, mid, r);
    }
    return;
}

int main() {
    int n;
    int i;

    n = getint();
    for (i = 0; i < n; i = i + 1) {
        num[i] = getint();
    }

    ans = 0;
    if (n > 0) {
        Merge_Sort(0, n - 1);
    }
    printf("%d\n", ans);
    return 0;
}
