/* Description:
 *   Circular list allocation simulation (array-based).
 */

const int MAXN = 64;

int pos[MAXN];
int lenv[MAXN];
int nxt[MAXN];
int pre[MAXN];

void deleteNode(int idx) {
    int a;
    int b;
    a = pre[idx];
    b = nxt[idx];
    nxt[a] = b;
    pre[b] = a;
}

int main() {
    int cnt;
    int i;
    int last;
    int P;
    int ask;
    int p;
    int found;
    int first;

    cnt = getint();

    nxt[0] = 0;
    pre[0] = 0;
    last = 0;

    for (i = 1; i <= cnt; i = i + 1) {
        pos[i] = getint();
        lenv[i] = getint();
        pre[i] = last;
        nxt[i] = 0;
        nxt[last] = i;
        last = i;
    }
    nxt[last] = 0;
    pre[0] = last;

    P = nxt[0];

    for (;;) {
        ask = getint();
        if (ask == -1) {
            break;
        }

        p = P;
        found = 0;
        first = 1;
        for (;;) {
            if (first == 0 && p == P) {
                break;
            }
            first = 0;

            if (p == 0) {
                p = nxt[p];
            } else {
                if (lenv[p] >= ask) {
                    found = 1;
                    break;
                }
                p = nxt[p];
            }
        }

        if (found == 1) {
            if (lenv[p] == ask) {
                P = nxt[p];
                deleteNode(p);
            } else {
                P = p;
                lenv[p] = lenv[p] - ask;
            }
        }
    }

    p = P;
    first = 1;
    for (;;) {
        if (first == 0 && p == P) {
            break;
        }
        first = 0;

        if (p == 0) {
            p = nxt[p];
        } else {
            printf("%d %d\n", pos[p], lenv[p]);
            p = nxt[p];
        }
    }
    return 0;
}
