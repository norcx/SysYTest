/* Description:
 *   Enumerate all simple paths from node 0 to node n-1 in an undirected graph,
 *   then sort the path edge-weights lexicographically and print them.
 *
 *   Strict SysY notes:
 *   - Only `int`/`void`, 1D arrays, `for` loops, `getint()` input, `printf` output.
 *   - Constants are scaled down to keep total memory well under 4MB.
 */

const int MAXN = 50;
const int MAXM = 60;
const int MAXE = 200;
const int MAXPATHS = 200;
const int MAXLEN = 50;

int n, m;
int head[MAXN];
int to[MAXE];
int ew[MAXE];
int nxt[MAXE];
int ecnt;

int vis[MAXN];
int curPath[MAXLEN];

int pathsStore[MAXPATHS * MAXLEN];
int pathLen[MAXPATHS];
int tot;

void addEdge(int u, int v, int w) {
    ecnt = ecnt + 1;
    to[ecnt] = v;
    ew[ecnt] = w;
    nxt[ecnt] = head[u];
    head[u] = ecnt;
}

void storePath(int dep) {
    int i;
    if (tot >= MAXPATHS) return;
    pathLen[tot] = dep;
    for (i = 0; i < dep; i = i + 1) {
        pathsStore[tot * MAXLEN + i] = curPath[i];
    }
    tot = tot + 1;
}

void dfs(int s, int dep) {
    int ei;
    int v;
    if (s >= n - 1) {
        storePath(dep);
        return;
    }
    vis[s] = 1;
    for (ei = head[s]; ei != 0; ei = nxt[ei]) {
        v = to[ei];
        if (vis[v] == 0) {
            curPath[dep] = ew[ei];
            dfs(v, dep + 1);
        }
    }
    vis[s] = 0;
}

int pathLess(int ia, int ib) {
    int la;
    int lb;
    int mn;
    int k;
    int va;
    int vb;
    la = pathLen[ia];
    lb = pathLen[ib];
    mn = la;
    if (lb < mn) mn = lb;
    for (k = 0; k < mn; k = k + 1) {
        va = pathsStore[ia * MAXLEN + k];
        vb = pathsStore[ib * MAXLEN + k];
        if (va < vb) return 1;
        if (va > vb) return 0;
    }
    if (la < lb) return 1;
    return 0;
}

int main() {
    int i;
    int u;
    int v;
    int w;
    int idx[MAXPATHS];
    int j;
    int minPos;
    int tmp;
    int k;
    int id;

    n = getint();
    m = getint();
    ecnt = 0;
    tot = 0;

    for (i = 0; i < MAXN; i = i + 1) head[i] = 0;
    for (i = 0; i < MAXN; i = i + 1) vis[i] = 0;

    for (i = 0; i < m; i = i + 1) {
        w = getint();
        u = getint();
        v = getint();
        addEdge(u, v, w);
        addEdge(v, u, w);
    }

    dfs(0, 0);

    for (i = 0; i < tot; i = i + 1) idx[i] = i;

    for (i = 0; i < tot; i = i + 1) {
        minPos = i;
        for (j = i + 1; j < tot; j = j + 1) {
            if (pathLess(idx[j], idx[minPos]) == 1) {
                minPos = j;
            }
        }
        tmp = idx[i];
        idx[i] = idx[minPos];
        idx[minPos] = tmp;
    }

    for (i = 0; i < tot; i = i + 1) {
        id = idx[i];
        for (k = 0; k < pathLen[id]; k = k + 1) {
            printf("%d ", pathsStore[id * MAXLEN + k]);
        }
        printf("\n");
    }

    return 0;
}
