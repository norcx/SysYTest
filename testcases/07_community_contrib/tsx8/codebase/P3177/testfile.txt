/* Tree DP testcase derived from Luogu P3177: maximize painting scores
 * n <= 5, k <= 3 so flattened DP slots can stay tiny. Input format:
 * n, k, then n-1 triples (u, v, w). Only printf produces output.
 */
int nodes_total = 0;
int k_total = 0;
int dp[96];
int sz[8];
int head[8];
int edge_to[24];
int edge_w[24];
int edge_next[24];
int edge_cnt = 1;

int idx(int node, int pick) {
    return node * 8 + pick;
}

void reset_all() {
    int i = 0;
    for (i = 0; i < 96; i = i + 1) {
        dp[i] = -1;
    }
    for (i = 0; i < 8; i = i + 1) {
        sz[i] = 0;
        head[i] = 0;
    }
    edge_cnt = 1;
}

void add_edge_once(int u, int v, int w) {
    edge_to[edge_cnt] = v;
    edge_w[edge_cnt] = w;
    edge_next[edge_cnt] = head[u];
    head[u] = edge_cnt;
    edge_cnt = edge_cnt + 1;
}

void dfs(int u, int parent) {
    sz[u] = 1;
    int base = idx(u, 0);
    dp[base] = 0;
    dp[base + 1] = 0;
    int walker = head[u];
    for (walker = head[u]; walker != 0; walker = edge_next[walker]) {
        int v = edge_to[walker];
        if (v == parent) {
            continue;
        }
        dfs(v, u);
        int current_size = sz[u];
        int child_size = sz[v];
        int outer = current_size;
        for (outer = current_size; outer >= 0; outer = outer - 1) {
            int inner = child_size;
            for (inner = child_size; inner >= 0; inner = inner - 1) {
                int val_u = dp[idx(u, outer)];
                int val_v = dp[idx(v, inner)];
                if (val_u >= 0 && val_v >= 0) {
                    int selected_child = inner;
                    int weight = edge_w[walker];
                    int term_a = selected_child * (k_total - selected_child) * weight;
                    int leftover = child_size - selected_child;
                    int mix = nodes_total - k_total + selected_child - child_size;
                    int term_b = leftover * mix * weight;
                    int candidate = val_u + val_v + term_a + term_b;
                    int sum = outer + inner;
                    int at = idx(u, sum);
                    if (dp[at] < candidate) {
                        dp[at] = candidate;
                    }
                }
            }
        }
        sz[u] = sz[u] + child_size;
    }
}

int main() {
    nodes_total = getint();
    k_total = getint();
    reset_all();
    int total_edges = nodes_total - 1;
    int i = 0;
    for (i = 0; i < total_edges; i = i + 1) {
        int u = getint();
        int v = getint();
        int w = getint();
        add_edge_once(u, v, w);
        add_edge_once(v, u, w);
    }
    dfs(1, 0);
    int answer_index = idx(1, k_total);
    printf("%d\n", dp[answer_index]);
    return 0;
}
