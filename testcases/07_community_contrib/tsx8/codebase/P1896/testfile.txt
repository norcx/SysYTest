/* Description:
 *   Luogu P1896 [SCOI2005] 互不侵犯 (scaled-down)
 *   Counts ways to place k kings on an n*n board so that no two attack.
 */

const int MAXN = 10;
const int MAXE = 100;
const int MAXK = 20;

int pow2[MAXN];
int state[MAXE];
int king_cnt[MAXE];
int bits[MAXE * MAXN];

int dp_prev[MAXE * (MAXK + 1)];
int dp_cur[MAXE * (MAXK + 1)];

int get_bit(int mask, int pos) {
    return (mask / pow2[pos]) % 2;
}

int compatible(int a, int b, int n) {
    int col;
    int abit;
    if (a == b) {
        col = 0;
        for (col = 0; col < n; col = col + 1) {
            abit = bits[a * MAXN + col];
            if (abit == 0) continue;
            if (col > 0 && bits[a * MAXN + (col - 1)] == 1) return 0;
            if (col + 1 < n && bits[a * MAXN + (col + 1)] == 1) return 0;
        }
    }
    for (col = 0; col < n; col = col + 1) {
        abit = bits[a * MAXN + col];
        if (abit == 0) continue;
        if (bits[b * MAXN + col] == 1) return 0;
        if (col > 0 && bits[b * MAXN + (col - 1)] == 1) return 0;
        if (col + 1 < n && bits[b * MAXN + (col + 1)] == 1) return 0;
    }
    return 1;
}

int main() {
    int n;
    int k;
    int i;
    int row;
    int mask;
    int tmp;
    int last;
    int cnt;
    int pos;
    int e;
    int j;
    int kk;
    int s;
    int res;
    int limit;
    int idx;

    pow2[0] = 1;
    for (i = 1; i < MAXN; i = i + 1) pow2[i] = pow2[i - 1] * 2;

    n = getint();
    k = getint();
    if (n < 1) n = 1;
    if (n >= MAXN) n = MAXN - 1;
    if (k < 0) k = 0;
    if (k > MAXK) k = MAXK;

    for (i = 0; i < MAXE * (MAXK + 1); i = i + 1) {
        dp_prev[i] = 0;
        dp_cur[i] = 0;
    }

    e = 0;
    limit = pow2[n];
    for (mask = 0; mask < limit; mask = mask + 1) {
        tmp = mask;
        last = 0;
        cnt = 0;
        for (pos = 0; pos < n; pos = pos + 1) {
            i = tmp % 2;
            tmp = tmp / 2;
            if (i == 1 && last == 1) {
                cnt = -1;
                break;
            }
            cnt = cnt + i;
            last = i;
        }
        if (cnt < 0) continue;
        if (cnt > k) continue;
        state[e] = mask;
        king_cnt[e] = cnt;
        for (pos = 0; pos < n; pos = pos + 1) {
            bits[e * MAXN + pos] = get_bit(mask, pos);
        }
        e = e + 1;
    }

    for (idx = 0; idx < e; idx = idx + 1) {
        dp_prev[idx * (MAXK + 1) + king_cnt[idx]] = 1;
    }

    for (row = 2; row <= n; row = row + 1) {
        for (i = 0; i < MAXE * (MAXK + 1); i = i + 1) dp_cur[i] = 0;
        for (j = 0; j < e; j = j + 1) {
            for (kk = 0; kk < e; kk = kk + 1) {
                if (compatible(j, kk, n) == 0) continue;
                for (s = king_cnt[j]; s <= k; s = s + 1) {
                    dp_cur[j * (MAXK + 1) + s] =
                        dp_cur[j * (MAXK + 1) + s] +
                        dp_prev[kk * (MAXK + 1) + (s - king_cnt[j])];
                }
            }
        }
        for (i = 0; i < MAXE * (MAXK + 1); i = i + 1) dp_prev[i] = dp_cur[i];
    }

    res = 0;
    for (idx = 0; idx < e; idx = idx + 1) res = res + dp_prev[idx * (MAXK + 1) + k];
    printf("%d\n", res);
    return 0;
}
