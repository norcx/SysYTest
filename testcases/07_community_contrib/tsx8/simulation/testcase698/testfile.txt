/* Description:
 * Segment range transformations on 2D integer points.
 *
 * Original C++ uses floating-point (angle/length + trig). For Strict SysY:
 * - Represent each point as integer (x, y).
 * - Support only integer translations and rotations by multiples of 90 degrees.
 * - Support reflections across X/Y axis and swap (x, y).
 *
 * Input format (all integers, one per line):
 * n
 * x1 y1 x2 y2 ... xn yn
 * m
 * For each operation:
 *   op l r [params...]
 * op:
 *   1: M (translate)       params: dx dy
 *   2: X (reflect X-axis)  params: none
 *   3: Y (reflect Y-axis)  params: none
 *   4: O (swap x,y)        params: none
 *   5: R (rotate CCW)      params: deg (must be 0/90/180/270)
 *
 * Output:
 * n lines: "x y"
 */

const int MAXN = 64;
const int MAXM = MAXN * 4 + 10;

int px[MAXN + 5];
int py[MAXN + 5];

/* Pending affine transform for each segment:
 * [x']   [a11 a12] [x]   [bx]
 * [y'] = [a21 a22] [y] + [by]
 */
int a11[MAXM];
int a12[MAXM];
int a21[MAXM];
int a22[MAXM];
int bx[MAXM];
int by[MAXM];

void build(int o, int l, int r) {
    a11[o] = 1;
    a12[o] = 0;
    a21[o] = 0;
    a22[o] = 1;
    bx[o] = 0;
    by[o] = 0;
    if (l == r) return;
    int mid;
    mid = (l + r) / 2;
    build(o * 2, l, mid);
    build(o * 2 + 1, mid + 1, r);
    return;
}

void apply_tag(int o, int na11, int na12, int na21, int na22, int nbx, int nby) {
    int oa11;
    int oa12;
    int oa21;
    int oa22;
    int obx;
    int oby;

    oa11 = a11[o];
    oa12 = a12[o];
    oa21 = a21[o];
    oa22 = a22[o];
    obx = bx[o];
    oby = by[o];

    a11[o] = na11 * oa11 + na12 * oa21;
    a12[o] = na11 * oa12 + na12 * oa22;
    a21[o] = na21 * oa11 + na22 * oa21;
    a22[o] = na21 * oa12 + na22 * oa22;
    bx[o] = na11 * obx + na12 * oby + nbx;
    by[o] = na21 * obx + na22 * oby + nby;
    return;
}

void push_down(int o) {
    if (a11[o] == 1 && a12[o] == 0 && a21[o] == 0 && a22[o] == 1 && bx[o] == 0 && by[o] == 0)
        return;
    apply_tag(o * 2, a11[o], a12[o], a21[o], a22[o], bx[o], by[o]);
    apply_tag(o * 2 + 1, a11[o], a12[o], a21[o], a22[o], bx[o], by[o]);
    a11[o] = 1;
    a12[o] = 0;
    a21[o] = 0;
    a22[o] = 1;
    bx[o] = 0;
    by[o] = 0;
    return;
}

void range_apply(int o, int l, int r, int ql, int qr, int na11, int na12, int na21, int na22, int nbx, int nby) {
    if (ql <= l && r <= qr) {
        apply_tag(o, na11, na12, na21, na22, nbx, nby);
        return;
    }
    push_down(o);
    int mid;
    mid = (l + r) / 2;
    if (ql <= mid) range_apply(o * 2, l, mid, ql, qr, na11, na12, na21, na22, nbx, nby);
    if (qr > mid) range_apply(o * 2 + 1, mid + 1, r, ql, qr, na11, na12, na21, na22, nbx, nby);
    return;
}

void finalize(int o, int l, int r) {
    if (l == r) {
        int x;
        int y;
        int nx;
        int ny;
        x = px[l];
        y = py[l];
        nx = a11[o] * x + a12[o] * y + bx[o];
        ny = a21[o] * x + a22[o] * y + by[o];
        px[l] = nx;
        py[l] = ny;
        return;
    }
    push_down(o);
    int mid;
    mid = (l + r) / 2;
    finalize(o * 2, l, mid);
    finalize(o * 2 + 1, mid + 1, r);
    return;
}

int main() {
    int n;
    int m;
    int i;

    n = getint();
    i = 1;
    for (i = 1; i <= n; i = i + 1) {
        px[i] = getint();
        py[i] = getint();
    }

    build(1, 1, n);

    m = getint();
    i = 0;
    for (i = 0; i < m; i = i + 1) {
        int op;
        int l;
        int r;
        op = getint();
        l = getint();
        r = getint();

        if (op == 1) {
            int dx;
            int dy;
            dx = getint();
            dy = getint();
            range_apply(1, 1, n, l, r, 1, 0, 0, 1, dx, dy);
        }
        if (op == 2) {
            range_apply(1, 1, n, l, r, 1, 0, 0, -1, 0, 0);
        }
        if (op == 3) {
            range_apply(1, 1, n, l, r, -1, 0, 0, 1, 0, 0);
        }
        if (op == 4) {
            range_apply(1, 1, n, l, r, 0, 1, 1, 0, 0, 0);
        }
        if (op == 5) {
            int deg;
            int k;
            deg = getint();
            k = deg / 90;
            k = k % 4;
            if (k == 0) range_apply(1, 1, n, l, r, 1, 0, 0, 1, 0, 0);
            if (k == 1) range_apply(1, 1, n, l, r, 0, -1, 1, 0, 0, 0);
            if (k == 2) range_apply(1, 1, n, l, r, -1, 0, 0, -1, 0, 0);
            if (k == 3) range_apply(1, 1, n, l, r, 0, 1, -1, 0, 0, 0);
        }
    }

    finalize(1, 1, n);

    i = 1;
    for (i = 1; i <= n; i = i + 1) {
        printf("%d %d\n", px[i], py[i]);
    }
    return 0;
}
