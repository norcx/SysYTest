/* Description:
 * Converted from a C++ "warchess" simulator to Strict SysY.
 *
 * Input format (all integers, one per line):
 * n, m, C, E
 * g matrix: n*m integers (row-major)
 * C pieces: hp at mv ad1 ad2 x y gr
 * E events:
 *   op=1: set current group      -> read now_gr
 *   op=2: select piece           -> read id
 *   op=3: move selected piece    -> read tx, ty
 *   op=4: attack (type 't')      -> read target_id
 *   op=5: destroy (type 'D')     -> read target_id
 */

const int MAXN = 105;

int n, m, C, E;

int g[11025];
int bo[11025];
int vis[11025];
int dis[11025];

int qx[50000];
int qy[50000];

int dx[5] = {0, 1, 0, -1, 0};
int dy[5] = {0, 0, 1, 0, -1};

int p_hp[110];
int p_at[110];
int p_mv[110];
int p_ad1[110];
int p_ad2[110];
int p_x[110];
int p_y[110];
int p_gr[110];
int p_die[110];

int now_hp, now_at, now_mv, now_ad1, now_ad2, now_x, now_y, now_piece_gr, now_die;
int now_gr, now_id;

int idx(int x, int y) {
    return x * MAXN + y;
}

int iabs(int x) {
    if (x < 0) return 0 - x;
    return x;
}

void select_piece(int id) {
    now_id = id;
    now_hp = p_hp[id];
    now_at = p_at[id];
    now_mv = p_mv[id];
    now_ad1 = p_ad1[id];
    now_ad2 = p_ad2[id];
    now_x = p_x[id];
    now_y = p_y[id];
    now_piece_gr = p_gr[id];
    now_die = p_die[id];
}

int judge_0(int x, int y) {
    int i;
    int enemy_gr;
    enemy_gr = 1 - now_gr;
    for (i = 1; i <= 4; i = i + 1) {
        int nx, ny;
        nx = x + dx[i];
        ny = y + dy[i];
        if (nx < 1 || ny < 1 || nx > n || ny > m) continue;
        if (bo[idx(nx, ny)] == enemy_gr) return 1;
    }
    return 0;
}

int move_to(int tx, int ty) {
    int i, j;
    int head, tail;
    int start;

    for (i = 1; i <= n; i = i + 1) {
        for (j = 1; j <= m; j = j + 1) {
            int id;
            id = idx(i, j);
            dis[id] = -1;
            vis[id] = 0;
        }
    }

    start = idx(now_x, now_y);
    dis[start] = now_mv;
    vis[start] = 1;

    head = 0;
    tail = 0;
    qx[tail] = now_x;
    qy[tail] = now_y;
    tail = tail + 1;

    for (head = 0; head < tail; head = head + 1) {
        int cx, cy;
        int dir;
        cx = qx[head];
        cy = qy[head];
        vis[idx(cx, cy)] = 0;

        for (dir = 1; dir <= 4; dir = dir + 1) {
            int nx, ny;
            int nid;
            int mv;
            nx = cx + dx[dir];
            ny = cy + dy[dir];
            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
            nid = idx(nx, ny);

            mv = dis[idx(cx, cy)] - g[nid];
            if (mv < 0) continue;
            if (bo[nid] != -1) continue;

            if (judge_0(nx, ny) != 0) {
                mv = 0;
                if (dis[nid] == -1 || dis[nid] < mv) dis[nid] = mv;
                continue;
            }

            if (dis[nid] == -1 || dis[nid] < mv) {
                dis[nid] = mv;
                if (vis[nid] == 0) {
                    vis[nid] = 1;
                    qx[tail] = nx;
                    qy[tail] = ny;
                    tail = tail + 1;
                }
            }
        }
    }

    {
        int ok;
        ok = 0;
        if (dis[idx(tx, ty)] != -1) ok = 1;
        return ok;
    }

    return 0;
}

int main() {
    int i, j;

    n = getint();
    m = getint();
    C = getint();
    E = getint();

    for (i = 1; i <= n; i = i + 1) {
        for (j = 1; j <= m; j = j + 1) {
            int id;
            id = idx(i, j);
            g[id] = getint();
            bo[id] = -1;
        }
    }

    for (i = 1; i <= C; i = i + 1) {
        p_hp[i] = getint();
        p_at[i] = getint();
        p_mv[i] = getint();
        p_ad1[i] = getint();
        p_ad2[i] = getint();
        p_x[i] = getint();
        p_y[i] = getint();
        p_gr[i] = getint();
        p_die[i] = 0;
        bo[idx(p_x[i], p_y[i])] = p_gr[i];
    }

    now_gr = 0;
    now_id = 0;
    now_hp = 0;
    now_at = 0;
    now_mv = 0;
    now_ad1 = 0;
    now_ad2 = 0;
    now_x = 0;
    now_y = 0;
    now_piece_gr = 0;
    now_die = 0;

    for (i = 1; i <= E; i = i + 1) {
        int op;
        op = getint();

        if (op == 1) {
            now_gr = getint();
            continue;
        }

        if (op == 2) {
            int id;
            id = getint();
            select_piece(id);
            continue;
        }

        if (op == 3) {
            int tx, ty;
            tx = getint();
            ty = getint();

            if (now_die != 0) {
                printf("INVALID\n");
                continue;
            }

            if (move_to(tx, ty) != 0) {
                printf("%d\n", dis[idx(tx, ty)]);
                bo[idx(now_x, now_y)] = -1;
                bo[idx(tx, ty)] = now_piece_gr;
                now_x = tx;
                now_y = ty;
                p_x[now_id] = tx;
                p_y[now_id] = ty;
            } else {
                printf("INVALID\n");
            }
            continue;
        }

        if (op == 4) {
            int tid;
            int dist;
            tid = getint();

            if (p_die[tid] != 0) {
                printf("INVALID\n");
                continue;
            }
            if (now_piece_gr == p_gr[tid]) {
                printf("INVALID\n");
                continue;
            }

            dist = iabs(now_x - p_x[tid]) + iabs(now_y - p_y[tid]);
            if (dist < now_ad1 || dist > now_ad2) {
                printf("INVALID\n");
                continue;
            }

            p_hp[tid] = p_hp[tid] - now_at;
            if (p_hp[tid] <= 0) {
                bo[idx(p_x[tid], p_y[tid])] = -1;
                p_die[tid] = 1;
                printf("INVALID\n");
            } else {
                printf("%d\n", p_hp[tid]);
            }
            continue;
        }

        if (op == 5) {
            int tid;
            int dist;
            tid = getint();

            if (p_die[tid] != 0) {
                printf("INVALID\n");
                continue;
            }
            if (now_piece_gr == p_gr[tid]) {
                printf("INVALID\n");
                continue;
            }

            dist = iabs(now_x - p_x[tid]) + iabs(now_y - p_y[tid]);
            if (dist < now_ad1 || dist > now_ad2) {
                printf("INVALID\n");
                continue;
            }

            p_hp[tid] = p_hp[tid] - now_at;
            if (p_hp[tid] <= 0) {
                bo[idx(p_x[tid], p_y[tid])] = -1;
                p_die[tid] = 1;
                printf("%d\n", p_hp[tid]);
            } else {
                printf("INVALID\n");
            }
            continue;
        }
    }

    return 0;
}
