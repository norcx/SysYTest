/* Description:
 *   SysY translation of the given C++ program.
 *   Computes the original-rank-th smallest value of:
 *     {a_i + y} union {b_i - y}
 *   where a_i are elements with type 1 and b_i are elements with type != 1.
 */

const int MAXN = 6000;

int n;
int m;

int a[MAXN];
int b[MAXN];
int ha_x[MAXN];
int ha_id[MAXN];
int id[MAXN];

int found_1_r(int now) {
    int l;
    int r;
    int mid;
    int tmp;
    l = 1;
    r = a[0];
    tmp = 0;
    for (; l <= r; ) {
        mid = (l + r) / 2;
        if (a[mid] <= now) {
            tmp = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return tmp;
}

int found_1_l(int now) {
    int l;
    int r;
    int mid;
    int tmp;
    l = 1;
    r = a[0];
    tmp = 0;
    for (; l <= r; ) {
        mid = (l + r) / 2;
        if (a[mid] < now) {
            tmp = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return tmp;
}

int found_2_r(int now) {
    int l;
    int r;
    int mid;
    int tmp;
    l = 1;
    r = b[0];
    tmp = 0;
    for (; l <= r; ) {
        mid = (l + r) / 2;
        if (b[mid] <= now) {
            tmp = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return tmp;
}

int found_2_l(int now) {
    int l;
    int r;
    int mid;
    int tmp;
    l = 1;
    r = b[0];
    tmp = 0;
    for (; l <= r; ) {
        mid = (l + r) / 2;
        if (b[mid] < now) {
            tmp = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return tmp;
}

void sort_int(int arr[], int len) {
    int i;
    for (i = 2; i <= len; i = i + 1) {
        int key;
        int j;
        key = arr[i];
        j = i - 1;
        for (; j >= 1 && arr[j] > key; ) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
    return;
}

void sort_pairs(int xarr[], int idarr[], int len) {
    int i;
    for (i = 2; i <= len; i = i + 1) {
        int keyx;
        int keyid;
        int j;
        keyx = xarr[i];
        keyid = idarr[i];
        j = i - 1;
        for (; j >= 1 && xarr[j] > keyx; ) {
            xarr[j + 1] = xarr[j];
            idarr[j + 1] = idarr[j];
            j = j - 1;
        }
        xarr[j + 1] = keyx;
        idarr[j + 1] = keyid;
    }
    return;
}

void get_ans(int x, int y) {
    int ans;
    int found;
    int l;
    int r;
    int mid;
    ans = 0;
    found = 0;
    l = 1;
    r = a[0];
    for (; l <= r; ) {
        int tmp_r;
        int tmp_l;
        mid = (l + r) / 2;
        tmp_r = mid + found_2_r(a[mid] + y * 2);
        if (tmp_r == x) {
            ans = a[mid] + y;
            found = 1;
            break;
        }
        tmp_l = mid + found_2_l(a[mid] + y * 2);
        if (tmp_l <= x && x <= tmp_r) {
            ans = a[mid] + y;
            found = 1;
            break;
        }
        if (tmp_l > x) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }

    if (found == 0) {
        l = 1;
        r = b[0];
        for (; l <= r; ) {
            int tmp_l2;
            int tmp_r2;
            mid = (l + r) / 2;
            tmp_l2 = mid + found_1_l(b[mid] - y * 2);
            if (tmp_l2 == x) {
                ans = b[mid] - y;
                found = 1;
                break;
            }
            tmp_r2 = mid + found_1_r(b[mid] - y * 2);
            if (tmp_l2 <= x && x <= tmp_r2) {
                ans = b[mid] - y;
                found = 1;
                break;
            }
            if (tmp_l2 > x) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
    }

    printf("%d\n", ans);
    return;
}

int main() {
    int i;
    int x;

    a[0] = 0;
    b[0] = 0;

    n = getint();
    for (i = 1; i <= n; i = i + 1) {
        x = getint();
        ha_x[i] = x;
        ha_id[i] = i;
    }
    for (i = 1; i <= n; i = i + 1) {
        x = getint();
        if (x == 1) {
            a[0] = a[0] + 1;
            a[a[0]] = ha_x[i];
        } else {
            b[0] = b[0] + 1;
            b[b[0]] = ha_x[i];
        }
    }

    sort_int(a, a[0]);
    sort_int(b, b[0]);
    sort_pairs(ha_x, ha_id, n);

    for (i = 1; i <= n; i = i + 1) {
        id[ha_id[i]] = i;
    }

    m = getint();
    for (i = 1; i <= m; i = i + 1) {
        int qx;
        int y;
        int idx;
        int rank;
        qx = getint();
        y = getint();
        idx = qx + 1;
        rank = id[idx];
        get_ans(rank, y);
    }
    return 0;
}
