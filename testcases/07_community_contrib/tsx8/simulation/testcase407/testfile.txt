const int MAXQ = 2000;

int qStates[MAXQ * 36];
int qStep[MAXQ];
int qHead;
int qTail;

int visKey[MAXQ];
int visStates[MAXQ * 36];
int visCnt;

int locks[9];

int curColors[36];
int visNode[36];
int bo[5];

void copy36(int dst[], int src[]) {
  int i;
  for (i = 0; i < 36; i = i + 1) {
    dst[i] = src[i];
  }
}

int getKey(int st[]) {
  int i;
  int key;
  key = 0;
  for (i = 0; i < 36; i = i + 1) {
    key = key * 233 + st[i];
  }
  return key;
}

int alreadyVisited(int key, int st[]) {
  int i;
  int j;
  int same;
  for (i = 0; i < visCnt; i = i + 1) {
    if (visKey[i] == key) {
      same = 1;
      for (j = 0; j < 36; j = j + 1) {
        if (visStates[i * 36 + j] != st[j]) {
          same = 0;
        }
      }
      if (same != 0) {
        return 1;
      }
    }
  }
  return 0;
}

void markVisited(int key, int st[]) {
  int i;
  int off;
  visKey[visCnt] = key;
  off = visCnt * 36;
  for (i = 0; i < 36; i = i + 1) {
    visStates[off + i] = st[i];
  }
  visCnt = visCnt + 1;
}

void enqueue(int st[], int step) {
  int i;
  int off;
  off = qTail * 36;
  for (i = 0; i < 36; i = i + 1) {
    qStates[off + i] = st[i];
  }
  qStep[qTail] = step;
  qTail = qTail + 1;
}

void applyRowRight(int st[], int row) {
  int c0;
  int c1;
  int c2;
  int s;
  int tmp;
  c0 = row * 3;
  c1 = c0 + 1;
  c2 = c0 + 2;
  for (s = 0; s < 4; s = s + 1) {
    tmp = st[c2 * 4 + s];
    st[c2 * 4 + s] = st[c1 * 4 + s];
    st[c1 * 4 + s] = st[c0 * 4 + s];
    st[c0 * 4 + s] = tmp;
  }
}

void applyRowLeft(int st[], int row) {
  int c0;
  int c1;
  int c2;
  int s;
  int tmp;
  c0 = row * 3;
  c1 = c0 + 1;
  c2 = c0 + 2;
  for (s = 0; s < 4; s = s + 1) {
    tmp = st[c0 * 4 + s];
    st[c0 * 4 + s] = st[c1 * 4 + s];
    st[c1 * 4 + s] = st[c2 * 4 + s];
    st[c2 * 4 + s] = tmp;
  }
}

void applyColDown(int st[], int col) {
  int c0;
  int c1;
  int c2;
  int s;
  int tmp;
  c0 = col;
  c1 = col + 3;
  c2 = col + 6;
  for (s = 0; s < 4; s = s + 1) {
    tmp = st[c2 * 4 + s];
    st[c2 * 4 + s] = st[c1 * 4 + s];
    st[c1 * 4 + s] = st[c0 * 4 + s];
    st[c0 * 4 + s] = tmp;
  }
}

void applyColUp(int st[], int col) {
  int c0;
  int c1;
  int c2;
  int s;
  int tmp;
  c0 = col;
  c1 = col + 3;
  c2 = col + 6;
  for (s = 0; s < 4; s = s + 1) {
    tmp = st[c0 * 4 + s];
    st[c0 * 4 + s] = st[c1 * 4 + s];
    st[c1 * 4 + s] = st[c2 * 4 + s];
    st[c2 * 4 + s] = tmp;
  }
}

void dfs(int cell, int side) {
  int idx;
  int col;
  idx = cell * 4 + side;
  visNode[idx] = 1;
  col = curColors[idx];

  if (side == 0 || side == 1) {
    if (visNode[cell * 4 + 2] == 0 && curColors[cell * 4 + 2] == col) {
      dfs(cell, 2);
    }
    if (visNode[cell * 4 + 3] == 0 && curColors[cell * 4 + 3] == col) {
      dfs(cell, 3);
    }
  }

  if (side == 2 || side == 3) {
    if (visNode[cell * 4 + 0] == 0 && curColors[cell * 4 + 0] == col) {
      dfs(cell, 0);
    }
    if (visNode[cell * 4 + 1] == 0 && curColors[cell * 4 + 1] == col) {
      dfs(cell, 1);
    }
  }

  if (side == 0 && cell >= 3) {
    if (visNode[(cell - 3) * 4 + 1] == 0 && curColors[(cell - 3) * 4 + 1] == col) {
      dfs(cell - 3, 1);
    }
  }

  if (side == 1 && cell <= 5) {
    if (visNode[(cell + 3) * 4 + 0] == 0 && curColors[(cell + 3) * 4 + 0] == col) {
      dfs(cell + 3, 0);
    }
  }

  if (side == 2 && cell % 3 != 0) {
    if (visNode[(cell - 1) * 4 + 3] == 0 && curColors[(cell - 1) * 4 + 3] == col) {
      dfs(cell - 1, 3);
    }
  }

  if (side == 3 && cell % 3 != 2) {
    if (visNode[(cell + 1) * 4 + 2] == 0 && curColors[(cell + 1) * 4 + 2] == col) {
      dfs(cell + 1, 2);
    }
  }
}

int judge(int st[]) {
  int i;
  int j;
  int color;
  for (i = 0; i < 36; i = i + 1) {
    curColors[i] = st[i];
    visNode[i] = 0;
  }
  for (i = 0; i < 5; i = i + 1) {
    bo[i] = 0;
  }

  for (i = 0; i < 9; i = i + 1) {
    for (j = 0; j < 4; j = j + 1) {
      if (visNode[i * 4 + j] == 0) {
        color = curColors[i * 4 + j];
        if (bo[color] != 0) {
          return 0;
        }
        bo[color] = 1;
        dfs(i, j);
      }
    }
  }
  return 1;
}

void tryPush(int st[], int nowStep) {
  int key;
  key = getKey(st);
  if (alreadyVisited(key, st) == 0) {
    if (visCnt < MAXQ && qTail < MAXQ) {
      markVisited(key, st);
      enqueue(st, nowStep + 1);
    }
  }
}

int main() {
  int initState[36];
  int tmpState[36];
  int i;
  int j;
  int k;
  int lockv;
  int nowStep;
  int off;
  int row;
  int col;
  int blocked;

  for (i = 0; i < 9; i = i + 1) {
    for (k = 0; k < 4; k = k + 1) {
      initState[i * 4 + k] = getint();
    }
    lockv = getint();
    locks[i] = lockv;
  }

  qHead = 0;
  qTail = 0;
  visCnt = 0;
  enqueue(initState, 0);

  for (qHead = 0; qHead < qTail; qHead = qHead + 1) {
    off = qHead * 36;
    for (i = 0; i < 36; i = i + 1) {
      tmpState[i] = qStates[off + i];
    }
    nowStep = qStep[qHead];

    if (judge(tmpState) != 0) {
      printf("%d\n", nowStep - 1);
      return 0;
    }

    for (row = 0; row < 3; row = row + 1) {
      blocked = 0;
      for (col = 0; col < 3; col = col + 1) {
        if (locks[row * 3 + col] == 1) {
          blocked = 1;
        }
      }
      if (blocked == 0) {
        for (i = 0; i < 36; i = i + 1) {
          tmpState[i] = qStates[off + i];
        }
        applyRowRight(tmpState, row);
        tryPush(tmpState, nowStep);

        applyRowLeft(tmpState, row);
        tryPush(tmpState, nowStep);
      }
    }

    for (col = 0; col < 3; col = col + 1) {
      blocked = 0;
      for (row = 0; row < 3; row = row + 1) {
        if (locks[row * 3 + col] == 1) {
          blocked = 1;
        }
      }
      if (blocked == 0) {
        for (i = 0; i < 36; i = i + 1) {
          tmpState[i] = qStates[off + i];
        }
        applyColDown(tmpState, col);
        tryPush(tmpState, nowStep);

        applyColUp(tmpState, col);
        tryPush(tmpState, nowStep);
      }
    }
  }

  return 0;
}
