/*
  Description:
    DSU-based check + binary search on edge weights.
    Input:
      n, m
      m lines: x, y, z
    Output:
      ans
*/

int n;
int m;
int ans;
int l;
int r;

int fa[40005];
int hx[20005];
int hy[20005];
int hz[20005];

int father(int x) {
    if (fa[x] == x) return x;
    fa[x] = father(fa[x]);
    return fa[x];
}

int judge(int midz) {
    int i;
    int fax;
    int fay;

    for (i = 1; i <= n * 2; i = i + 1) fa[i] = i;
    for (i = 1; i <= m; i = i + 1) {
        if (hz[i] > midz) {
            fax = father(hx[i]);
            fay = father(hy[i]);
            if (fax == fay) return 0;
            fa[fax] = father(hy[i] + n);
            fa[fax] = father(hx[i] + n);
        }
    }
    return 1;
}

void sort_edges() {
    int i;
    int j;
    int tx;
    int ty;
    int tz;

    for (i = 1; i <= m; i = i + 1) {
        for (j = 1; j <= m - i; j = j + 1) {
            if (hz[j] > hz[j + 1]) {
                tx = hx[j];
                ty = hy[j];
                tz = hz[j];
                hx[j] = hx[j + 1];
                hy[j] = hy[j + 1];
                hz[j] = hz[j + 1];
                hx[j + 1] = tx;
                hy[j + 1] = ty;
                hz[j + 1] = tz;
            }
        }
    }
    return;
}

int main() {
    int i;
    int mid;

    n = getint();
    m = getint();
    for (i = 1; i <= m; i = i + 1) {
        hx[i] = getint();
        hy[i] = getint();
        hz[i] = getint();
    }

    sort_edges();

    l = 0;
    r = m;
    for (; l <= r;) {
        mid = (l + r) / 2;
        if (judge(hz[mid])) {
            r = mid - 1;
            ans = hz[mid];
        } else {
            l = mid + 1;
        }
    }

    printf("%d\n", ans);
    return 0;
}
