/* Strict SysY testcase: inversion count under block reversals */
const int MAXN = 11;
const int MAXSUM = 2048;

int a[MAXSUM];
int tmpa[MAXSUM];
int pow2v[MAXN + 1];

int inv_sum[MAXN];
int uneq_sum[MAXN];
int cur_inv[MAXN];

void build_pow2(int n) {
  int i;
  pow2v[0] = 1;
  for (i = 1; i <= n; i = i + 1) {
    pow2v[i] = pow2v[i - 1] * 2;
  }
}

void compute_sums(int n) {
  int level;
  int sum;
  int len;
  int seg;
  int left;
  int mid;
  int right;
  int i;
  int j;
  int k;
  int inv_seg;
  int equal_pairs;
  int val;
  int cntl;
  int cntr;

  sum = pow2v[n];
  for (level = 0; level < n; level = level + 1) {
    inv_sum[level] = 0;
    uneq_sum[level] = 0;

    len = pow2v[level];
    for (seg = 0; seg < sum; seg = seg + len * 2) {
      left = seg;
      mid = seg + len;
      right = seg + len * 2;

      inv_seg = 0;
      equal_pairs = 0;
      i = left;
      j = mid;
      k = left;

      for (;;) {
        if (i >= mid) break;
        if (j >= right) break;

        if (a[i] < a[j]) {
          tmpa[k] = a[i];
          k = k + 1;
          i = i + 1;
        } else if (a[i] > a[j]) {
          tmpa[k] = a[j];
          k = k + 1;
          j = j + 1;
          inv_seg = inv_seg + (mid - i);
        } else {
          val = a[i];
          cntl = 0;
          for (;;) {
            if (i >= mid) break;
            if (a[i] != val) break;
            tmpa[k] = a[i];
            k = k + 1;
            i = i + 1;
            cntl = cntl + 1;
          }
          cntr = 0;
          for (;;) {
            if (j >= right) break;
            if (a[j] != val) break;
            tmpa[k] = a[j];
            k = k + 1;
            j = j + 1;
            cntr = cntr + 1;
          }
          equal_pairs = equal_pairs + cntl * cntr;
        }
      }

      for (;;) {
        if (i >= mid) break;
        tmpa[k] = a[i];
        k = k + 1;
        i = i + 1;
      }
      for (;;) {
        if (j >= right) break;
        tmpa[k] = a[j];
        k = k + 1;
        j = j + 1;
      }

      inv_sum[level] = inv_sum[level] + inv_seg;
      uneq_sum[level] = uneq_sum[level] + len * len - equal_pairs;

      for (i = left; i < right; i = i + 1) {
        a[i] = tmpa[i];
      }
    }
  }

  for (level = 0; level < n; level = level + 1) {
    cur_inv[level] = inv_sum[level];
  }
}

int total_inversions(int n) {
  int i;
  int s;
  s = 0;
  for (i = 0; i < n; i = i + 1) {
    s = s + cur_inv[i];
  }
  return s;
}

int main() {
  int n;
  int sum;
  int i;
  int T;
  int A;

  n = getint();
  build_pow2(n);
  sum = pow2v[n];

  for (i = 0; i < sum; i = i + 1) {
    a[i] = getint();
  }
  compute_sums(n);

  T = getint();
  for (i = 0; i < T; i = i + 1) {
    A = getint();
    if (A != 0) {
      int lv;
      for (lv = 0; lv < A; lv = lv + 1) {
        cur_inv[lv] = uneq_sum[lv] - cur_inv[lv];
      }
    }
    printf("%d\n", total_inversions(n));
  }
  return 0;
}
