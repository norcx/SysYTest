/* Description:
 *   Count permutations of n with exactly m inversions (Mahonian numbers),
 *   output modulo 10000.
 *
 *   Input:
 *     T
 *     n1
 *     m1
 *     n2
 *     m2
 *     ...
 *
 *   Output:
 *     f[ni][mi] mod 10000, one per line
 */

const int MOD = 10000;
const int MAXT = 1000;
const int MAXM = 20000;

int n_q[MAXT];
int m_q[MAXT];
int idx_q[MAXT];
int ans[MAXT];

int f_prev[20001];
int f_cur[20001];

int main() {
    int T;
    int i;
    int j;
    int max_n;
    int max_m;

    T = getint();

    if (T < 0) T = 0;
    if (T > MAXT) T = MAXT;

    max_n = 1;
    max_m = 0;

    for (i = 0; i < T; i = i + 1) {
        n_q[i] = getint();
        m_q[i] = getint();
        idx_q[i] = i;
        if (n_q[i] > max_n) max_n = n_q[i];
        if (m_q[i] > max_m) max_m = m_q[i];
    }

    if (max_n < 1) max_n = 1;
    if (max_m < 0) max_m = 0;
    if (max_m > MAXM) max_m = MAXM;

    /* sort queries by n ascending (selection sort) */
    for (i = 0; i < T; i = i + 1) {
        int best_pos;
        int best_idx;

        best_pos = i;
        for (j = i + 1; j < T; j = j + 1) {
            if (n_q[idx_q[j]] < n_q[idx_q[best_pos]]) best_pos = j;
        }
        best_idx = idx_q[i];
        idx_q[i] = idx_q[best_pos];
        idx_q[best_pos] = best_idx;
    }

    /* DP base: f[1][0] = 1, others = 0 */
    for (j = 0; j <= max_m; j = j + 1) f_prev[j] = 0;
    f_prev[0] = 1;

    /* answer queries in sorted order while building rows incrementally */
    {
        int current_n;
        int q;

        current_n = 1;
        for (q = 0; q < T; q = q + 1) {
            int qi;
            int target_n;
            int target_m;

            qi = idx_q[q];
            target_n = n_q[qi];
            target_m = m_q[qi];

            if (target_n < 1) target_n = 1;

            for (i = current_n + 1; i <= target_n; i = i + 1) {
                int prefix;
                prefix = 0;
                for (j = 0; j <= max_m; j = j + 1) {
                    prefix = prefix + f_prev[j];
                    prefix = prefix % MOD;
                    if (j >= i) {
                        prefix = prefix - f_prev[j - i];
                        prefix = prefix % MOD;
                        if (prefix < 0) prefix = prefix + MOD;
                    }
                    f_cur[j] = prefix;
                }
                for (j = 0; j <= max_m; j = j + 1) f_prev[j] = f_cur[j];
                current_n = i;
            }

            if (target_m < 0 || target_m > max_m) {
                ans[qi] = 0;
            } else {
                ans[qi] = f_prev[target_m];
            }
        }
    }

    for (i = 0; i < T; i = i + 1) printf("%d\n", ans[i]);
    return 0;
}
