/* Description:
 * Adapted from a C++ DP solution into Strict SysY.
 *
 * Input (one integer per line):
 *   len
 *   n
 *   s[1..len] (0 => 'F', non-zero => 'T')
 *
 * Output:
 *   abs(ans)
 */

const int MAXN = 211;
const int INF = 1061109567;
const int inf = -1044266559;

int n;
int ans;
int len;

int f[MAXN * MAXN * 2];
int g[MAXN * MAXN * 2];
int s[MAXN + 2];

int mymax(int a, int b) {
    if (a > b) return a;
    return b;
}

int mymin(int a, int b) {
    if (a < b) return a;
    return b;
}

int myabs(int x) {
    if (x < 0) return 0 - x;
    return x;
}

int idx(int i, int j, int k) {
    return (i * MAXN + j) * 2 + k;
}

void work(int now, int i, int j, int k) {
    int nk;
    nk = 1 - k;

    if (s[i + 1] == 0) {
        if (k == 1) {
            f[idx(i + 1, j, k)] = mymax(f[idx(i + 1, j, k)], now + 1);
            g[idx(i + 1, j, k)] = mymin(g[idx(i + 1, j, k)], now + 1);
        } else {
            f[idx(i + 1, j, k)] = mymax(f[idx(i + 1, j, k)], now - 1);
            g[idx(i + 1, j, k)] = mymin(g[idx(i + 1, j, k)], now - 1);
        }
        if (j < n) {
            f[idx(i + 1, j + 1, nk)] = mymax(f[idx(i + 1, j + 1, nk)], now);
            g[idx(i + 1, j + 1, nk)] = mymin(g[idx(i + 1, j + 1, nk)], now);
        }
    } else {
        if (j < n) {
            if (k == 1) {
                f[idx(i + 1, j + 1, k)] = mymax(f[idx(i + 1, j + 1, k)], now + 1);
                g[idx(i + 1, j + 1, k)] = mymin(g[idx(i + 1, j + 1, k)], now + 1);
            } else {
                f[idx(i + 1, j + 1, k)] = mymax(f[idx(i + 1, j + 1, k)], now - 1);
                g[idx(i + 1, j + 1, k)] = mymin(g[idx(i + 1, j + 1, k)], now - 1);
            }
        }
        f[idx(i + 1, j, nk)] = mymax(f[idx(i + 1, j, nk)], now);
        g[idx(i + 1, j, nk)] = mymin(g[idx(i + 1, j, nk)], now);
    }
}

void get_ans(int x) {
    int v;
    v = f[idx(len, x, 0)];
    if (v != inf) ans = mymax(ans, myabs(v));
    v = f[idx(len, x, 1)];
    if (v != inf) ans = mymax(ans, myabs(v));
    v = g[idx(len, x, 0)];
    if (v != INF) ans = mymax(ans, myabs(v));
    v = g[idx(len, x, 1)];
    if (v != INF) ans = mymax(ans, myabs(v));
}

int main() {
    int i;
    int j;
    int k;
    int total;

    len = getint();
    n = getint();
    for (i = 1; i <= len; i = i + 1) {
        s[i] = getint();
    }

    total = MAXN * MAXN * 2;
    for (i = 0; i < total; i = i + 1) {
        f[i] = inf;
        g[i] = INF;
    }

    f[idx(0, 0, 1)] = 0;
    g[idx(0, 0, 1)] = 0;

    for (i = 0; i < len; i = i + 1) {
        for (j = 0; j <= n; j = j + 1) {
            for (k = 0; k <= 1; k = k + 1) {
                if (f[idx(i, j, k)] != inf) work(f[idx(i, j, k)], i, j, k);
                if (g[idx(i, j, k)] != INF) work(g[idx(i, j, k)], i, j, k);
            }
        }
    }

    for (i = n; i >= 0; i = i - 2) {
        get_ans(i);
    }

    printf("%d\n", myabs(ans));
    return 0;
}
