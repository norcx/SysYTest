/* Description:
 *   Converted from C++ (segment tree + greedy after sorting by y).
 *   Input:
 *     K, n, m
 *     K lines: x, y, z
 *   Output:
 *     ans
 */

int hx[1024];
int hy[1024];
int hz[1024];

int mx[4096];
int addv[4096];

int max2(int a, int b) {
    if (a > b) return a;
    return b;
}

void swap_triplet(int i, int j) {
    int t;
    t = hx[i]; hx[i] = hx[j]; hx[j] = t;
    t = hy[i]; hy[i] = hy[j]; hy[j] = t;
    t = hz[i]; hz[i] = hz[j]; hz[j] = t;
}

void sort_by_y(int K) {
    int i;
    int j;
    int best;
    for (i = 1; i <= K; i = i + 1) {
        best = i;
        for (j = i + 1; j <= K; j = j + 1) {
            if (hy[j] < hy[best]) best = j;
        }
        if (best != i) swap_triplet(i, best);
    }
}

void push_down(int o) {
    int lch;
    int rch;
    if (addv[o] == 0) return;
    lch = o * 2;
    rch = o * 2 + 1;
    addv[lch] = addv[lch] + addv[o];
    addv[rch] = addv[rch] + addv[o];
    mx[lch] = mx[lch] + addv[o];
    mx[rch] = mx[rch] + addv[o];
    addv[o] = 0;
    return;
}

int query(int l, int r, int o, int x, int y) {
    int mid;
    int tmp;
    int t;
    int lch;
    int rch;
    if (x <= l && r <= y) return mx[o];
    push_down(o);
    mid = (l + r) / 2;
    lch = o * 2;
    rch = o * 2 + 1;
    tmp = 0;
    if (x <= mid) tmp = query(l, mid, lch, x, y);
    if (mid < y) {
        t = query(mid + 1, r, rch, x, y);
        if (t > tmp) tmp = t;
    }
    mx[o] = max2(mx[lch], mx[rch]);
    return tmp;
}

void update(int l, int r, int o, int x, int y, int z) {
    int mid;
    int lch;
    int rch;
    if (x <= l && r <= y) {
        addv[o] = addv[o] + z;
        mx[o] = mx[o] + z;
        return;
    }
    push_down(o);
    mid = (l + r) / 2;
    lch = o * 2;
    rch = o * 2 + 1;
    if (x <= mid) update(l, mid, lch, x, y, z);
    if (mid < y) update(mid + 1, r, rch, x, y, z);
    mx[o] = max2(mx[lch], mx[rch]);
    return;
}

int main() {
    int K;
    int n;
    int m;
    int i;
    int ans;
    int left;
    int right;
    int current;
    int cap;
    int tt;

    K = getint();
    n = getint();
    m = getint();

    for (i = 1; i <= K; i = i + 1) {
        hx[i] = getint();
        hy[i] = getint();
        hz[i] = getint();
        if (hz[i] > m) hz[i] = m;
    }

    sort_by_y(K);

    ans = 0;
    for (i = 1; i <= K; i = i + 1) {
        left = hx[i];
        right = hy[i] - 1;
        if (right < left) {
            tt = 0;
        } else {
            current = query(1, n, 1, left, right);
            cap = m - current;
            if (cap < 0) cap = 0;
            tt = hz[i];
            if (tt > cap) tt = cap;
            ans = ans + tt;
            if (tt != 0) update(1, n, 1, left, right, tt);
        }
    }

    printf("%d\n", ans);
    return 0;
}
