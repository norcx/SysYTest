/*
  Greedy interval filling.
  Input:
    K, n, m
    then K triples (x, y, z)
  Output:
    total filled amount
*/

const int MAXK = 5000;
const int MAXN = 5000;

int K;
int n;
int m;

int x_arr[MAXK + 5];
int y_arr[MAXK + 5];
int z_arr[MAXK + 5];
int s[MAXN + 5];

int main() {
    int i;
    int j;
    int min_idx;
    int tmp;
    int ans;
    int max_seg;
    int cap;
    int add;

    K = getint();
    n = getint();
    m = getint();

    ans = 0;

    for (i = 1; i <= K; i = i + 1) {
        x_arr[i] = getint();
        y_arr[i] = getint();
        z_arr[i] = getint();
        if (z_arr[i] > m) z_arr[i] = m;
    }

    for (i = 1; i <= K; i = i + 1) {
        min_idx = i;
        for (j = i + 1; j <= K; j = j + 1) {
            if (y_arr[j] < y_arr[min_idx]) min_idx = j;
        }
        if (min_idx != i) {
            tmp = x_arr[i];
            x_arr[i] = x_arr[min_idx];
            x_arr[min_idx] = tmp;

            tmp = y_arr[i];
            y_arr[i] = y_arr[min_idx];
            y_arr[min_idx] = tmp;

            tmp = z_arr[i];
            z_arr[i] = z_arr[min_idx];
            z_arr[min_idx] = tmp;
        }
    }

    for (i = 1; i <= K; i = i + 1) {
        max_seg = 0;
        for (j = x_arr[i]; j < y_arr[i]; j = j + 1) {
            if (s[j] > max_seg) max_seg = s[j];
        }

        cap = m - max_seg;
        add = z_arr[i];
        if (add > cap) add = cap;
        if (add < 0) add = 0;

        ans = ans + add;

        for (j = x_arr[i]; j < y_arr[i]; j = j + 1) {
            s[j] = s[j] + add;
        }
    }

    printf("%d\n", ans);
    return 0;
}
