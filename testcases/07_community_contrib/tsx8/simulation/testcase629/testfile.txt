/* Description:
 *   Converted to Strict SysY from a merge-sort inversion counter with queries.
 *   Input format (one integer per line):
 *     n
 *     a[1..2^n]
 *     T
 *     Q_1..Q_T
 *   Output:
 *     For each query, print the total inversion count after applying the swap
 *     operation on levels 1..Q.
 */

const int MAX_N = 5;
const int MAX_SUM = 32;
const int STRIDE = 8;

int a[34];
int b[34];
int rr[34];
int pmap[34];
int pow2[6];

int st[272];
int ST[272];

int t[8];
int tt[8];

void gb(int l, int r) {
    int mid;
    int i;
    int j;
    int o;
    int level;

    if (l == r) {
        return;
    }

    mid = (l + r) / 2;
    gb(l, mid);
    gb(mid + 1, r);

    for (i = l; i <= r; i = i + 1) {
        b[i] = a[i];
    }

    for (i = r; i >= mid; i = i - 1) {
        rr[i] = i;
        if (i != r) {
            if (b[i + 1] == b[i]) {
                rr[i] = rr[i + 1];
            }
        }
    }

    i = l;
    j = mid + 1;
    o = l;
    level = pmap[r - l + 1];

    for (; i <= mid && j <= r; ) {
        if (b[i] <= b[j]) {
            a[o] = b[i];
            o = o + 1;
            if (b[i] == b[j]) {
                ST[l * STRIDE + level] = ST[l * STRIDE + level] + (rr[j] - j + 1);
            }
            i = i + 1;
        } else {
            a[o] = b[j];
            o = o + 1;
            st[l * STRIDE + level] = st[l * STRIDE + level] + (mid - i + 1);
            j = j + 1;
        }
    }

    if (i <= mid) {
        for (j = i; j <= mid; j = j + 1) {
            a[o] = b[j];
            o = o + 1;
        }
    } else {
        if (j <= r) {
            for (i = j; i <= r; i = i + 1) {
                a[o] = b[i];
                o = o + 1;
            }
        }
    }
    return;
}

int main() {
    int n;
    int sum;
    int i;
    int j;
    int T;
    int Q;
    int k;
    int total;
    int ans;

    n = getint();

    pow2[0] = 1;
    for (i = 1; i <= MAX_N; i = i + 1) {
        pow2[i] = pow2[i - 1] * 2;
    }

    sum = pow2[n];
    for (i = 1; i <= sum; i = i + 1) {
        a[i] = getint();
    }

    for (i = 1; i <= MAX_N; i = i + 1) {
        pmap[pow2[i]] = i;
        t[i] = 0;
        tt[i] = 0;
    }

    gb(1, sum);

    T = getint();

    for (i = 1; i <= n; i = i + 1) {
        for (j = 1; j <= sum; j = j + pow2[i]) {
            t[i] = t[i] + st[j * STRIDE + i];
            tt[i] = tt[i] + ST[j * STRIDE + i];
        }
    }

    for (k = 0; k < T; k = k + 1) {
        Q = getint();
        for (i = 1; i <= Q; i = i + 1) {
            total = pow2[i - 1] * pow2[i - 1] * pow2[n - i];
            t[i] = total - tt[i] - t[i];
        }
        ans = 0;
        for (i = 1; i <= n; i = i + 1) {
            ans = ans + t[i];
        }
        printf("%d\n", ans);
    }

    return 0;
}
