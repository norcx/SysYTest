/* Description:
 *   Strict SysY translation of the given C++ BFS puzzle solver.
 *
 * Input format (newline-separated integers; 1 integer per line):
 *   9 blocks (row-major order), each block has 5 integers:
 *     c1 c2 c3 c4 lock
 *   where c1..c4 are colors in {0,1,2,3} and lock in {0,1}.
 *
 * Semantics:
 *   - The 3x3 board consists of 9 tiles; each tile has 4 edge colors.
 *   - Allowed moves are cyclic shifts of an unlocked row or column by 1 step
 *     in either direction. A row/column is locked if ANY tile in that row/col
 *     has lock==1 in the initial input (matches the original program behavior).
 *   - Goal (judge): for each color, all occurrences of that color must be in a
 *     single connected component under the same adjacency rules as the source.
 *
 * Output:
 *   The program prints (minimum_moves - 1), matching the source's now.b - 1.
 */

const int NSTATE = 362880; /* 9! */

int tileColors[36]; /* tile id 0..8, 4 colors each => 9*4 */
int rowLocked[3];
int colLocked[3];

int fact[10];

int visitedDist[NSTATE]; /* 0 = unvisited, else dist+1 */
int q[NSTATE];

int get_color(int perm[], int cell, int side) {
    return tileColors[perm[cell] * 4 + side];
}

void init_fact() {
    int i;
    fact[0] = 1;
    for (i = 1; i <= 9; i = i + 1) {
        fact[i] = fact[i - 1] * i;
    }
}

void unrank_perm(int rank, int perm[]) {
    int avail[9];
    int i;
    int j;
    int base;
    int qv;

    for (i = 0; i < 9; i = i + 1) {
        avail[i] = i;
    }

    for (i = 0; i < 9; i = i + 1) {
        base = fact[8 - i];
        qv = rank / base;
        rank = rank - qv * base;

        perm[i] = avail[qv];
        for (j = qv; j < 8 - i; j = j + 1) {
            avail[j] = avail[j + 1];
        }
    }
}

int rank_perm(int perm[]) {
    int used[9];
    int i;
    int j;
    int cnt;
    int r;

    for (i = 0; i < 9; i = i + 1) {
        used[i] = 0;
    }

    r = 0;
    for (i = 0; i < 9; i = i + 1) {
        cnt = 0;
        for (j = 0; j < perm[i]; j = j + 1) {
            if (used[j] == 0) {
                cnt = cnt + 1;
            }
        }
        r = r + cnt * fact[8 - i];
        used[perm[i]] = 1;
    }
    return r;
}

int judge(int perm[]) {
    int visNode[36];
    int usedColor[4];
    int stack[36];
    int top;
    int idx;
    int loop;

    for (idx = 0; idx < 36; idx = idx + 1) {
        visNode[idx] = 0;
    }
    for (idx = 0; idx < 4; idx = idx + 1) {
        usedColor[idx] = 0;
    }

    for (idx = 0; idx < 36; idx = idx + 1) {
        if (visNode[idx] == 1) {
        } else {
            int cell;
            int side;
            int c;

            cell = idx / 4;
            side = idx - cell * 4;
            c = get_color(perm, cell, side);

            if (usedColor[c] == 1) {
                return 0;
            }
            usedColor[c] = 1;

            top = 0;
            stack[top] = idx;
            top = top + 1;
            visNode[idx] = 1;

            for (loop = 0; top > 0; loop = 0) {
                int cur;
                int curCell;
                int curSide;
                int x;
                int y;

                top = top - 1;
                cur = stack[top];
                curCell = cur / 4;
                curSide = cur - curCell * 4;
                x = curCell / 3;
                y = curCell - x * 3;

                if (curSide == 0 || curSide == 1) {
                    int o1;
                    int o2;
                    int nidx;

                    o1 = 2;
                    o2 = 3;
                    if (get_color(perm, curCell, o1) == c) {
                        nidx = curCell * 4 + o1;
                        if (visNode[nidx] == 0) {
                            visNode[nidx] = 1;
                            stack[top] = nidx;
                            top = top + 1;
                        }
                    }
                    if (get_color(perm, curCell, o2) == c) {
                        nidx = curCell * 4 + o2;
                        if (visNode[nidx] == 0) {
                            visNode[nidx] = 1;
                            stack[top] = nidx;
                            top = top + 1;
                        }
                    }
                } else {
                    int o1;
                    int o2;
                    int nidx;

                    o1 = 0;
                    o2 = 1;
                    if (get_color(perm, curCell, o1) == c) {
                        nidx = curCell * 4 + o1;
                        if (visNode[nidx] == 0) {
                            visNode[nidx] = 1;
                            stack[top] = nidx;
                            top = top + 1;
                        }
                    }
                    if (get_color(perm, curCell, o2) == c) {
                        nidx = curCell * 4 + o2;
                        if (visNode[nidx] == 0) {
                            visNode[nidx] = 1;
                            stack[top] = nidx;
                            top = top + 1;
                        }
                    }
                }

                if (curSide == 0 && x > 0) {
                    int nbCell;
                    int nbIdx;
                    nbCell = (x - 1) * 3 + y;
                    if (get_color(perm, nbCell, 1) == c) {
                        nbIdx = nbCell * 4 + 1;
                        if (visNode[nbIdx] == 0) {
                            visNode[nbIdx] = 1;
                            stack[top] = nbIdx;
                            top = top + 1;
                        }
                    }
                }
                if (curSide == 1 && x < 2) {
                    int nbCell;
                    int nbIdx;
                    nbCell = (x + 1) * 3 + y;
                    if (get_color(perm, nbCell, 0) == c) {
                        nbIdx = nbCell * 4 + 0;
                        if (visNode[nbIdx] == 0) {
                            visNode[nbIdx] = 1;
                            stack[top] = nbIdx;
                            top = top + 1;
                        }
                    }
                }
                if (curSide == 2 && y > 0) {
                    int nbCell;
                    int nbIdx;
                    nbCell = x * 3 + (y - 1);
                    if (get_color(perm, nbCell, 3) == c) {
                        nbIdx = nbCell * 4 + 3;
                        if (visNode[nbIdx] == 0) {
                            visNode[nbIdx] = 1;
                            stack[top] = nbIdx;
                            top = top + 1;
                        }
                    }
                }
                if (curSide == 3 && y < 2) {
                    int nbCell;
                    int nbIdx;
                    nbCell = x * 3 + (y + 1);
                    if (get_color(perm, nbCell, 2) == c) {
                        nbIdx = nbCell * 4 + 2;
                        if (visNode[nbIdx] == 0) {
                            visNode[nbIdx] = 1;
                            stack[top] = nbIdx;
                            top = top + 1;
                        }
                    }
                }
            }
        }
    }
    return 1;
}

void copy_perm(int src[], int dst[]) {
    int i;
    for (i = 0; i < 9; i = i + 1) {
        dst[i] = src[i];
    }
}

void rot_row_right(int perm[], int r) {
    int base;
    int t;
    base = r * 3;
    t = perm[base + 2];
    perm[base + 2] = perm[base + 1];
    perm[base + 1] = perm[base + 0];
    perm[base + 0] = t;
}

void rot_row_left(int perm[], int r) {
    int base;
    int t;
    base = r * 3;
    t = perm[base + 0];
    perm[base + 0] = perm[base + 1];
    perm[base + 1] = perm[base + 2];
    perm[base + 2] = t;
}

void rot_col_down(int perm[], int c) {
    int t;
    t = perm[c + 6];
    perm[c + 6] = perm[c + 3];
    perm[c + 3] = perm[c + 0];
    perm[c + 0] = t;
}

void rot_col_up(int perm[], int c) {
    int t;
    t = perm[c + 0];
    perm[c + 0] = perm[c + 3];
    perm[c + 3] = perm[c + 6];
    perm[c + 6] = t;
}

int main() {
    int i;
    int j;
    int k;
    int lock;

    init_fact();

    for (i = 0; i < 3; i = i + 1) {
        rowLocked[i] = 0;
        colLocked[i] = 0;
    }

    for (i = 0; i < 3; i = i + 1) {
        for (j = 0; j < 3; j = j + 1) {
            for (k = 0; k < 4; k = k + 1) {
                tileColors[(i * 3 + j) * 4 + k] = getint();
            }
            lock = getint();
            if (lock == 1) {
                rowLocked[i] = 1;
                colLocked[j] = 1;
            }
        }
    }

    // for (i = 0; i < NSTATE; i = i + 1) {
    //     visitedDist[i] = 0;
    // }

    /* initial permutation is identity => rank 0 */
    visitedDist[0] = 1; /* dist = 0 */
    q[0] = 0;

    {
        int head;
        int tail;
        int loop;

        head = 0;
        tail = 1;

        for (loop = 0; head < tail; head = head + 1) {
            int curRank;
            int curDist;
            int perm[9];
            int perm2[9];

            curRank = q[head];
            curDist = visitedDist[curRank] - 1;

            unrank_perm(curRank, perm);
            if (judge(perm) == 1) {
                printf("%d\n", curDist - 1);
                return 0;
            }

            for (i = 0; i < 3; i = i + 1) {
                if (rowLocked[i] == 0) {
                    int nr;

                    copy_perm(perm, perm2);
                    rot_row_right(perm2, i);
                    nr = rank_perm(perm2);
                    if (visitedDist[nr] == 0) {
                        visitedDist[nr] = curDist + 2;
                        q[tail] = nr;
                        tail = tail + 1;
                    }

                    copy_perm(perm, perm2);
                    rot_row_left(perm2, i);
                    nr = rank_perm(perm2);
                    if (visitedDist[nr] == 0) {
                        visitedDist[nr] = curDist + 2;
                        q[tail] = nr;
                        tail = tail + 1;
                    }
                }
            }

            for (i = 0; i < 3; i = i + 1) {
                if (colLocked[i] == 0) {
                    int nr;

                    copy_perm(perm, perm2);
                    rot_col_down(perm2, i);
                    nr = rank_perm(perm2);
                    if (visitedDist[nr] == 0) {
                        visitedDist[nr] = curDist + 2;
                        q[tail] = nr;
                        tail = tail + 1;
                    }

                    copy_perm(perm, perm2);
                    rot_col_up(perm2, i);
                    nr = rank_perm(perm2);
                    if (visitedDist[nr] == 0) {
                        visitedDist[nr] = curDist + 2;
                        q[tail] = nr;
                        tail = tail + 1;
                    }
                }
            }
        }
    }

    return 0;
}
