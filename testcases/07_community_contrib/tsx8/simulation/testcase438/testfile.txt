/* Description:
 *   Converted to Strict SysY from a CP-style C++ solution.
 *
 *   Input format (integers, one per line):
 *     T
 *     k
 *     m
 *     p1..pm
 *     For each testcase:
 *       n          (number of digits)
 *       d1..dn     (digits, most-significant first, each 0..9)
 *
 *   Meaning: interpret digits as a base-k number (digits are still 0..9),
 *   then output the result modulo 64123 using matrix exponentiation.
 */

const int MAXN = 111;
const int MAT_SIZE = 12321; /* 111 * 111 */
const int MAXD = 512;
const int MOD = 64123;

int T;
int k;
int m;
int mx_p;

int p[MAXN];
int f[MAXN];

int base[MAT_SIZE];
int ans[MAT_SIZE];
int nowm[MAT_SIZE];
int tm[MAT_SIZE];

int a[MAXD];
int b[MAXD];
int c[MAXD];
int t1[MAXD];

int max2(int x, int y) {
    int res;
    res = y;
    if (x > y) res = x;
    return res;
}

int idx(int r, int col) {
    return r * MAXN + col;
}

void trim_big(int arr[]) {
    int guard;
    for (guard = 0; guard < MAXD; guard = guard + 1) {
        if (arr[0] > 1 && arr[arr[0]] == 0) arr[0] = arr[0] - 1;
        else guard = MAXD;
    }
}

int mul_mod(int x, int y) {
    int res;
    int i;
    int a2;
    int b2;
    res = 0;
    a2 = x % MOD;
    b2 = y % MOD;
    if (a2 < 0) a2 = a2 + MOD;
    if (b2 < 0) b2 = b2 + MOD;
    for (i = 0; i < 20; i = i + 1) {
        if (b2 % 2 == 1) res = (res + a2) % MOD;
        a2 = (a2 + a2) % MOD;
        b2 = b2 / 2;
    }
    return res;
}

int judge() {
    if (c[0] == 1 && c[1] == 0) return 0;
    return 1;
}

void work1() {
    int i;
    int j;
    int kk;
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) tm[idx(i, j)] = 0;
    }
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) {
            for (kk = 1; kk <= mx_p; kk = kk + 1) {
                tm[idx(i, j)] = (tm[idx(i, j)] + mul_mod(ans[idx(i, kk)], nowm[idx(kk, j)])) % MOD;
            }
        }
    }
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) ans[idx(i, j)] = tm[idx(i, j)];
    }
}

void work2() {
    int i;
    int j;
    int kk;
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) tm[idx(i, j)] = 0;
    }
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) {
            for (kk = 1; kk <= mx_p; kk = kk + 1) {
                tm[idx(i, j)] = (tm[idx(i, j)] + mul_mod(nowm[idx(i, kk)], nowm[idx(kk, j)])) % MOD;
            }
        }
    }
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) nowm[idx(i, j)] = tm[idx(i, j)];
    }
}

void work3() {
    int i;
    for (i = c[0]; i >= 1; i = i - 1) {
        if (i > 1) c[i - 1] = c[i - 1] + (c[i] % 2) * 10;
        c[i] = c[i] / 2;
    }
    trim_big(c);
}

void init_num() {
    int i;
    int j;
    int d;
    int n;

    for (i = 0; i < MAXD; i = i + 1) {
        a[i] = 0;
        b[i] = 0;
        c[i] = 0;
        t1[i] = 0;
    }

    n = getint();
    a[0] = n;
    for (i = 1; i <= n; i = i + 1) {
        d = getint();
        a[n - i + 1] = d;
    }

    b[0] = 1;
    b[1] = 1;
    c[0] = 1;
    c[1] = 0;

    for (i = 1; i <= n; i = i + 1) {
        t1[0] = b[0] + 1;
        if (t1[0] >= MAXD) t1[0] = MAXD - 1;
        t1[t1[0]] = 0;

        for (j = 1; j <= b[0]; j = j + 1) t1[j] = b[j] * a[i];
        for (j = 1; j <= b[0]; j = j + 1) {
            t1[j + 1] = t1[j + 1] + t1[j] / 10;
            t1[j] = t1[j] % 10;
        }
        trim_big(t1);

        for (j = 1; j <= t1[0]; j = j + 1) c[j] = c[j] + t1[j];
        for (j = 1; j <= t1[0]; j = j + 1) {
            c[j + 1] = c[j + 1] + c[j] / 10;
            c[j] = c[j] % 10;
        }
        c[0] = max2(t1[0], c[0]) + 2;
        if (c[0] >= MAXD) c[0] = MAXD - 1;
        trim_big(c);

        for (j = 1; j <= b[0]; j = j + 1) b[j] = b[j] * k;
        for (j = 1; j <= b[0]; j = j + 1) {
            b[j + 1] = b[j + 1] + b[j] / 10;
            b[j] = b[j] % 10;
        }
        b[0] = b[0] + 1;
        if (b[0] >= MAXD) b[0] = MAXD - 1;
        trim_big(b);
    }
}

void work() {
    int i;
    int j;
    int tmp;
    int step;
    int an;

    c[1] = c[1] - mx_p - 1;

    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= mx_p; j = j + 1) {
            ans[idx(i, j)] = base[idx(i, j)];
            nowm[idx(i, j)] = base[idx(i, j)];
        }
    }

    for (i = 1; i <= c[0]; i = i + 1) {
        tmp = 0;
        for (j = 0; j < 20; j = j + 1) {
            if (c[i] >= 0) j = 20;
            else {
                c[i] = c[i] + 10;
                tmp = tmp + 1;
            }
        }
        c[i + 1] = c[i + 1] - tmp;
    }
    trim_big(c);

    for (step = 0; step < 1024; step = step + 1) {
        if (judge() == 0) step = 1024;
        else {
            if (c[1] % 2 == 1) work1();
            work2();
            work3();
        }
    }

    an = 0;
    for (i = 1; i <= mx_p; i = i + 1) {
        an = (an + mul_mod(f[i], ans[idx(i, mx_p)])) % MOD;
    }
    printf("%d\n", an);
}

int main() {
    int i;
    int j;
    int tc;
    int tmp;
    int pd;

    T = getint();
    k = getint();
    m = getint();

    mx_p = 0;
    for (i = 1; i <= m; i = i + 1) {
        p[i] = getint();
        if (p[i] > mx_p) mx_p = p[i];
    }

    for (i = 0; i < MAT_SIZE; i = i + 1) base[i] = 0;

    for (i = 0; i <= mx_p; i = i + 1) f[i] = 0;
    f[0] = 1;
    for (i = 1; i <= mx_p; i = i + 1) {
        for (j = 1; j <= m; j = j + 1) {
            if (i - p[j] >= 0) f[i] = (f[i] + f[i - p[j]]) % MOD;
        }
    }

    for (i = 1; i < mx_p; i = i + 1) base[idx(i + 1, i)] = 1;
    for (i = 1; i <= m; i = i + 1) base[idx(mx_p + 1 - p[i], mx_p)] = 1;

    for (tc = 0; tc < T; tc = tc + 1) {
        init_num();
        pd = 0;

        if (c[0] <= 2) {
            tmp = c[1];
            if (c[0] == 2) tmp = tmp + c[2] * 10;
            if (tmp <= mx_p) {
                printf("%d\n", f[tmp] % MOD);
                pd = 1;
            }
        }

        if (pd == 0) work();
    }
    return 0;
}
