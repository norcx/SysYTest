/* Description:
 *   Converted from a C++ solution (survivor) to Strict SysY.
 *   Logic: shortest path on a forward DAG with step limit L and node costs max(0, a[i]-K).
 *   Refactor: replace SPFA + adjacency with O(n*L) DP (DAG relaxation), clamp edges to node n+1.
 *   Scale-down: use small fixed arrays to stay within ~4MB.
 */

const int MAXN = 450;
const int INF = 1000000000;

int a[MAXN + 5];
int dis[MAXN + 5];

int main() {
    int T;
    int tc;
    int B;
    int L;
    int K;
    int n;
    int i;
    int j;
    int to;
    int nd;

    T = getint();
    for (tc = 0; tc < T; tc = tc + 1) {
        B = getint();
        L = getint();
        K = getint();
        n = getint();

        for (i = 1; i <= n; i = i + 1) {
            a[i] = getint();
            a[i] = a[i] - K;
            if (a[i] < 0) a[i] = 0;
        }
        a[0] = 0;
        a[n + 1] = 0;

        for (i = 0; i <= n + 1; i = i + 1) dis[i] = INF;
        dis[0] = 0;

        for (i = 0; i <= n; i = i + 1) {
            if (dis[i] < INF) {
                for (j = 1; j <= L; j = j + 1) {
                    to = i + j;
                    if (to > n + 1) to = n + 1;
                    nd = dis[i] + a[to];
                    if (nd < dis[to]) dis[to] = nd;
                }
            }
        }

        if (dis[n + 1] < B) printf("%d\n", B - dis[n + 1]);
        else printf("-1\n");
    }
    return 0;
}
