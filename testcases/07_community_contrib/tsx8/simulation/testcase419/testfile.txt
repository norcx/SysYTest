/* Description:
 * Converted from C++ (SPFA on a doubled graph) to Strict SysY.
 * Input format:
 *   n, m
 *   p[1..n], w[1..n], s[1..n]
 *   m edges: x, y, z
 * Output:
 *   min(dis[n], dis[2*n])
 */

const int MAXV = 50;   /* supports up to 2*n <= 49 */
const int MAXE = 120;  /* supports up to 2*m <= 119 */
const int QMAX = 400;

int n, m, cnt;
int p[MAXV], w[MAXV], s[MAXV];
int vis[MAXV], dis[MAXV], head[MAXV];
int to[MAXE], val[MAXE], nxt[MAXE];
int q[QMAX], qh, qt;

int abs_int(int x) {
    if (x >= 0) return x;
    return 0 - x;
}

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

void q_push(int x) {
    q[qt] = x;
    qt = qt + 1;
    if (qt == QMAX) qt = 0;
}

int q_pop() {
    int x;
    x = q[qh];
    qh = qh + 1;
    if (qh == QMAX) qh = 0;
    return x;
}

void add_edge(int x, int y, int z) {
    cnt = cnt + 1;
    to[cnt] = y;
    val[cnt] = z;
    nxt[cnt] = head[x];
    head[x] = cnt;
}

int main() {
    int i;
    int x, y, z;
    int now;
    int ei;
    int tmpn, nn;
    int del;
    int t;
    int ans;

    n = getint();
    m = getint();

    cnt = 0;
    qh = 0;
    qt = 0;

    for (i = 0; i < MAXV; i = i + 1) {
        head[i] = 0;
        vis[i] = 0;
        dis[i] = -1;
        p[i] = 0;
        w[i] = 0;
        s[i] = 0;
    }

    for (i = 1; i <= n; i = i + 1) {
        p[i] = getint();
        p[i + n] = 1 - p[i];
    }
    for (i = 1; i <= n; i = i + 1) {
        w[i] = getint();
        w[i + n] = w[i];
    }
    for (i = 1; i <= n; i = i + 1) {
        s[i] = getint();
        s[i + n] = s[i];
    }

    for (i = 1; i <= m; i = i + 1) {
        x = getint();
        y = getint();
        z = getint();
        add_edge(x, y, z);
        add_edge(x + n, y + n, z);
    }

    q_push(1);
    vis[1] = 1;
    dis[1] = 0;

    for (; qh != qt; ) {
        now = q_pop();
        vis[now] = 0;

        for (ei = head[now]; ei != 0; ei = nxt[ei]) {
            tmpn = to[ei];
            nn = tmpn;

            del = abs_int(w[now] - w[tmpn]);

            if (nn > n) nn = nn - n;
            else nn = nn + n;

            if (p[now] == 0 && p[tmpn] == 1) {
                del = val[ei] - del;
                if (del < 0) del = 0;
            } else if (p[now] == 1 && p[tmpn] == 0) {
                del = val[ei] + del;
            } else {
                del = val[ei];
            }

            if (dis[nn] == -1 || dis[nn] > dis[now] + del) {
                dis[nn] = dis[now] + del;
                if (vis[nn] == 0) {
                    vis[nn] = 1;
                    q_push(nn);
                }
            }
        }

        t = 0;
        if (p[now] == 1) t = s[now];
        nn = now;
        if (nn > n) nn = nn - n;
        else nn = nn + n;

        if (dis[nn] == -1 || dis[nn] > dis[now] + t) {
            dis[nn] = dis[now] + t;
            if (vis[nn] == 0) {
                vis[nn] = 1;
                q_push(nn);
            }
        }
    }

    ans = dis[n];
    if (ans == -1) ans = dis[n + n];
    else {
        if (dis[n + n] != -1) ans = min2(ans, dis[n + n]);
    }
    printf("%d\n", ans);
    return 0;
}
