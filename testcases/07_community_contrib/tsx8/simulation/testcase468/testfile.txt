/* Description:
 *   Converted from C++: DP over a "string" (here: int sequence).
 *   Input:
 *     mlen
 *     serial[0..mlen-1] (one integer per line)
 *   Output:
 *     dyna[0][mlen-1] mod 1,000,000,000
 */

const int mod = 1000000000;
const int MAXL = 310;

int serial[MAXL];
int dyna[MAXL * MAXL];

int idx(int i, int j) {
    return i * MAXL + j;
}

int mul_mod(int a, int b) {
    int res;
    int aa;
    int bb;
    res = 0;
    aa = a;
    bb = b;
    for (; bb > 0; bb = bb / 2) {
        if (bb % 2 == 1) {
            res = res + aa;
            if (res >= mod) res = res - mod;
        }
        aa = aa + aa;
        if (aa >= mod) aa = aa - mod;
    }
    return res;
}

int main() {
    int mlen;
    int i;
    int len;
    int j;
    int k;
    int span;
    int value;

    mlen = getint();
    if (mlen > MAXL) mlen = MAXL;
    if (mlen <= 0) {
        printf("0\n");
        return 0;
    }

    for (i = 0; i < mlen; i = i + 1) {
        serial[i] = getint();
    }

    for (i = 0; i < mlen; i = i + 1) {
        dyna[idx(i, i)] = 1;
    }

    for (len = 1; len < mlen; len = len + 1) {
        for (i = 0; i + len < mlen; i = i + 1) {
            j = i + len;
            dyna[idx(i, j)] = 0;

            span = j - i + 1;
            if (serial[i] == serial[j] && span % 2 == 1) {
                dyna[idx(i, j)] = dyna[idx(i + 1, j - 1)];
                for (k = i + 2; k < j; k = k + 1) {
                    if (serial[k] == serial[i]) {
                        value = mul_mod(dyna[idx(i + 1, k - 1)], dyna[idx(k, j)]);
                        dyna[idx(i, j)] = dyna[idx(i, j)] + value;
                        if (dyna[idx(i, j)] >= mod) dyna[idx(i, j)] = dyna[idx(i, j)] - mod;
                    }
                }
            }
        }
    }

    printf("%d\n", dyna[idx(0, mlen - 1)]);
    return 0;
}
