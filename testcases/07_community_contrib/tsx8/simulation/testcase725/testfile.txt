/* Description:
 *   Convert a bracket string DP into Strict SysY.
 *
 *   Input:
 *     n
 *     a1
 *     a2
 *     ...
 *     an
 *   where ai = 0 means '(' and ai = 1 means ')'.
 *
 *   Output:
 *     Minimum number of flips needed to make the sequence a valid
 *     bracket sequence (never negative balance, ends with balance 0).
 */

const int MAXN = 5005;
const int INF = 707406378;

int n;
int a[MAXN];
int f[2 * MAXN];

int min2(int x, int y) {
    if (x < y) return x;
    return y;
}

int main() {
    int i;
    int j;
    int now;
    int prev;
    int cur;

    n = getint();
    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
    }

    now = 0;
    for (j = 0; j <= n + 1; j = j + 1) {
        f[now * MAXN + j] = INF;
        f[(1 - now) * MAXN + j] = INF;
    }

    if (n >= 1) {
        if (a[1] == 1) {
            f[now * MAXN + 1] = 1;
        } else {
            f[now * MAXN + 1] = 0;
        }
    }

    for (i = 2; i <= n; i = i + 1) {
        cur = 1 - now;
        prev = now;

        for (j = 0; j <= n + 1; j = j + 1) {
            f[cur * MAXN + j] = INF;
        }

        for (j = 0; j <= i; j = j + 1) {
            int best;
            best = INF;

            if (a[i] == 0) {
                if (j > 0) best = min2(best, f[prev * MAXN + (j - 1)]);
                best = min2(best, f[prev * MAXN + (j + 1)] + 1);
            } else {
                if (j > 0) best = min2(best, f[prev * MAXN + (j - 1)] + 1);
                best = min2(best, f[prev * MAXN + (j + 1)]);
            }

            f[cur * MAXN + j] = best;
        }

        now = cur;
    }

    printf("%d\n", f[now * MAXN + 0]);
    return 0;
}
