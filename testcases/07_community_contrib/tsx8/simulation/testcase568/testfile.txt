const int MOD = 1000000007;
const int MAXN = 2005;
const int MAXM = 4005;

int n;
int cnt;

int head[MAXN];
int to[MAXM];
int nxt[MAXM];

int hx[MAXN];
int hy[MAXN];
int q[MAXN];

int fa[MAXN];
int parent[MAXN];

int a[MAXN];
int d[MAXN];
int sdown[MAXN];
int an[MAXN];

int it[MAXN];
int st[MAXN];

int ans;

int mod_norm(int x) {
    int r = x % MOD;
    if (r < 0) r = r + MOD;
    return r;
}

int mod_add(int x, int y) {
    int r = x + y;
    if (r >= MOD) r = r - MOD;
    if (r < 0) r = r + MOD;
    return r;
}

int mul_mod(int x, int y) {
    int a1 = mod_norm(x);
    int b1 = mod_norm(y);
    int res = 0;
    for (; b1 > 0; b1 = b1 / 2) {
        if (b1 % 2 == 1) res = mod_add(res, a1);
        a1 = mod_add(a1, a1);
    }
    return res;
}

int pow_mod(int base, int exp) {
    int res = 1;
    int b = mod_norm(base);
    int e = exp;
    for (; e > 0; e = e / 2) {
        if (e % 2 == 1) res = mul_mod(res, b);
        b = mul_mod(b, b);
    }
    return res;
}

int mod_inv(int x) {
    return pow_mod(x, MOD - 2);
}

void div_val(int v) {
    int nv = mod_norm(v);
    ans = mul_mod(ans, mod_inv(nv));
}

void add_edge(int x, int y) {
    cnt = cnt + 1;
    to[cnt] = y;
    nxt[cnt] = head[x];
    head[x] = cnt;
    cnt = cnt + 1;
    to[cnt] = x;
    nxt[cnt] = head[y];
    head[y] = cnt;
}

int father(int x) {
    if (fa[x] == x) return x;
    fa[x] = father(fa[x]);
    return fa[x];
}

void build_parent() {
    int i;
    int top = 0;
    int u;
    int eidx;
    int v;
    for (i = 1; i <= n; i = i + 1) {
        it[i] = head[i];
        parent[i] = 0;
    }
    top = top + 1;
    st[top] = 1;
    parent[1] = 0;
    for (; top > 0;) {
        u = st[top];
        eidx = it[u];
        if (eidx == 0) {
            top = top - 1;
        } else {
            v = to[eidx];
            it[u] = nxt[eidx];
            if (v == parent[u]) {
            } else {
                parent[v] = u;
                top = top + 1;
                st[top] = v;
            }
        }
    }
}

void update_path(int start, int fat) {
    int u = start;
    int s1;
    int s2;
    int du;
    int i;
    int v;
    int tmp;
    int cand;
    for (; 1;) {
        s1 = 0;
        s2 = 0;
        du = d[u];
        for (i = head[u]; i != 0; i = nxt[i]) {
            v = to[i];
            if (v == parent[u]) {
            } else {
                tmp = sdown[v];
                if (tmp >= s1) {
                    s2 = s1;
                    s1 = tmp;
                } else {
                    if (tmp > s2) s2 = tmp;
                }
                if (d[v] > du) du = d[v];
            }
        }
        cand = s1 + s2 + a[u];
        if (cand > du) du = cand;
        d[u] = du;
        sdown[u] = s1 + a[u];
        if (u == fat) break;
        u = parent[u];
    }
}

int main() {
    int i;
    int ii;
    int x;
    int y;
    int rootx;
    int rooty;
    n = getint();

    ans = 1;
    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
        ans = mul_mod(ans, a[i]);
        fa[i] = i;
        d[i] = a[i];
        sdown[i] = a[i];
        head[i] = 0;
    }

    cnt = 0;
    for (i = 1; i < n; i = i + 1) {
        hx[i] = getint();
        hy[i] = getint();
        add_edge(hx[i], hy[i]);
    }

    build_parent();

    for (i = 1; i <= n; i = i + 1) head[i] = 0;
    cnt = 0;

    for (i = 1; i < n; i = i + 1) q[i] = getint();

    an[n] = ans;
    for (i = n - 1; i >= 1; i = i - 1) {
        ii = q[i];
        x = hx[ii];
        y = hy[ii];
        rootx = father(x);
        rooty = father(y);

        add_edge(x, y);
        div_val(d[rootx]);
        div_val(d[rooty]);

        if (parent[y] == x) {
            update_path(x, rootx);
            ans = mul_mod(ans, d[rootx]);
            fa[y] = rootx;
        } else {
            update_path(y, rooty);
            ans = mul_mod(ans, d[rooty]);
            fa[x] = rooty;
        }
        an[i] = ans;
    }

    for (i = 1; i <= n; i = i + 1) printf("%d\n", an[i]);
    return 0;
}
