/* Description:
 *   Converted from a C++ brute-force DFS solution.
 *   Observed: each undirected edge (u,v) contributes the value of the later
 *   endpoint in the visitation order; optimal ordering is by decreasing val,
 *   so the minimal total equals sum over edges of min(val[u], val[v]).
 */

const int MAXN = 10005;

int val[MAXN];

int main() {
    int n;
    int m;
    int i;
    int ans;
    int x;
    int y;

    n = getint();
    m = getint();

    for (i = 1; i <= n; i = i + 1) {
        val[i] = getint();
    }

    ans = 0;
    for (i = 1; i <= m; i = i + 1) {
        x = getint();
        y = getint();

        if (x == y) {
            ans = ans + 0;
        } else {
            if (val[x] < val[y]) {
                ans = ans + val[x];
            } else {
                ans = ans + val[y];
            }
        }
    }

    printf("%d\n", ans);
    return 0;
}
