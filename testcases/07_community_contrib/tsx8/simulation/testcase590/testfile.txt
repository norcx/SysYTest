/* Description:
 *   Brute-force subset search on a small weighted graph.
 *   For each selected vertex subset S:
 *     t1 = sum of vertex weights in S
 *     t2 = sum of edge weights inside S (i < j)
 *   Find max ratio t1 / t2 (t2 != 0), output as an integer scaled by 100.
 */

const int MAXN = 25;

int n;
int m;
int vis[MAXN];
int a[MAXN];
int b[MAXN * MAXN];

int best_num;
int best_den;

void dfs(int now) {
    int i;
    int j;
    if (now > n) {
        int t1;
        int t2;
        t1 = 0;
        t2 = 0;
        for (i = 1; i <= n; i = i + 1) {
            if (vis[i] != 0) {
                t1 = t1 + a[i];
                for (j = i + 1; j <= n; j = j + 1) {
                    if (vis[j] != 0) {
                        t2 = t2 + b[i * MAXN + j];
                    }
                }
            }
        }
        if (t2 == 0) {
            return;
        }
        if (best_den == 0) {
            best_num = t1;
            best_den = t2;
            return;
        }
        if (t1 * best_den > best_num * t2) {
            best_num = t1;
            best_den = t2;
        }
        return;
    }

    vis[now] = 1;
    dfs(now + 1);
    vis[now] = 0;
    dfs(now + 1);
    return;
}

int main() {
    int i;
    int x;
    int y;
    int z;
    int ans100;

    n = getint();
    m = getint();

    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
    }

    for (i = 1; i <= m; i = i + 1) {
        x = getint();
        y = getint();
        z = getint();
        b[x * MAXN + y] = z;
        b[y * MAXN + x] = z;
    }

    best_num = -1000000000;
    best_den = 0;
    dfs(1);

    if (best_den == 0) {
        printf("%d\n", -1000000000);
        return 0;
    }

    ans100 = (best_num * 100 + best_den / 2) / best_den;
    printf("%d\n", ans100);
    return 0;
}
