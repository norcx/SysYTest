/* Description:
 *   Answer multiple queries of:
 *     number of permutations of size n with exactly m inversions (mod 10000)
 *
 *   Converted from a C++ solution to Strict SysY:
 *   - uses getint() for input and printf("%d\n", ...) for output
 *   - rolling 1D DP arrays (no 2D arrays)
 */

const int MOD = 10000;
const int MAXM = 64;
const int MAXT = 16;

int qn[16];
int qm[16];
int ans[16];

int f_prev[64];
int g_prev[64];
int f_cur[64];
int g_cur[64];

int main() {
    int T;
    int i;
    int j;
    int t;
    int max_n;
    int max_m;
    int k;
    int tmp;

    T = getint();

    max_n = 1;
    max_m = 0;
    i = 0;
    for (i = 0; i < T; i = i + 1) {
        qn[i] = getint();
        qm[i] = getint();
        if (qn[i] > max_n) max_n = qn[i];
        if (qm[i] > max_m) max_m = qm[i];
    }

    for (t = 0; t < T; t = t + 1) ans[t] = 0;

    for (j = 0; j < MAXM; j = j + 1) {
        f_prev[j] = 0;
        g_prev[j] = 1;
    }
    f_prev[0] = 1;

    for (t = 0; t < T; t = t + 1) {
        if (qn[t] == 1) {
            if (qm[t] == 0) ans[t] = 1;
            else ans[t] = 0;
        }
    }

    for (i = 2; i <= max_n; i = i + 1) {
        for (j = 0; j <= max_m; j = j + 1) {
            k = j;
            if (i - 1 < k) k = i - 1;

            tmp = g_prev[j];
            if (k != j) tmp = tmp - g_prev[j - k - 1];
            tmp = tmp % MOD;
            if (tmp < 0) tmp = tmp + MOD;
            f_cur[j] = tmp;

            if (j == 0) g_cur[j] = f_cur[j];
            else {
                tmp = g_cur[j - 1] + f_cur[j];
                tmp = tmp % MOD;
                if (tmp < 0) tmp = tmp + MOD;
                g_cur[j] = tmp;
            }
        }

        for (t = 0; t < T; t = t + 1) {
            if (qn[t] == i) ans[t] = f_cur[qm[t]];
        }

        for (j = 0; j <= max_m; j = j + 1) {
            f_prev[j] = f_cur[j];
            g_prev[j] = g_cur[j];
        }
    }

    for (t = 0; t < T; t = t + 1) {
        printf("%d\n", ans[t]);
    }

    return 0;
}
