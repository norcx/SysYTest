/* Description:
 *   Range affine transforms over 2D points (int-only Strict SysY).
 *
 * Input (all integers, one per line):
 *   n
 *   x1 y1 x2 y2 ... xn yn
 *   m
 *   For each op:
 *     op l r [params...]
 *   op:
 *     1: translate, params dx dy
 *     2: reflect X axis (y = -y)
 *     3: reflect Y axis (x = -x)
 *     4: swap x/y
 *     5: rotate by angle in {0,90,180,270} degrees (CCW), param angle
 *
 * Output:
 *   n lines: "x.00 y.00"
 */

const int TREE_SIZE = 520;

int ax[130];
int ay[130];

int P[520];
int Q[520];
int R[520];
int S[520];
int TX[520];
int TY[520];

int tp;
int tq;
int tr;
int ts;
int ttx;
int tty;

void compose_node(int idx, int p2, int q2, int r2, int s2, int tx2, int ty2) {
    int p1;
    int q1;
    int r1;
    int s1;
    int tx1;
    int ty1;
    int np;
    int nq;
    int nr;
    int ns;
    int ntx;
    int nty;

    p1 = P[idx];
    q1 = Q[idx];
    r1 = R[idx];
    s1 = S[idx];
    tx1 = TX[idx];
    ty1 = TY[idx];

    np = p1 * p2 + q1 * r2;
    nq = p1 * q2 + q1 * s2;
    nr = r1 * p2 + s1 * r2;
    ns = r1 * q2 + s1 * s2;
    ntx = tx1 * p2 + ty1 * r2 + tx2;
    nty = tx1 * q2 + ty1 * s2 + ty2;

    P[idx] = np;
    Q[idx] = nq;
    R[idx] = nr;
    S[idx] = ns;
    TX[idx] = ntx;
    TY[idx] = nty;
    return;
}

void set_identity(int idx) {
    P[idx] = 1;
    Q[idx] = 0;
    R[idx] = 0;
    S[idx] = 1;
    TX[idx] = 0;
    TY[idx] = 0;
    return;
}

void push_down(int o) {
    int lch;
    int rch;

    lch = o * 2;
    rch = o * 2 + 1;
    compose_node(lch, P[o], Q[o], R[o], S[o], TX[o], TY[o]);
    compose_node(rch, P[o], Q[o], R[o], S[o], TX[o], TY[o]);
    set_identity(o);
    return;
}

void update(int l, int r, int o, int x, int y) {
    int mid;
    if (x <= l && r <= y) {
        compose_node(o, tp, tq, tr, ts, ttx, tty);
        return;
    }

    push_down(o);
    mid = (l + r) / 2;
    if (x <= mid) update(l, mid, o * 2, x, y);
    if (y > mid) update(mid + 1, r, o * 2 + 1, x, y);
    return;
}

void dfs(int l, int r, int o) {
    int mid;
    int x;
    int y;
    int nx;
    int ny;

    if (l == r) {
        x = ax[l];
        y = ay[l];
        nx = x * P[o] + y * R[o] + TX[o];
        ny = x * Q[o] + y * S[o] + TY[o];
        printf("%d.00 %d.00\n", nx, ny);
        return;
    }

    push_down(o);
    mid = (l + r) / 2;
    dfs(l, mid, o * 2);
    dfs(mid + 1, r, o * 2 + 1);
    return;
}

int main() {
    int n;
    int m;
    int i;
    int opi;
    int op;
    int l;
    int r;
    int dx;
    int dy;
    int ang;

    n = getint();
    i = 1;
    for (i = 1; i <= n; i = i + 1) {
        ax[i] = getint();
        ay[i] = getint();
    }

    i = 1;
    for (i = 1; i < TREE_SIZE; i = i + 1) set_identity(i);

    m = getint();
    opi = 0;
    for (opi = 0; opi < m; opi = opi + 1) {
        op = getint();
        l = getint();
        r = getint();

        tp = 1;
        tq = 0;
        tr = 0;
        ts = 1;
        ttx = 0;
        tty = 0;

        if (op == 1) {
            dx = getint();
            dy = getint();
            ttx = dx;
            tty = dy;
        }
        if (op == 2) {
            ts = -1;
        }
        if (op == 3) {
            tp = -1;
        }
        if (op == 4) {
            tp = 0;
            tq = 1;
            tr = 1;
            ts = 0;
        }
        if (op == 5) {
            ang = getint();
            if (ang == 0) {
                tp = 1; tq = 0; tr = 0; ts = 1;
            }
            if (ang == 90) {
                tp = 0; tq = 1; tr = -1; ts = 0;
            }
            if (ang == 180) {
                tp = -1; tq = 0; tr = 0; ts = -1;
            }
            if (ang == 270) {
                tp = 0; tq = -1; tr = 1; ts = 0;
            }
        }

        update(1, n, 1, l, r);
    }

    dfs(1, n, 1);
    return 0;
}
