/*
  Converted from a C++ solution:
  - Sparse table RMQ for range maximum
  - DP over partitions
*/

int n;
int m;

int a[2005];
int b[2005];
int sum[2005];
int c[2005];
int f[2005];

int p2[20];
int mx[2005 * 20];

int max2(int x, int y) {
    if (x > y) return x;
    return y;
}

int mx_idx(int pos, int lg) {
    return pos * 20 + lg;
}

int get_mx(int x, int y) {
    int len;
    int lg;
    int left;
    int right;
    len = y - x + 1;
    lg = c[len];
    left = mx[mx_idx(x, lg)];
    right = mx[mx_idx(y - p2[lg] + 1, lg)];
    return max2(left, right);
}

int main() {
    int i;
    int j;
    int k;
    int tmp;
    int cand;

    n = getint();
    m = getint();

    p2[0] = 1;
    for (i = 1; i < 20; i = i + 1) p2[i] = p2[i - 1] * 2;

    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
        mx[mx_idx(i, 0)] = a[i];
    }

    c[1] = 0;
    for (i = 2; i <= n; i = i + 1) c[i] = c[i / 2] + 1;

    for (k = 1; p2[k] <= n; k = k + 1) {
        for (j = 1; j + p2[k] - 1 <= n; j = j + 1) {
            mx[mx_idx(j, k)] = max2(mx[mx_idx(j, k - 1)], mx[mx_idx(j + p2[k - 1], k - 1)]);
        }
    }

    for (i = 1; i <= n; i = i + 1) {
        b[i] = getint();
        sum[i] = sum[i - 1] + b[i];
    }

    for (i = 1; i <= n; i = i + 1) {
        tmp = get_mx(1, i);
        if (tmp <= m) f[i] = m - tmp + sum[i];
        for (j = 1; j < i; j = j + 1) {
            tmp = get_mx(j + 1, i);
            if (f[j] >= tmp) {
                cand = f[j] - tmp + sum[i] - sum[j];
                if (cand > f[i]) f[i] = cand;
            }
        }
    }

    printf("%d\n", f[n]);
    return 0;
}
