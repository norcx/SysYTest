/* Description:
 * Converted from a C++ SPFA-like shortest path solution using:
 * - 2-layer node duplication (i and i+n)
 * - adjacency list (flattened from struct to parallel arrays)
 * - manual circular queue (replacing std::queue)
 *
 * Input format:
 * n
 * m
 * p[1..n]
 * w[1..n]
 * s[1..n]
 * then m triples (x,y,z), each read as 3 integers
 *
 * Output:
 * min(dis[n], dis[2*n]) + newline
 */

const int MAXN = 60;
const int MAXV = 130;
const int MAXE = 300;
const int MAXQ = 10000;

int n;
int m;
int cnt;

int p[MAXV];
int w[MAXV];
int s[MAXV];

int vis[MAXV];
int dis[MAXV];
int head[MAXV];

int ey[MAXE];
int eval_[MAXE];
int enext[MAXE];

int q[MAXQ];
int qh;
int qt;

int myabs(int x) {
    if (x >= 0) return x;
    return 0 - x;
}

int mymin(int a, int b) {
    int r;
    r = a;
    if (b < r) r = b;
    return r;
}

void add_edge(int x, int y, int z) {
    cnt = cnt + 1;
    ey[cnt] = y;
    eval_[cnt] = z;
    enext[cnt] = head[x];
    head[x] = cnt;
    return;
}

int main() {
    int i;
    int x;
    int y;
    int z;
    int n2;
    int now;
    int edgeIdx;
    int nn;
    int tmpn;
    int del;
    int to;
    int t;
    int cost;
    int cand;
    int tmp;

    n = getint();
    m = getint();
    n2 = n + n;

    cnt = 0;
    for (i = 0; i <= n2; i = i + 1) {
        head[i] = 0;
        vis[i] = 0;
        dis[i] = -1;
    }

    for (i = 1; i <= n; i = i + 1) {
        p[i] = getint();
        p[i + n] = 1 - p[i];
    }
    for (i = 1; i <= n; i = i + 1) {
        w[i] = getint();
        w[i + n] = w[i];
    }
    for (i = 1; i <= n; i = i + 1) {
        s[i] = getint();
        s[i + n] = s[i];
    }

    for (i = 1; i <= m; i = i + 1) {
        x = getint();
        y = getint();
        z = getint();
        add_edge(x, y, z);
        add_edge(x + n, y + n, z);
    }

    qh = 0;
    qt = 0;
    q[qt] = 1;
    qt = qt + 1;
    if (qt == MAXQ) qt = 0;

    vis[1] = 1;
    dis[1] = 0;

    for (; qh != qt; ) {
        now = q[qh];
        qh = qh + 1;
        if (qh == MAXQ) qh = 0;
        vis[now] = 0;

        for (edgeIdx = head[now]; edgeIdx != 0; edgeIdx = enext[edgeIdx]) {
            nn = ey[edgeIdx];
            tmpn = nn;

            del = myabs(w[now] - w[nn]);

            if (nn > n) to = nn - n;
            else to = nn + n;

            if (p[now] == 0 && p[tmpn] == 1) {
                tmp = eval_[edgeIdx] - del;
                if (tmp < 0) tmp = 0;
                cost = tmp;
            } else {
                if (p[now] == 1 && p[tmpn] == 0) {
                    cost = eval_[edgeIdx] + del;
                } else {
                    cost = eval_[edgeIdx];
                }
            }

            cand = dis[now] + cost;
            if (dis[to] == -1) {
                dis[to] = cand;
                if (vis[to] == 0) {
                    vis[to] = 1;
                    q[qt] = to;
                    qt = qt + 1;
                    if (qt == MAXQ) qt = 0;
                }
            } else {
                if (dis[to] > cand) {
                    dis[to] = cand;
                    if (vis[to] == 0) {
                        vis[to] = 1;
                        q[qt] = to;
                        qt = qt + 1;
                        if (qt == MAXQ) qt = 0;
                    }
                }
            }
        }

        t = 0;
        if (p[now] == 1) t = s[now];
        to = now;
        if (to > n) to = to - n;
        else to = to + n;

        cand = dis[now] + t;
        if (dis[to] == -1) {
            dis[to] = cand;
            if (vis[to] == 0) {
                vis[to] = 1;
                q[qt] = to;
                qt = qt + 1;
                if (qt == MAXQ) qt = 0;
            }
        } else {
            if (dis[to] > cand) {
                dis[to] = cand;
                if (vis[to] == 0) {
                    vis[to] = 1;
                    q[qt] = to;
                    qt = qt + 1;
                    if (qt == MAXQ) qt = 0;
                }
            }
        }
    }

    printf("%d\n", mymin(dis[n], dis[n2]));
    return 0;
}
