/* Description:
 * Converted from a C++ Dinic-based maxflow solver.
 * Input: n, m, then m triples (x, y, z).
 * Output: a 0/1 string of length m, then '\n'.
 */

const int MAXV = 128;
const int MAXE = 2048;
const int INF = 2147483647;

int n;
int m;
int cnt;
int S;
int T;

int ru[MAXV];
int chu[MAXV];
int head[MAXV];
int cur[MAXV];
int dis[MAXV];

int e_to[MAXE];
int e_cap[MAXE];
int e_next[MAXE];

int que[MAXV];

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

void add_edge(int x, int y, int flow) {
    cnt = cnt + 1;
    e_to[cnt] = y;
    e_cap[cnt] = flow;
    e_next[cnt] = head[x];
    head[x] = cnt;

    cnt = cnt + 1;
    e_to[cnt] = x;
    e_cap[cnt] = 0;
    e_next[cnt] = head[y];
    head[y] = cnt;
}

int bfs() {
    int i;
    int qh;
    int qt;
    int now;
    int ei;
    int nn;

    for (i = 1; i <= T; i = i + 1) dis[i] = -1;
    qh = 0;
    qt = 0;
    que[qt] = S;
    qt = qt + 1;
    dis[S] = 0;

    for (qh = 0; qh < qt; qh = qh + 1) {
        now = que[qh];
        for (ei = head[now]; ei; ei = e_next[ei]) {
            nn = e_to[ei];
            if (e_cap[ei] <= 0) {
            } else if (dis[nn] == -1) {
                dis[nn] = dis[now] + 1;
                que[qt] = nn;
                qt = qt + 1;
            }
        }
    }

    if (dis[T] == -1) return 0;
    return 1;
}

int dfs(int now, int last) {
    int flow;
    int f;
    int ei;
    int nn;
    int pushed;

    flow = 0;
    f = 0;
    if (now == T || last == 0) return last;

    for (ei = cur[now]; ei; ei = e_next[ei]) {
        cur[now] = ei;
        nn = e_to[ei];
        if (dis[nn] == dis[now] + 1) {
            pushed = last;
            if (pushed > e_cap[ei]) pushed = e_cap[ei];
            f = dfs(nn, pushed);
            if (f > 0) {
                flow = flow + f;
                last = last - f;
                e_cap[ei] = e_cap[ei] - f;
                if (ei % 2 == 0) e_cap[ei + 1] = e_cap[ei + 1] + f;
                else e_cap[ei - 1] = e_cap[ei - 1] + f;
                if (last == 0) break;
            }
        }
    }

    return flow;
}

void dinic() {
    int i;
    for (;;) {
        if (bfs() == 0) break;
        for (i = 1; i <= T; i = i + 1) cur[i] = head[i];
        dfs(S, INF);
    }
}

int main() {
    int i;
    int x;
    int y;
    int z;

    n = getint();
    m = getint();

    cnt = 1;
    S = n + 1;
    T = S + 1;

    for (i = 1; i <= m; i = i + 1) {
        x = getint();
        y = getint();
        z = getint();
        ru[y] = ru[y] + 1;
        chu[x] = chu[x] + 1;
        add_edge(y, z, 1);
    }

    for (i = 1; i <= n; i = i + 1) {
        if (ru[i] > chu[i]) add_edge(S, i, ru[i] - chu[i]);
        if (chu[i] > ru[i]) add_edge(i, T, chu[i] - ru[i]);
    }

    dinic();

    for (i = 1; i <= m; i = i + 1) {
        if (e_cap[i * 2 + 1] > 0) printf("%d", 1);
        else printf("%d", 0);
    }
    printf("\n");
    return 0;
}
