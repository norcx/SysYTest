const int MAXP = 120;
const int MAXD = 600;
const int MOD = 64123;

int T;
int k;
int m;
int mx_p;
int len_s;

int p[MAXP];
int f[MAXP];

int base[MAXP * MAXP];
int ans[MAXP * MAXP];
int nowm[MAXP * MAXP];
int tm[MAXP * MAXP];

int digits[MAXD];
int a[MAXD];
int b[MAXD];
int c[MAXD];
int t1[MAXD];

int idx(int i, int j) {
  return i * MAXP + j;
}

int mul_mod(int x, int y) {
  int res;
  int a0;
  int b0;
  res = 0;
  a0 = x % MOD;
  b0 = y % MOD;
  for (; b0 > 0; b0 = b0 / 2) {
    if (b0 % 2 == 1) {
      res = res + a0;
      if (res >= MOD) res = res - MOD;
    }
    a0 = a0 + a0;
    if (a0 >= MOD) a0 = a0 - MOD;
  }
  return res;
}

void work1() {
  int i;
  int j;
  int kk;
  int sum;
  for (i = 1; i <= mx_p; i = i + 1) {
    for (j = 1; j <= mx_p; j = j + 1) {
      sum = 0;
      for (kk = 1; kk <= mx_p; kk = kk + 1) {
        sum = sum + mul_mod(ans[idx(i, kk)], nowm[idx(kk, j)]);
        sum = sum % MOD;
      }
      tm[idx(i, j)] = sum;
    }
  }
  for (i = 1; i <= mx_p; i = i + 1) {
    for (j = 1; j <= mx_p; j = j + 1) {
      ans[idx(i, j)] = tm[idx(i, j)];
    }
  }
}

void work2() {
  int i;
  int j;
  int kk;
  int sum;
  for (i = 1; i <= mx_p; i = i + 1) {
    for (j = 1; j <= mx_p; j = j + 1) {
      sum = 0;
      for (kk = 1; kk <= mx_p; kk = kk + 1) {
        sum = sum + mul_mod(nowm[idx(i, kk)], nowm[idx(kk, j)]);
        sum = sum % MOD;
      }
      tm[idx(i, j)] = sum;
    }
  }
  for (i = 1; i <= mx_p; i = i + 1) {
    for (j = 1; j <= mx_p; j = j + 1) {
      nowm[idx(i, j)] = tm[idx(i, j)];
    }
  }
}

void trim_c() {
  for (;;) {
    if (c[0] > 1 && c[c[0]] == 0) {
      c[0] = c[0] - 1;
    } else {
      break;
    }
  }
}

void work3() {
  int i;
  for (i = c[0]; i >= 1; i = i - 1) {
    if (i > 1) {
      c[i - 1] = c[i - 1] + (c[i] % 2) * 10;
    }
    c[i] = c[i] / 2;
  }
  trim_c();
}

int judge() {
  if (c[0] == 1 && c[1] == 0) return 0;
  return 1;
}

void normalize_c_negative() {
  int i;
  int tmp;
  for (i = 1; i <= c[0]; i = i + 1) {
    tmp = 0;
    for (;;) {
      if (c[i] < 0) {
        c[i] = c[i] + 10;
        tmp = tmp + 1;
      } else {
        break;
      }
    }
    c[i + 1] = c[i + 1] - tmp;
  }
  trim_c();
}

void work() {
  int i;
  int j;
  int an;
  int tmp;

  c[1] = c[1] - mx_p - 1;

  for (i = 1; i <= mx_p; i = i + 1) {
    for (j = 1; j <= mx_p; j = j + 1) {
      ans[idx(i, j)] = base[idx(i, j)];
      nowm[idx(i, j)] = base[idx(i, j)];
    }
  }

  normalize_c_negative();

  for (;;) {
    if (judge() == 0) break;
    if (c[1] % 2 == 1) work1();
    work2();
    work3();
  }

  an = 0;
  for (i = 1; i <= mx_p; i = i + 1) {
    tmp = mul_mod(f[i] % MOD, ans[idx(i, mx_p)]);
    an = an + tmp;
    an = an % MOD;
  }
  printf("%d\n", an);
}

void init_case() {
  int i;
  int j;
  int tmpmax;

  for (i = 0; i < MAXD; i = i + 1) {
    a[i] = 0;
    b[i] = 0;
    c[i] = 0;
    t1[i] = 0;
  }

  for (i = 1; i <= len_s; i = i + 1) {
    a[i] = digits[len_s - i + 1];
  }
  a[0] = len_s;

  b[0] = 1;
  b[1] = 1;
  c[0] = 1;
  c[1] = 0;

  for (i = 1; i <= len_s; i = i + 1) {
    for (j = 1; j <= b[0] + 2; j = j + 1) t1[j] = 0;

    t1[0] = b[0] + 1;
    t1[t1[0]] = 0;
    for (j = 1; j <= b[0]; j = j + 1) t1[j] = b[j] * a[i];
    for (j = 1; j <= b[0]; j = j + 1) {
      t1[j + 1] = t1[j + 1] + t1[j] / 10;
      t1[j] = t1[j] % 10;
    }
    for (;;) {
      if (t1[0] > 1 && t1[t1[0]] == 0) {
        t1[0] = t1[0] - 1;
      } else {
        break;
      }
    }

    for (j = 1; j <= t1[0]; j = j + 1) c[j] = c[j] + t1[j];
    for (j = 1; j <= t1[0]; j = j + 1) {
      c[j + 1] = c[j + 1] + c[j] / 10;
      c[j] = c[j] % 10;
    }

    tmpmax = t1[0];
    if (c[0] > tmpmax) tmpmax = c[0];
    c[0] = tmpmax + 2;
    trim_c();

    for (j = 1; j <= b[0]; j = j + 1) b[j] = b[j] * k;
    for (j = 1; j <= b[0]; j = j + 1) {
      b[j + 1] = b[j + 1] + b[j] / 10;
      b[j] = b[j] % 10;
    }
    b[0] = b[0] + 1;
    for (;;) {
      if (b[0] > 1 && b[b[0]] == 0) {
        b[0] = b[0] - 1;
      } else {
        break;
      }
    }
  }
}

int main() {
  int i;
  int j;
  int ii;
  int jj;
  int pd;
  int tmpv;

  T = getint();
  k = getint();
  m = getint();
  mx_p = 0;

  for (i = 1; i <= m; i = i + 1) {
    p[i] = getint();
    if (p[i] > mx_p) mx_p = p[i];
  }

  for (i = 0; i < MAXP; i = i + 1) f[i] = 0;
  f[0] = 1;
  for (i = 1; i <= mx_p; i = i + 1) {
    for (j = 1; j <= m; j = j + 1) {
      if (i - p[j] >= 0) f[i] = f[i] + f[i - p[j]];
    }
  }

  for (ii = 1; ii <= mx_p; ii = ii + 1) {
    for (jj = 1; jj <= mx_p; jj = jj + 1) base[idx(ii, jj)] = 0;
  }
  for (i = 1; i < mx_p; i = i + 1) base[idx(i + 1, i)] = 1;
  for (i = 1; i <= m; i = i + 1) base[idx(mx_p + 1 - p[i], mx_p)] = 1;

  for (;;) {
    if (T <= 0) break;
    T = T - 1;

    len_s = getint();
    for (i = 1; i <= len_s; i = i + 1) digits[i] = getint();

    init_case();

    pd = 0;
    if (c[0] <= 2) {
      tmpv = c[1];
      if (c[0] == 2) tmpv = tmpv + c[2] * 10;
      if (tmpv <= mx_p) {
        printf("%d\n", f[tmpv]);
        pd = 1;
      }
    }

    if (pd == 0) work();
  }

  return 0;
}
