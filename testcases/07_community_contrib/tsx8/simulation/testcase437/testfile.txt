/*
  Matrix exponentiation for a linear recurrence:
    F(n) = sum_{j=1..m} F(n - p[j]) (mod 64123), F(0)=1, F(x<0)=0
  Input:
    T, k, m
    p[1..m]
    n (repeat T times)
  Output:
    F(n) mod 64123 per line
*/

const int MAXN = 120;
const int MOD = 64123;

int T;
int k;
int m;
int mx_p;
int n;

int p[MAXN];
int f[MAXN];

int base[MAXN * MAXN];
int ans[MAXN * MAXN];
int now[MAXN * MAXN];
int tm[MAXN * MAXN];

int mul_mod(int a, int b) {
    int res;
    int x;
    int y;
    res = 0;
    x = a % MOD;
    y = b;
    for (; y > 0; y = y / 2) {
        if (y % 2 == 1) {
            res = res + x;
            res = res % MOD;
        }
        x = x + x;
        x = x % MOD;
    }
    return res;
}

void work1() {
    int i;
    int j;
    int kk;
    int row_i;
    int pos_ij;
    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            tm[row_i + j] = 0;
        }
    }

    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            pos_ij = row_i + j;
            for (kk = 1; kk <= mx_p; kk = kk + 1) {
                tm[pos_ij] = tm[pos_ij] + mul_mod(ans[row_i + kk], now[kk * MAXN + j]);
                tm[pos_ij] = tm[pos_ij] % MOD;
            }
        }
    }

    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            ans[row_i + j] = tm[row_i + j];
        }
    }
}

void work2() {
    int i;
    int j;
    int kk;
    int row_i;
    int pos_ij;
    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            tm[row_i + j] = 0;
        }
    }

    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            pos_ij = row_i + j;
            for (kk = 1; kk <= mx_p; kk = kk + 1) {
                tm[pos_ij] = tm[pos_ij] + mul_mod(now[row_i + kk], now[kk * MAXN + j]);
                tm[pos_ij] = tm[pos_ij] % MOD;
            }
        }
    }

    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            now[row_i + j] = tm[row_i + j];
        }
    }
}

void solve_one() {
    int i;
    int j;
    int exp;
    int an;
    int row_i;

    exp = n - mx_p - 1;
    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            ans[row_i + j] = base[row_i + j];
            now[row_i + j] = base[row_i + j];
        }
    }

    for (; exp != 0; ) {
        if (exp % 2 == 1) {
            work1();
        }
        exp = exp / 2;
        work2();
    }

    an = 0;
    for (i = 1; i <= mx_p; i = i + 1) {
        an = an + mul_mod(f[i], ans[i * MAXN + mx_p]);
        an = an % MOD;
    }
    printf("%d\n", an);
}

int main() {
    int i;
    int j;
    int row_i;

    T = getint();
    k = getint();
    m = getint();

    mx_p = 0;
    for (i = 1; i <= m; i = i + 1) {
        p[i] = getint();
        if (p[i] > mx_p) {
            mx_p = p[i];
        }
    }

    f[0] = 1;
    for (i = 1; i <= mx_p; i = i + 1) {
        f[i] = 0;
        for (j = 1; j <= m; j = j + 1) {
            if (i - p[j] >= 0) {
                f[i] = f[i] + f[i - p[j]];
                f[i] = f[i] % MOD;
            }
        }
    }

    for (i = 1; i <= mx_p; i = i + 1) {
        row_i = i * MAXN;
        for (j = 1; j <= mx_p; j = j + 1) {
            base[row_i + j] = 0;
        }
    }

    for (i = 1; i < mx_p; i = i + 1) {
        base[(i + 1) * MAXN + i] = 1;
    }
    for (i = 1; i <= m; i = i + 1) {
        base[(mx_p + 1 - p[i]) * MAXN + mx_p] = 1;
    }

    for (i = 0; i < T; i = i + 1) {
        n = getint();
        solve_one();
    }
    return 0;
}
