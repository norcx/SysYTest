/* Description:
 * Converted from a C++ matrix DP solution to Strict SysY.
 * Input is terminated by a sentinel `n = 0`.
 */

const int NMAX = 305;
const int MMAX = 305;
const int STR = 306;          /* (NMAX+1) and (MMAX+1) stride */
const int INF_NEG = -1000000000;

int a[STR * STR];
int s[STR * STR];
int MINC[STR];
int b[STR];
int dp0[STR];
int dp1[STR];

int min2(int x, int y) {
    if (x < y) return x;
    return y;
}

int max2(int x, int y) {
    if (x > y) return x;
    return y;
}

int main() {
    int n;
    int m;
    int P;
    int i;
    int j;
    int k;
    int ans;

    for (;;) {
        n = getint();
        if (n == 0) break;

        m = getint();
        P = getint();

        ans = INF_NEG;

        for (k = 0; k <= m; k = k + 1) s[0 * STR + k] = 0;

        for (i = 1; i <= n; i = i + 1) {
            for (j = 1; j <= m; j = j + 1) {
                a[i * STR + j] = getint();
            }
        }

        for (i = 1; i <= n; i = i + 1) {
            for (j = 1; j <= m; j = j + 1) {
                s[i * STR + j] = s[(i - 1) * STR + j] + a[i * STR + j];
            }
        }

        for (i = 1; i <= n; i = i + 1) {
            for (j = 1; j <= m; j = j + 1) {
                MINC[j] = a[i * STR + j];
            }

            for (j = i; j <= n; j = j + 1) {
                for (k = 1; k <= m; k = k + 1) {
                    MINC[k] = min2(MINC[k], a[j * STR + k]);
                }

                for (k = 1; k <= m; k = k + 1) {
                    b[k] = s[j * STR + k] - s[(i - 1) * STR + k];
                }

                dp0[0] = 0;
                dp1[0] = INF_NEG;

                for (k = 1; k <= m; k = k + 1) {
                    int t0;
                    int t1;
                    int t2;

                    t0 = dp0[k - 1] + b[k];
                    dp0[k] = max2(t0, b[k]);

                    t0 = dp1[k - 1] + b[k];
                    t1 = dp0[k - 1] + b[k] - MINC[k] + P;
                    t2 = b[k] - MINC[k] + P;
                    dp1[k] = max2(max2(t0, t1), t2);
                }

                for (k = 1; k < m; k = k + 1) {
                    ans = max2(ans, max2(dp0[k], dp1[k]));
                }

                if (i == 1 && j == n) {
                    int sum;
                    ans = max2(ans, dp1[m]);
                    sum = 0;
                    for (k = m; k > 1; k = k - 1) {
                        sum = sum + b[k];
                        ans = max2(ans, sum);
                    }
                } else {
                    ans = max2(ans, max2(dp1[m], dp0[m]));
                }
            }
        }

        printf("%d\n", ans);
    }

    return 0;
}
