/* Description:
 *   Strict SysY testcase converted from a matrix-exponentiation solution.
 *   Input format (newline-separated integers only):
 *     T
 *     k
 *     m
 *     p1..pm
 *     For each query:
 *       L
 *       d1..dL   (decimal digits of the query number, left to right)
 */

const int MOD = 64123;
const int MAX_MX = 10;
const int MAX_P = 25;
const int MAX_K = 10;

int base[(MAX_P + 1) * MAX_K * (MAX_MX + 1) * (MAX_MX + 1)];
int vis[MAX_MX + 1];
int V[MAX_MX + 1];
int tmpV[MAX_MX + 1];
int digits[MAX_P + 1];

int base_index(int pos, int digit, int i, int j) {
    int idx;
    idx = pos;
    idx = idx * MAX_K + digit;
    idx = idx * (MAX_MX + 1) + i;
    idx = idx * (MAX_MX + 1) + j;
    return idx;
}

int mul_mod(int a, int b) {
    int res;
    int x;
    int y;
    res = 0;
    x = a % MOD;
    y = b;
    for (; y > 0; ) {
        if (y % 2 == 1) {
            res = res + x;
            res = res % MOD;
        }
        x = x + x;
        x = x % MOD;
        y = y / 2;
    }
    return res;
}

void M1(int l1, int r1, int l2, int r2, int l3, int r3, int mx) {
    int i;
    int j;
    int k;
    int idxA;
    int idxB;
    int idxC;
    int add;
    for (i = 1; i <= mx; i = i + 1) {
        for (j = 1; j <= mx; j = j + 1) {
            for (k = 1; k <= mx; k = k + 1) {
                idxA = base_index(l1, r1, i, k);
                idxB = base_index(l2, r2, k, j);
                idxC = base_index(l3, r3, i, j);
                add = mul_mod(base[idxA], base[idxB]);
                base[idxC] = base[idxC] + add;
                base[idxC] = base[idxC] % MOD;
            }
        }
    }
    return;
}

void M2(int l1, int r1, int mx) {
    int i;
    int j;
    int idxM;
    int add;
    for (i = 1; i <= mx; i = i + 1) {
        tmpV[i] = 0;
    }
    for (i = 1; i <= mx; i = i + 1) {
        for (j = 1; j <= mx; j = j + 1) {
            idxM = base_index(l1, r1, j, i);
            add = mul_mod(V[j], base[idxM]);
            tmpV[i] = tmpV[i] + add;
            tmpV[i] = tmpV[i] % MOD;
        }
    }
    for (i = 1; i <= mx; i = i + 1) {
        V[i] = tmpV[i];
    }
    return;
}

int main() {
    int T;
    int k;
    int m;
    int mx;
    int i;
    int d;
    int P;

    T = getint();
    k = getint();
    m = getint();

    mx = 0;
    for (i = 1; i <= m; i = i + 1) {
        int pi;
        pi = getint();
        if (pi >= 1 && pi <= MAX_MX) {
            vis[pi] = 1;
        }
        if (pi > mx) {
            mx = pi;
        }
    }
    if (mx > MAX_MX) {
        mx = MAX_MX;
    }
    if (k > MAX_K) {
        k = MAX_K;
    }

    for (i = 1; i <= mx; i = i + 1) {
        base[base_index(1, 1, i, 1)] = vis[i];
    }
    for (i = 2; i <= mx; i = i + 1) {
        base[base_index(1, 1, i - 1, i)] = 1;
    }
    for (d = 2; d < k; d = d + 1) {
        M1(1, d - 1, 1, 1, 1, d, mx);
    }

    P = 1;
    for (i = 0; i < T; i = i + 1) {
        int L;
        int pos;

        L = getint();
        if (L < 1) {
            L = 1;
        }
        if (L > MAX_P) {
            L = MAX_P;
        }

        for (pos = 1; pos <= L; pos = pos + 1) {
            int x;
            x = getint();
            if (x < 0) {
                x = 0;
            }
            if (x > 9) {
                x = x % 10;
            }
            digits[pos] = x;
        }

        for (; P < L; ) {
            P = P + 1;
            M1(P - 1, k - 1, P - 1, 1, P, 1, mx);
            for (d = 2; d < k; d = d + 1) {
                M1(P, d - 1, P, 1, P, d, mx);
            }
        }

        for (pos = 1; pos <= mx; pos = pos + 1) {
            V[pos] = 0;
        }
        V[1] = 1;

        for (pos = 1; pos <= L; pos = pos + 1) {
            int digit;
            digit = digits[pos];
            if (digit != 0) {
                M2(L - pos + 1, digit, mx);
            }
        }

        printf("%d\n", V[1]);
    }

    return 0;
}
