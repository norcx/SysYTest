/* Description:
 *   Strict SysY translation of the given C++ program:
 *   - No structs / templates / STL
 *   - int-only, for-loops only, no bitwise ops
 */

const int MAXM = 20050;

int n;
int m;
int ans;

int fa[MAXM];

int ha_l[MAXM];
int ha_r[MAXM];
int ha_z[MAXM];

int t_l[MAXM];
int t_r[MAXM];
int t_z[MAXM];

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

int max2(int a, int b) {
    if (a > b) return a;
    return b;
}

int father(int x) {
    if (fa[x] == x) return x;
    fa[x] = father(fa[x]);
    return fa[x];
}

void tswap(int i, int j) {
    int tmp;
    tmp = t_l[i];
    t_l[i] = t_l[j];
    t_l[j] = tmp;
    tmp = t_r[i];
    t_r[i] = t_r[j];
    t_r[j] = tmp;
    tmp = t_z[i];
    t_z[i] = t_z[j];
    t_z[j] = tmp;
}

void qsort_desc(int left, int right) {
    int i;
    int j;
    int pivot;
    if (left >= right) return;

    i = left;
    j = right;
    pivot = t_z[(left + right) / 2];
    for (; i <= j; ) {
        for (; t_z[i] > pivot; ) i = i + 1;
        for (; t_z[j] < pivot; ) j = j - 1;
        if (i <= j) {
            tswap(i, j);
            i = i + 1;
            j = j - 1;
        }
    }
    if (left < j) qsort_desc(left, j);
    if (i < right) qsort_desc(i, right);
    return;
}

int judge(int mid) {
    int i;
    int j;

    int minl;
    int maxl;
    int minr;
    int maxr;

    for (i = 1; i <= n + 1; i = i + 1) fa[i] = i;
    for (i = 1; i <= mid; i = i + 1) {
        t_l[i] = ha_l[i];
        t_r[i] = ha_r[i];
        t_z[i] = ha_z[i];
    }

    qsort_desc(1, mid);

    minl = t_l[1];
    maxl = t_l[1];
    minr = t_r[1];
    maxr = t_r[1];

    for (i = 2; i <= mid; i = i + 1) {
        if (t_z[i] < t_z[i - 1]) {
            int root_maxl;
            root_maxl = father(maxl);
            if (root_maxl > minr) return 0;

            {
                int limit;
                int root;
                limit = father(maxr + 1);
                j = father(minl);
                for (; j <= maxr; j = j + 1) {
                    root = father(j);
                    fa[root] = limit;
                }
            }

            minl = t_l[i];
            maxl = t_l[i];
            minr = t_r[i];
            maxr = t_r[i];
        } else {
            minl = min2(minl, t_l[i]);
            maxl = max2(maxl, t_l[i]);
            minr = min2(minr, t_r[i]);
            maxr = max2(maxr, t_r[i]);
            if (father(maxl) > minr) return 0;
        }
    }
    if (father(maxl) > minr) return 0;
    return 1;
}

int main() {
    int i;
    int l;
    int r;
    int mid;

    n = getint();
    m = getint();
    for (i = 1; i <= m; i = i + 1) {
        ha_l[i] = getint();
        ha_r[i] = getint();
        ha_z[i] = getint();
    }

    l = 1;
    r = n;
    ans = n + 1;

    for (; l <= r; ) {
        mid = (l + r) / 2;
        if (judge(mid) == 0) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }

    printf("%d\n", ans);
    return 0;
}
