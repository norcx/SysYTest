/* Description:
 * Segment tree with alternating OR/XOR levels (CF 339D style),
 * rewritten to Strict SysY: no bitwise ops, no scanf/freopen.
 */

const int MAXN = 2048;
const int MAXM = 8192;
const int BITS = 16;

int n;
int m;
int nn;
int size;
int a[MAXN];
int sum[MAXM];

int pow2(int k) {
    int r;
    int i;
    r = 1;
    for (i = 0; i < k; i = i + 1) r = r * 2;
    return r;
}

int bit_or(int x, int y) {
    int res;
    int base;
    int i;
    int xb;
    int yb;
    int b;
    res = 0;
    base = 1;
    for (i = 0; i < BITS; i = i + 1) {
        xb = (x / base) % 2;
        yb = (y / base) % 2;
        b = 0;
        if (xb != 0 || yb != 0) b = 1;
        res = res + b * base;
        base = base * 2;
    }
    return res;
}

int bit_xor(int x, int y) {
    int res;
    int base;
    int i;
    int xb;
    int yb;
    int b;
    res = 0;
    base = 1;
    for (i = 0; i < BITS; i = i + 1) {
        xb = (x / base) % 2;
        yb = (y / base) % 2;
        b = 0;
        if (xb != yb) b = 1;
        res = res + b * base;
        base = base * 2;
    }
    return res;
}

void push_up(int o, int p) {
    int lch;
    int rch;
    lch = o * 2;
    rch = lch + 1;
    if (p % 2 == 1) sum[o] = bit_or(sum[lch], sum[rch]);
    else sum[o] = bit_xor(sum[lch], sum[rch]);
    return;
}

void build(int l, int r, int o, int p) {
    int mid;
    if (l == r) {
        sum[o] = a[l];
        return;
    }
    mid = (l + r) / 2;
    build(l, mid, o * 2, p - 1);
    build(mid + 1, r, o * 2 + 1, p - 1);
    push_up(o, p);
    return;
}

void update(int l, int r, int o, int pos, int p) {
    int mid;
    if (l == r) {
        sum[o] = a[l];
        return;
    }
    mid = (l + r) / 2;
    if (pos <= mid) update(l, mid, o * 2, pos, p - 1);
    else update(mid + 1, r, o * 2 + 1, pos, p - 1);
    push_up(o, p);
    return;
}

int main() {
    int i;
    int x;
    int y;

    nn = getint();
    m = getint();

    size = pow2(nn);
    for (i = 1; i <= size; i = i + 1) a[i] = getint();

    build(1, size, 1, nn);

    for (i = 0; i < m; i = i + 1) {
        x = getint();
        y = getint();
        a[x] = y;
        update(1, size, 1, x, nn);
        printf("%d\n", sum[1]);
    }
    return 0;
}
