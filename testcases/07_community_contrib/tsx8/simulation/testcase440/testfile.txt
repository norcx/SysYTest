/* Description:
 *   [Add description here]
 */
const int MAXN = 64;
const int MAXM = 128;
const int MAXQ = 64;
const int MAXS = 2048;

int Amax[MAXN];
int Ccnt[MAXN];
int Bsum[MAXN];
int parent[MAXN];
int compsize[MAXN];

int ex[MAXM];
int ey[MAXM];
int ev[MAXM];

int qlen[MAXQ];
int qv[MAXQ];
int qid[MAXQ];
int qstart[MAXQ];

int listMem[MAXS];
int listTot;

int ans0[MAXQ];
int ans1[MAXQ];

int vis[MAXN];
int timer;

int sumBAll;

int find_root(int x) {
  int stk[MAXN];
  int top;
  top = 0;
  for (; parent[x] != x; ) {
    top = top + 1;
    stk[top] = x;
    x = parent[x];
  }
  for (; top > 0; ) {
    parent[stk[top]] = x;
    top = top - 1;
  }
  return x;
}

void merge_set(int x, int y) {
  int rx;
  int ry;
  int t;
  rx = find_root(x);
  ry = find_root(y);
  if (rx == ry) {
    return;
  }
  if (compsize[rx] < compsize[ry]) {
    t = rx;
    rx = ry;
    ry = t;
  }
  parent[ry] = rx;

  if (Amax[rx] == Amax[ry]) {
    Ccnt[rx] = Ccnt[rx] + Ccnt[ry];
  } else {
    if (Amax[rx] < Amax[ry]) {
      Amax[rx] = Amax[ry];
      Ccnt[rx] = Ccnt[ry];
    }
  }
  Bsum[rx] = Bsum[rx] + Bsum[ry];
  compsize[rx] = compsize[rx] + compsize[ry];
}

void sort_edges(int m) {
  int i;
  int j;
  int tx;
  int ty;
  int tv;
  for (i = 1; i <= m; i = i + 1) {
    for (j = 1; j + 1 <= m; j = j + 1) {
      if (ev[j] > ev[j + 1]) {
        tx = ex[j];
        ty = ey[j];
        tv = ev[j];
        ex[j] = ex[j + 1];
        ey[j] = ey[j + 1];
        ev[j] = ev[j + 1];
        ex[j + 1] = tx;
        ey[j + 1] = ty;
        ev[j + 1] = tv;
      }
    }
  }
}

void sort_queries(int q) {
  int i;
  int j;
  int tlen;
  int tv;
  int tid;
  int ts;
  for (i = 1; i <= q; i = i + 1) {
    for (j = 1; j + 1 <= q; j = j + 1) {
      if (qv[j] > qv[j + 1]) {
        tlen = qlen[j];
        tv = qv[j];
        tid = qid[j];
        ts = qstart[j];
        qlen[j] = qlen[j + 1];
        qv[j] = qv[j + 1];
        qid[j] = qid[j + 1];
        qstart[j] = qstart[j + 1];
        qlen[j + 1] = tlen;
        qv[j + 1] = tv;
        qid[j + 1] = tid;
        qstart[j + 1] = ts;
      }
    }
  }
}

void solve_query(int idx) {
  int i;
  int p;
  int rp;
  int ansA;
  int ansB;
  int ansC;
  int start;
  int len;
  timer = timer + 1;

  ansA = 0;
  ansB = sumBAll;
  ansC = 0;

  start = qstart[idx];
  len = qlen[idx];
  for (i = 0; i < len; i = i + 1) {
    p = listMem[start + i];
    rp = find_root(p);
    if (vis[rp] != timer) {
      vis[rp] = timer;
      ansB = ansB - Bsum[rp];
      if (ansA == Amax[rp]) {
        ansC = ansC + Ccnt[rp];
      } else {
        if (ansA < Amax[rp]) {
          ansA = Amax[rp];
          ansC = Ccnt[rp];
        }
      }
    }
  }

  ans0[qid[idx]] = ansA * ansC;
  ans1[qid[idx]] = ansB;
}

int main() {
  int n;
  int m;
  int q;
  int i;
  int j;
  int k;
  int x;
  int y;
  int v;
  n = getint();
  m = getint();
  q = getint();

  sumBAll = 0;
  listTot = 0;
  timer = 0;

  for (i = 1; i <= n; i = i + 1) {
    Amax[i] = getint();
    Ccnt[i] = 1;
    parent[i] = i;
    compsize[i] = 1;
    vis[i] = 0;
  }

  for (i = 1; i <= n; i = i + 1) {
    Bsum[i] = getint();
    sumBAll = sumBAll + Bsum[i];
  }

  for (i = 1; i <= m; i = i + 1) {
    ex[i] = getint();
    ey[i] = getint();
    ev[i] = getint();
  }

  for (i = 1; i <= q; i = i + 1) {
    qid[i] = i;
    qlen[i] = getint();
    qv[i] = getint();
    qstart[i] = listTot;
    for (j = 0; j < qlen[i]; j = j + 1) {
      listMem[listTot] = getint();
      listTot = listTot + 1;
    }
  }

  sort_edges(m);
  sort_queries(q);

  j = 1;
  for (i = 1; i <= q; i = i + 1) {
    v = qv[i];
    for (; j <= m && ev[j] <= v; ) {
      merge_set(ex[j], ey[j]);
      j = j + 1;
    }
    solve_query(i);
  }

  for (i = 1; i <= q; i = i + 1) {
    printf("%d %d\n", ans0[i], ans1[i]);
  }
  return 0;
}
