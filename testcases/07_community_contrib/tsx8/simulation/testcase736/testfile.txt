/* Description:
 *   Converted from C++: segment tree + greedy after sorting by y.
 *   Input: n, m, c, then n triples (x, y, z).
 *   Output: total accepted amount.
 */

int treeL[65536];
int treeR[65536];
int treeMin[65536];
int treeLazy[65536];

int Ax[2048];
int Ay[2048];
int Az[2048];

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

int max2(int a, int b) {
    if (a > b) return a;
    return b;
}

void pushDown(int k) {
    if (treeLazy[k] != 0) {
        treeMin[k * 2] = treeMin[k * 2] + treeLazy[k];
        treeMin[k * 2 + 1] = treeMin[k * 2 + 1] + treeLazy[k];
        treeLazy[k * 2] = treeLazy[k * 2] + treeLazy[k];
        treeLazy[k * 2 + 1] = treeLazy[k * 2 + 1] + treeLazy[k];
        treeLazy[k] = 0;
    }
}

void rangeAdd(int root, int l, int r, int delta) {
    int mid;
    if (l == treeL[root] && r == treeR[root]) {
        treeMin[root] = treeMin[root] + delta;
        treeLazy[root] = treeLazy[root] + delta;
        return;
    }
    pushDown(root);
    mid = (treeL[root] + treeR[root]) / 2;
    if (l <= mid) rangeAdd(root * 2, l, min2(mid, r), delta);
    if (r > mid) rangeAdd(root * 2 + 1, max2(mid + 1, l), r, delta);
    treeMin[root] = min2(treeMin[root * 2], treeMin[root * 2 + 1]);
}

int rangeMin(int root, int l, int r) {
    int mid;
    int p;
    int q;
    if (l == treeL[root] && r == treeR[root]) return treeMin[root];
    pushDown(root);
    mid = (treeL[root] + treeR[root]) / 2;
    p = 1000000000;
    q = 1000000000;
    if (l <= mid) p = rangeMin(root * 2, l, min2(mid, r));
    if (r > mid) q = rangeMin(root * 2 + 1, max2(mid + 1, l), r);
    return min2(p, q);
}

int main() {
    int n;
    int m;
    int c;
    int i;
    int j;
    int base;
    int ans;
    int t;
    int mn;
    int delta;

    n = getint();
    m = getint();
    c = getint();

    base = 32767;

    for (i = 32768; i <= 65535; i = i + 1) {
        treeL[i] = i;
        treeR[i] = i;
        treeMin[i] = 0;
        treeLazy[i] = 0;
    }
    for (i = 32767; i >= 1; i = i - 1) {
        treeL[i] = treeL[i * 2];
        treeR[i] = treeR[i * 2 + 1];
        treeMin[i] = 0;
        treeLazy[i] = 0;
    }

    rangeAdd(1, base + 1, base + m, c);

    for (i = 1; i <= n; i = i + 1) {
        Ax[i] = getint();
        Ay[i] = getint();
        Az[i] = getint();
        Ay[i] = Ay[i] - 1;
    }

    for (i = 1; i <= n; i = i + 1) {
        for (j = i + 1; j <= n; j = j + 1) {
            if (Ay[j] < Ay[i]) {
                t = Ax[i];
                Ax[i] = Ax[j];
                Ax[j] = t;
                t = Ay[i];
                Ay[i] = Ay[j];
                Ay[j] = t;
                t = Az[i];
                Az[i] = Az[j];
                Az[j] = t;
            }
        }
    }

    ans = 0;
    for (i = 1; i <= n; i = i + 1) {
        mn = rangeMin(1, Ax[i] + base, Ay[i] + base);
        delta = mn;
        if (mn > Az[i]) delta = Az[i];
        rangeAdd(1, Ax[i] + base, Ay[i] + base, 0 - delta);
        ans = ans + delta;
    }

    printf("%d\n", ans);
    return 0;
}
