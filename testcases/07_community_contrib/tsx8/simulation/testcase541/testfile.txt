/*
  DP for inversion-count permutations (mod 10000), scaled to fit SysY limits.

  Input (in.txt): newline-separated integers:
    T
    n1
    m1
    n2
    m2
    ...
  Output:
    f[n][m] per line (mod 10000)
*/

const int LIM = 450;
const int W = 451;
const int MOD = 10000;

int f[203401];
int g[203401];

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

int main() {
    int i;
    int j;
    int k;
    int tmp;
    int prev;
    int T;
    int n;
    int m;
    int caseIdx;

    f[1 * W + 0] = 1;
    for (j = 0; j <= LIM; j = j + 1) {
        g[1 * W + j] = 1;
    }

    for (i = 2; i <= LIM; i = i + 1) {
        for (j = 0; j <= LIM; j = j + 1) {
            k = min2(j, i - 1);
            if (k == j) tmp = g[(i - 1) * W + j];
            else tmp = g[(i - 1) * W + j] - g[(i - 1) * W + (j - k - 1)];

            tmp = tmp % MOD;
            if (tmp < 0) tmp = tmp + MOD;

            f[i * W + j] = tmp;

            if (j == 0) g[i * W + j] = tmp;
            else {
                prev = g[i * W + (j - 1)];
                g[i * W + j] = (prev + tmp) % MOD;
            }
        }
    }

    T = getint();
    for (caseIdx = 0; caseIdx < T; caseIdx = caseIdx + 1) {
        n = getint();
        m = getint();
        printf("%d\n", f[n * W + m]);
    }
    return 0;
}
