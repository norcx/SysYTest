int tileEdge[36];
int lockPos[9];

int fac[10];

int distArr[362880];
int qArr[362880];
int qHead;
int qTail;

int permCur[9];
int permNext[9];

int usedNum[9];
int visEdge[36];
int usedColor[4];

int init_fac() {
    int i;
    fac[0] = 1;
    for (i = 1; i <= 9; i = i + 1) {
        fac[i] = fac[i - 1] * i;
    }
    return 0;
}

void decode_perm(int code) {
    int i;
    int j;
    int f;
    int k;
    int x;

    for (i = 0; i < 9; i = i + 1) {
        usedNum[i] = 0;
    }

    x = code;
    for (i = 0; i < 9; i = i + 1) {
        f = fac[8 - i];
        k = x / f;
        x = x - k * f;
        for (j = 0; j < 9; j = j + 1) {
            if (usedNum[j] == 0) {
                if (k == 0) {
                    permCur[i] = j;
                    usedNum[j] = 1;
                    j = 9;
                } else {
                    k = k - 1;
                }
            }
        }
    }
}

int encode_perm(int permArr[]) {
    int i;
    int j;
    int cnt;
    int code;

    for (i = 0; i < 9; i = i + 1) {
        usedNum[i] = 0;
    }

    code = 0;
    for (i = 0; i < 9; i = i + 1) {
        cnt = 0;
        for (j = 0; j < permArr[i]; j = j + 1) {
            if (usedNum[j] == 0) {
                cnt = cnt + 1;
            }
        }
        code = code + cnt * fac[8 - i];
        usedNum[permArr[i]] = 1;
    }

    return code;
}

int edge_color(int pos, int dir) {
    int tile;
    tile = permCur[pos];
    return tileEdge[tile * 4 + dir];
}

void dfs_edge(int pos, int dir, int color) {
    int idx;
    int row;
    int col;
    int npos;
    int ndir;
    int nidx;

    idx = pos * 4 + dir;
    visEdge[idx] = 1;

    if (dir == 0 || dir == 1) {
        nidx = pos * 4 + 2;
        if (visEdge[nidx] == 0 && edge_color(pos, 2) == color) {
            dfs_edge(pos, 2, color);
        }
        nidx = pos * 4 + 3;
        if (visEdge[nidx] == 0 && edge_color(pos, 3) == color) {
            dfs_edge(pos, 3, color);
        }
    } else {
        nidx = pos * 4 + 0;
        if (visEdge[nidx] == 0 && edge_color(pos, 0) == color) {
            dfs_edge(pos, 0, color);
        }
        nidx = pos * 4 + 1;
        if (visEdge[nidx] == 0 && edge_color(pos, 1) == color) {
            dfs_edge(pos, 1, color);
        }
    }

    row = pos / 3;
    col = pos - row * 3;

    if (dir == 0 && row > 0) {
        npos = pos - 3;
        ndir = 1;
        nidx = npos * 4 + ndir;
        if (visEdge[nidx] == 0 && edge_color(npos, ndir) == color) {
            dfs_edge(npos, ndir, color);
        }
    }
    if (dir == 1 && row < 2) {
        npos = pos + 3;
        ndir = 0;
        nidx = npos * 4 + ndir;
        if (visEdge[nidx] == 0 && edge_color(npos, ndir) == color) {
            dfs_edge(npos, ndir, color);
        }
    }
    if (dir == 2 && col > 0) {
        npos = pos - 1;
        ndir = 3;
        nidx = npos * 4 + ndir;
        if (visEdge[nidx] == 0 && edge_color(npos, ndir) == color) {
            dfs_edge(npos, ndir, color);
        }
    }
    if (dir == 3 && col < 2) {
        npos = pos + 1;
        ndir = 2;
        nidx = npos * 4 + ndir;
        if (visEdge[nidx] == 0 && edge_color(npos, ndir) == color) {
            dfs_edge(npos, ndir, color);
        }
    }
}

int judge_board() {
    int pos;
    int dir;
    int idx;
    int color;

    for (pos = 0; pos < 36; pos = pos + 1) {
        visEdge[pos] = 0;
    }
    for (pos = 0; pos < 4; pos = pos + 1) {
        usedColor[pos] = 0;
    }

    for (pos = 0; pos < 9; pos = pos + 1) {
        for (dir = 0; dir < 4; dir = dir + 1) {
            idx = pos * 4 + dir;
            if (visEdge[idx] == 0) {
                color = edge_color(pos, dir);
                if (usedColor[color] == 1) {
                    return 0;
                }
                usedColor[color] = 1;
                dfs_edge(pos, dir, color);
            }
        }
    }
    return 1;
}

void copy_perm() {
    int i;
    for (i = 0; i < 9; i = i + 1) {
        permNext[i] = permCur[i];
    }
}

void rotate_row_right(int r) {
    int p;
    int tmp;
    p = r * 3;
    tmp = permNext[p + 2];
    permNext[p + 2] = permNext[p + 1];
    permNext[p + 1] = permNext[p + 0];
    permNext[p + 0] = tmp;
}

void rotate_row_left(int r) {
    int p;
    int tmp;
    p = r * 3;
    tmp = permNext[p + 0];
    permNext[p + 0] = permNext[p + 1];
    permNext[p + 1] = permNext[p + 2];
    permNext[p + 2] = tmp;
}

void rotate_col_down(int c) {
    int tmp;
    tmp = permNext[c + 6];
    permNext[c + 6] = permNext[c + 3];
    permNext[c + 3] = permNext[c + 0];
    permNext[c + 0] = tmp;
}

void rotate_col_up(int c) {
    int tmp;
    tmp = permNext[c + 0];
    permNext[c + 0] = permNext[c + 3];
    permNext[c + 3] = permNext[c + 6];
    permNext[c + 6] = tmp;
}

int is_row_locked(int r) {
    int c;
    for (c = 0; c < 3; c = c + 1) {
        if (lockPos[r * 3 + c] == 1) {
            return 1;
        }
    }
    return 0;
}

int is_col_locked(int c) {
    int r;
    for (r = 0; r < 3; r = r + 1) {
        if (lockPos[r * 3 + c] == 1) {
            return 1;
        }
    }
    return 0;
}

int main() {
    int i;
    int code;
    int d;
    int r;
    int c;
    int locked;
    int nextCode;

    init_fac();

    for (i = 0; i < 9; i = i + 1) {
        tileEdge[i * 4 + 0] = getint();
        tileEdge[i * 4 + 1] = getint();
        tileEdge[i * 4 + 2] = getint();
        tileEdge[i * 4 + 3] = getint();
        lockPos[i] = getint();
    }

    for (i = 0; i < 362880; i = i + 1) {
        distArr[i] = -1;
    }

    qHead = 0;
    qTail = 0;
    distArr[0] = 0;
    qArr[qTail] = 0;
    qTail = qTail + 1;

    for (; qHead < qTail;) {
        code = qArr[qHead];
        qHead = qHead + 1;
        decode_perm(code);

        if (judge_board() == 1) {
            d = distArr[code] - 1;
            printf("%d\n", d);
            return 0;
        }

        d = distArr[code];

        for (r = 0; r < 3; r = r + 1) {
            locked = is_row_locked(r);
            if (locked == 0) {
                copy_perm();
                rotate_row_right(r);
                nextCode = encode_perm(permNext);
                if (distArr[nextCode] == -1) {
                    distArr[nextCode] = d + 1;
                    qArr[qTail] = nextCode;
                    qTail = qTail + 1;
                }

                copy_perm();
                rotate_row_left(r);
                nextCode = encode_perm(permNext);
                if (distArr[nextCode] == -1) {
                    distArr[nextCode] = d + 1;
                    qArr[qTail] = nextCode;
                    qTail = qTail + 1;
                }
            }
        }

        for (c = 0; c < 3; c = c + 1) {
            locked = is_col_locked(c);
            if (locked == 0) {
                copy_perm();
                rotate_col_down(c);
                nextCode = encode_perm(permNext);
                if (distArr[nextCode] == -1) {
                    distArr[nextCode] = d + 1;
                    qArr[qTail] = nextCode;
                    qTail = qTail + 1;
                }

                copy_perm();
                rotate_col_up(c);
                nextCode = encode_perm(permNext);
                if (distArr[nextCode] == -1) {
                    distArr[nextCode] = d + 1;
                    qArr[qTail] = nextCode;
                    qTail = qTail + 1;
                }
            }
        }
    }

    return 0;
}
