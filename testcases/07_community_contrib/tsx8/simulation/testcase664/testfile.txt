/* Strict SysY testcase: maxflow selection (Dinic). */
const int MAXV = 128;
const int MAXE = 4096;
const int INF = 1000000000;

int n, m, cnt, S, T;
int ru[MAXV];
int chu[MAXV];
int head[MAXV];
int cur[MAXV];
int dis[MAXV];
int q[MAXV];

int e_to[MAXE];
int e_flow[MAXE];
int e_next[MAXE];

int min2(int a, int b) {
  if (a < b) return a;
  return b;
}

int rev_edge(int idx) {
  if (idx % 2 == 0) return idx + 1;
  return idx - 1;
}

void add_edge(int x, int y, int flow) {
  cnt = cnt + 1;
  e_to[cnt] = y;
  e_flow[cnt] = flow;
  e_next[cnt] = head[x];
  head[x] = cnt;

  cnt = cnt + 1;
  e_to[cnt] = x;
  e_flow[cnt] = 0;
  e_next[cnt] = head[y];
  head[y] = cnt;
}

int bfs() {
  int i;
  int qh;
  int qt;
  int now;
  int ei;
  int nn;

  for (i = 1; i <= T; i = i + 1) dis[i] = -1;
  dis[S] = 0;

  qh = 0;
  qt = 0;
  q[qt] = S;
  qt = qt + 1;

  for (; qh < qt;) {
    now = q[qh];
    qh = qh + 1;
    for (ei = head[now]; ei != 0; ei = e_next[ei]) {
      nn = e_to[ei];
      if (e_flow[ei] > 0 && dis[nn] == -1) {
        dis[nn] = dis[now] + 1;
        q[qt] = nn;
        qt = qt + 1;
      }
    }
  }

  if (dis[T] != -1) return 1;
  return 0;
}

int dfs(int now, int last) {
  int flow;
  int f;
  int i;
  int nn;
  int use;
  int r;

  if (now == T) return last;
  if (last == 0) return 0;

  flow = 0;
  i = cur[now];
  for (; i != 0;) {
    nn = e_to[i];
    if (dis[nn] == dis[now] + 1 && e_flow[i] > 0) {
      use = min2(last, e_flow[i]);
      f = dfs(nn, use);
      if (f > 0) {
        flow = flow + f;
        last = last - f;
        e_flow[i] = e_flow[i] - f;
        r = rev_edge(i);
        e_flow[r] = e_flow[r] + f;
        if (last == 0) {
          cur[now] = i;
          return flow;
        }
      }
    }
    i = e_next[i];
    cur[now] = i;
  }
  return flow;
}

void dinic() {
  int i;
  for (; bfs();) {
    for (i = 1; i <= T; i = i + 1) cur[i] = head[i];
    dfs(S, INF);
  }
}

int main() {
  int i;
  int x;
  int y;
  int z;

  n = getint();
  m = getint();
  S = n + 1;
  T = S + 1;

  cnt = 1;

  for (i = 1; i <= T; i = i + 1) {
    ru[i] = 0;
    chu[i] = 0;
    head[i] = 0;
    cur[i] = 0;
    dis[i] = 0;
  }

  for (i = 1; i <= m; i = i + 1) {
    x = getint();
    y = getint();
    z = getint();
    ru[y] = ru[y] + 1;
    chu[x] = chu[x] + 1;
    add_edge(y, z, 1);
  }

  for (i = 1; i <= n; i = i + 1) {
    if (ru[i] > chu[i]) add_edge(S, i, ru[i] - chu[i]);
    if (chu[i] > ru[i]) add_edge(i, T, chu[i] - ru[i]);
  }

  dinic();

  for (i = 1; i <= m; i = i + 1) {
    if (e_flow[i * 2 + 1] != 0)
      printf("1");
    else
      printf("0");
  }
  printf("\n");
  return 0;
}
