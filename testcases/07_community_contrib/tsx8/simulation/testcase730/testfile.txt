/* Description:
 *   Dinic maxflow on a small bus-line style network.
 */

const int MAXV = 600;
const int MAXE = 20000;
const int INF = 1000000000;

int n;
int m;
int K;
int S;
int T;
int ans;

int head[MAXV];
int dis[MAXV];
int cur[MAXV];
int q[MAXV];
int h;
int t;

int to[MAXE];
int flow[MAXE];
int nxt[MAXE];
int cnt;

int min2(int a, int b) {
    if (a < b) return a;
    return b;
}

int rev_edge(int idx) {
    if (idx % 2 == 0) return idx - 1;
    return idx + 1;
}

void add_edge(int x, int y, int f) {
    cnt = cnt + 1;
    to[cnt] = y;
    flow[cnt] = f;
    nxt[cnt] = head[x];
    head[x] = cnt;

    cnt = cnt + 1;
    to[cnt] = x;
    flow[cnt] = 0;
    nxt[cnt] = head[y];
    head[y] = cnt;
    return;
}

int bfs() {
    int i;
    for (i = 1; i <= T; i = i + 1) dis[i] = -1;
    h = 0;
    t = 0;
    t = t + 1;
    q[t] = S;
    dis[S] = 0;

    for (; h < t; ) {
        h = h + 1;
        int now;
        int ei;
        now = q[h];
        ei = head[now];
        for (; ei != 0; ei = nxt[ei]) {
            int nn;
            nn = to[ei];
            if (dis[nn] != -1) {
            } else if (flow[ei] > 0) {
                dis[nn] = dis[now] + 1;
                t = t + 1;
                q[t] = nn;
            }
        }
    }

    if (dis[T] != -1) return 1;
    return 0;
}

int dfs(int now, int last) {
    if (now == T || last == 0) return last;

    int ei;
    int pushed;
    ei = cur[now];
    pushed = 0;

    for (; ei != 0; ) {
        int nn;
        nn = to[ei];
        if (dis[nn] == dis[now] + 1 && flow[ei] > 0) {
            int f;
            f = dfs(nn, min2(last, flow[ei]));
            if (f > 0) {
                int ri;
                ri = rev_edge(ei);
                flow[ei] = flow[ei] - f;
                flow[ri] = flow[ri] + f;
                last = last - f;
                pushed = pushed + f;
                if (last == 0) break;
            }
        }
        ei = nxt[ei];
        cur[now] = ei;
    }

    if (pushed == 0) dis[now] = -1;
    return pushed;
}

void dinic() {
    for (; bfs() != 0; ) {
        int i;
        for (i = 1; i <= T; i = i + 1) cur[i] = head[i];

        int pushed;
        pushed = dfs(S, INF);
        for (; pushed > 0; ) {
            ans = ans + pushed;
            pushed = dfs(S, INF);
        }
    }
    return;
}

int main() {
    int i;
    int x;
    int y;
    int z;

    cnt = 0;
    ans = 0;

    K = getint();
    n = getint();
    m = getint();

    S = n * 2 + 1;
    T = S + 1;

    for (i = 1; i <= T; i = i + 1) head[i] = 0;

    for (i = 1; i <= K; i = i + 1) {
        x = getint();
        y = getint();
        z = getint();
        if (z > m) z = m;
        add_edge(S, x, z);
        add_edge(y - 1 + n, T, z);
    }

    for (i = 1; i < n; i = i + 1) {
        add_edge(i + n, i + 1, INF);
        add_edge(i, i + n, m);
    }

    dinic();
    printf("%d\n", ans);
    return 0;
}
