/* Description:
 *   Range-sum queries on arithmetic progressions with point updates.
 *   Ops are encoded as integers:
 *     1 x y : query sum_{i=y, i+=x} a[i] (0 <= y < x)
 *     2 x y : set a[x] = y (1 <= x <= n)
 */

const int MAXN = 2000;
const int MAXSQRT = 50;
const int STRIDE = 51; /* MAXSQRT + 1 */

int n;
int m;
int a[2001];
int f[2601]; /* (MAXSQRT + 1) * (MAXSQRT + 1) */

int main() {
    int i;
    int j;
    int q;
    int op;
    int x;
    int y;
    int limit;
    int r;
    int tmp;
    int delta;

    n = getint();
    m = getint();

    a[0] = 0;
    for (i = 1; i <= n; i = i + 1) {
        a[i] = getint();
    }

    limit = 0;
    for (i = 1; i * i <= n; i = i + 1) {
        limit = i;
    }

    for (i = 1; i <= limit; i = i + 1) {
        for (j = 1; j <= n; j = j + 1) {
            r = j % i;
            f[i * STRIDE + r] = f[i * STRIDE + r] + a[j];
        }
    }

    for (q = 0; q < m; q = q + 1) {
        op = getint();
        x = getint();
        y = getint();

        if (op == 1) {
            if (x * x <= n) {
                r = y % x;
                printf("%d\n", f[x * STRIDE + r]);
            } else {
                tmp = 0;
                for (i = y; i <= n; i = i + x) {
                    tmp = tmp + a[i];
                }
                printf("%d\n", tmp);
            }
        } else {
            delta = y - a[x];
            for (i = 1; i * i <= n; i = i + 1) {
                r = x % i;
                f[i * STRIDE + r] = f[i * STRIDE + r] + delta;
            }
            a[x] = y;
        }
    }

    return 0;
}
