/* Description:
 * Converted from UVa 12161 (Ironman Race in Treeland).
 * Given a tree (input gives edge count n) and a cost limit m,
 * find the maximum number of edges on any path with total cost <= m.
 *
 * Strict SysY notes:
 * - Uses only int / void, for-loops, getint(), printf().
 * - Uses a scaled-down brute force (DFS from every node) suitable for testcase sizes.
 */

const int MAXV = 256;
const int MAXE = 512;

int head[MAXV];
int to[MAXE];
int wt[MAXE];
int nxt[MAXE];
int edge_cnt;

int m;
int best;

void init_graph() {
  int i;
  for (i = 0; i < MAXV; i = i + 1) {
    head[i] = -1;
  }
  edge_cnt = 0;
}

void add_edge(int u, int v, int w) {
  to[edge_cnt] = v;
  wt[edge_cnt] = w;
  nxt[edge_cnt] = head[u];
  head[u] = edge_cnt;
  edge_cnt = edge_cnt + 1;
}

void dfs_from(int u, int parent, int cost, int step) {
  int ei;
  if (cost <= m) {
    if (step > best) {
      best = step;
    }
  } else {
    return;
  }

  for (ei = head[u]; ei != -1; ei = nxt[ei]) {
    int v;
    int w;
    v = to[ei];
    w = wt[ei];
    if (v != parent) {
      dfs_from(v, u, cost + w, step + 1);
    }
  }
  return;
}

int main() {
  int T;
  int tc;
  T = getint();

  for (tc = 1; tc <= T; tc = tc + 1) {
    int n_edges;
    int i;
    int max_node;

    n_edges = getint();
    m = getint();

    init_graph();
    max_node = 1;

    for (i = 0; i < n_edges; i = i + 1) {
      int u;
      int v;
      int w;
      u = getint();
      v = getint();
      w = getint();

      add_edge(u, v, w);
      add_edge(v, u, w);

      if (u > max_node) {
        max_node = u;
      }
      if (v > max_node) {
        max_node = v;
      }
    }

    best = 0;
    for (i = 1; i <= max_node; i = i + 1) {
      dfs_from(i, 0, 0, 0);
    }

    printf("Case %d: %d\n", tc, best);
  }

  return 0;
}
