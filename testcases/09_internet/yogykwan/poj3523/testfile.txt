/*
 * Converted from: POJ 3523 "The Morning after Halloween"
 * Model: up to 3 ghosts move simultaneously on a grid; no collisions; no swaps.
 * Input (integers only):
 *   Repeated testcases:
 *     n
 *     m
 *     k
 *     then m*n integers: ASCII codes of grid chars (# . A..Z a..z)
 *   Terminator: n == 0 (still provide m,k, e.g. 0 0 0).
 * Output:
 *   Minimal steps for each testcase (one per line).
 */

const int MAX_CELL = 256;
const int MAX_K = 3;
const int MAX_STATE = 20000;

int n;
int m;
int k;

int wall[MAX_CELL];
int sx[MAX_K];
int sy[MAX_K];
int tx[MAX_K];
int ty[MAX_K];

int dx[5];
int dy[5];

int dista[MAX_STATE];
int q[MAX_STATE];

int encode_state(int pos[], int kk, int base) {
  int id;
  int i;
  id = 0;
  i = 0;
  for (i = 0; i < kk; i = i + 1) {
    id = id * base + pos[i];
  }
  return id;
}

void decode_state(int id, int pos[], int kk, int base) {
  int i;
  i = kk - 1;
  for (i = kk - 1; i >= 0; i = i - 1) {
    pos[i] = id % base;
    id = id / base;
  }
}

int is_legal_transition(int oldPos[], int newPos[], int kk) {
  int i;
  int j;
  for (i = 0; i < kk; i = i + 1) {
    for (j = i + 1; j < kk; j = j + 1) {
      if (newPos[i] == newPos[j]) return 0;
      if (oldPos[i] == newPos[j] && oldPos[j] == newPos[i]) return 0;
    }
  }
  return 1;
}

int bfs_min_steps(int startPos[], int targetPos[], int kk, int base) {
  int total;
  int i;
  int head;
  int tail;
  int startId;
  int targetId;
  int oldPos[MAX_K];
  int newPos[MAX_K];
  int curId;
  int curD;

  total = 1;
  for (i = 0; i < kk; i = i + 1) total = total * base;
  if (total > MAX_STATE) return -1;

  for (i = 0; i < total; i = i + 1) dista[i] = -1;

  startId = encode_state(startPos, kk, base);
  targetId = encode_state(targetPos, kk, base);
  if (startId == targetId) return 0;

  head = 0;
  tail = 0;
  dista[startId] = 0;
  q[tail] = startId;
  tail = tail + 1;

  for (; head < tail; ) {
    curId = q[head];
    head = head + 1;
    curD = dista[curId];

    decode_state(curId, oldPos, kk, base);

    if (kk == 1) {
      int a0;
      a0 = 0;
      for (a0 = 0; a0 < 5; a0 = a0 + 1) {
        int p0;
        int r0;
        int c0;
        int nr0;
        int nc0;
        p0 = oldPos[0];
        r0 = p0 / n;
        c0 = p0 - r0 * n;
        nr0 = r0 + dx[a0];
        nc0 = c0 + dy[a0];
        if (nr0 < 0 || nr0 >= m) {
        } else if (nc0 < 0 || nc0 >= n) {
        } else {
          int np0;
          np0 = nr0 * n + nc0;
          if (wall[np0] == 0) {
            newPos[0] = np0;
            if (is_legal_transition(oldPos, newPos, kk) == 1) {
              int nid;
              nid = encode_state(newPos, kk, base);
              if (dista[nid] == -1) {
                dista[nid] = curD + 1;
                if (nid == targetId) return dista[nid];
                q[tail] = nid;
                tail = tail + 1;
              }
            }
          }
        }
      }
    } else if (kk == 2) {
      int a0;
      int a1;
      a0 = 0;
      for (a0 = 0; a0 < 5; a0 = a0 + 1) {
        for (a1 = 0; a1 < 5; a1 = a1 + 1) {
          int ok;
          ok = 1;

          int p0;
          int r0;
          int c0;
          int nr0;
          int nc0;
          p0 = oldPos[0];
          r0 = p0 / n;
          c0 = p0 - r0 * n;
          nr0 = r0 + dx[a0];
          nc0 = c0 + dy[a0];
          if (nr0 < 0 || nr0 >= m) ok = 0;
          if (nc0 < 0 || nc0 >= n) ok = 0;

          int p1;
          int r1;
          int c1;
          int nr1;
          int nc1;
          p1 = oldPos[1];
          r1 = p1 / n;
          c1 = p1 - r1 * n;
          nr1 = r1 + dx[a1];
          nc1 = c1 + dy[a1];
          if (nr1 < 0 || nr1 >= m) ok = 0;
          if (nc1 < 0 || nc1 >= n) ok = 0;

          if (ok == 1) {
            int np0;
            int np1;
            np0 = nr0 * n + nc0;
            np1 = nr1 * n + nc1;
            if (wall[np0] == 0 && wall[np1] == 0) {
              newPos[0] = np0;
              newPos[1] = np1;
              if (is_legal_transition(oldPos, newPos, kk) == 1) {
                int nid;
                nid = encode_state(newPos, kk, base);
                if (dista[nid] == -1) {
                  dista[nid] = curD + 1;
                  if (nid == targetId) return dista[nid];
                  q[tail] = nid;
                  tail = tail + 1;
                }
              }
            }
          }
        }
      }
    } else {
      int a0;
      int a1;
      int a2;
      a0 = 0;
      for (a0 = 0; a0 < 5; a0 = a0 + 1) {
        for (a1 = 0; a1 < 5; a1 = a1 + 1) {
          for (a2 = 0; a2 < 5; a2 = a2 + 1) {
            int ok;
            ok = 1;

            int p0;
            int r0;
            int c0;
            int nr0;
            int nc0;
            p0 = oldPos[0];
            r0 = p0 / n;
            c0 = p0 - r0 * n;
            nr0 = r0 + dx[a0];
            nc0 = c0 + dy[a0];
            if (nr0 < 0 || nr0 >= m) ok = 0;
            if (nc0 < 0 || nc0 >= n) ok = 0;

            int p1;
            int r1;
            int c1;
            int nr1;
            int nc1;
            p1 = oldPos[1];
            r1 = p1 / n;
            c1 = p1 - r1 * n;
            nr1 = r1 + dx[a1];
            nc1 = c1 + dy[a1];
            if (nr1 < 0 || nr1 >= m) ok = 0;
            if (nc1 < 0 || nc1 >= n) ok = 0;

            int p2;
            int r2;
            int c2;
            int nr2;
            int nc2;
            p2 = oldPos[2];
            r2 = p2 / n;
            c2 = p2 - r2 * n;
            nr2 = r2 + dx[a2];
            nc2 = c2 + dy[a2];
            if (nr2 < 0 || nr2 >= m) ok = 0;
            if (nc2 < 0 || nc2 >= n) ok = 0;

            if (ok == 1) {
              int np0;
              int np1;
              int np2;
              np0 = nr0 * n + nc0;
              np1 = nr1 * n + nc1;
              np2 = nr2 * n + nc2;
              if (wall[np0] == 0 && wall[np1] == 0 && wall[np2] == 0) {
                newPos[0] = np0;
                newPos[1] = np1;
                newPos[2] = np2;
                if (is_legal_transition(oldPos, newPos, kk) == 1) {
                  int nid;
                  nid = encode_state(newPos, kk, base);
                  if (dista[nid] == -1) {
                    dista[nid] = curD + 1;
                    if (nid == targetId) return dista[nid];
                    q[tail] = nid;
                    tail = tail + 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return -1;
}

int main() {
  dx[0] = 0;
  dy[0] = 0;
  dx[1] = -1;
  dy[1] = 0;
  dx[2] = 0;
  dy[2] = 1;
  dx[3] = 1;
  dy[3] = 0;
  dx[4] = 0;
  dy[4] = -1;

  for (;;) {
    int i;
    int j;
    int base;
    int code;
    int startPos[MAX_K];
    int targetPos[MAX_K];

    n = getint();
    m = getint();
    k = getint();
    if (n == 0) break;

    for (i = 0; i < k; i = i + 1) {
      sx[i] = 0;
      sy[i] = 0;
      tx[i] = 0;
      ty[i] = 0;
    }

    for (i = 0; i < m * n; i = i + 1) wall[i] = 0;

    for (i = 0; i < m; i = i + 1) {
      for (j = 0; j < n; j = j + 1) {
        int idx;
        idx = i * n + j;
        code = getint();
        if (code == 35) {
          wall[idx] = 1;
        } else {
          wall[idx] = 0;
          if (code >= 65 && code <= 90) {
            int t;
            t = code - 65;
            if (t >= 0 && t < k) {
              tx[t] = i;
              ty[t] = j;
            }
          } else if (code >= 97 && code <= 122) {
            int s;
            s = code - 97;
            if (s >= 0 && s < k) {
              sx[s] = i;
              sy[s] = j;
            }
          }
        }
      }
    }

    base = m * n;
    for (i = 0; i < k; i = i + 1) {
      startPos[i] = sx[i] * n + sy[i];
      targetPos[i] = tx[i] * n + ty[i];
    }

    printf("%d\n", bfs_min_steps(startPos, targetPos, k, base));
  }

  return 0;
}
