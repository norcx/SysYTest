/* Description:
 *   Converted from AOJ 1070 (FIMO sequence) reference solution.
 *   Maintains two halves of a dynamic sequence and supports:
 *   - append distinct numbers
 *   - delete median
 *   - query min/max of left/right halves, and indexed queries on their monotonic structures
 *
 *   Input format (one integer per line):
 *     n
 *     op [arg]
 *     ...
 *     (repeat for n ops)
 *   Repeat testcases until a terminating n = 0.
 */

const int MAXN = 20000;

int la[MAXN];
int ls[MAXN];
int lb[MAXN];
int ra[MAXN];
int rs[MAXN];
int rb[MAXN];

int la1, la2, ls1, ls2, lb1, lb2;
int ra1, ra2, rs1, rs2, rb1, rb2;
int m;

void left_push_back(int x) {
  la[la2] = x;
  la2 = la2 + 1;

  if (ls2 == ls1 || ls[ls2 - 1] > x) {
    ls[ls2] = x;
    ls2 = ls2 + 1;
  }
  if (lb2 == lb1 || lb[lb2 - 1] < x) {
    lb[lb2] = x;
    lb2 = lb2 + 1;
  }
  return;
}

void right_push_back(int x) {
  ra[ra2] = x;
  ra2 = ra2 + 1;

  for (; rs2 > rs1 && rs[rs2 - 1] > x;) {
    rs2 = rs2 - 1;
  }
  rs[rs2] = x;
  rs2 = rs2 + 1;

  for (; rb2 > rb1 && rb[rb2 - 1] < x;) {
    rb2 = rb2 - 1;
  }
  rb[rb2] = x;
  rb2 = rb2 + 1;
  return;
}

int right_pop_front() {
  int v;
  v = ra[ra1];
  if (v == rs[rs1]) rs1 = rs1 + 1;
  if (v == rb[rb1]) rb1 = rb1 + 1;
  ra1 = ra1 + 1;
  return v;
}

int left_pop_back() {
  int v;
  v = la[la2 - 1];
  if (v == ls[ls2 - 1]) ls2 = ls2 - 1;
  if (v == lb[lb2 - 1]) lb2 = lb2 - 1;
  la2 = la2 - 1;
  return v;
}

void f0_add() {
  int x;
  int y;
  x = getint();
  if (m == 0) {
    left_push_back(x);
  } else {
    right_push_back(x);
    if (m % 2 == 0) {
      y = right_pop_front();
      left_push_back(y);
    }
  }
  m = m + 1;
  return;
}

void f1_del() {
  int x;
  int y;
  x = left_pop_back();
  printf("%d\n", x);
  if (m % 2 == 0) {
    y = right_pop_front();
    left_push_back(y);
  }
  m = m - 1;
  return;
}

void f2_ls() {
  int x;
  x = ls[ls2 - 1];
  printf("%d\n", x);
  return;
}

void f3_rs() {
  int x;
  x = rs[rs1];
  printf("%d\n", x);
  return;
}

void f4_ls_() {
  int i;
  int x;
  i = getint();
  x = ls[ls2 - i];
  printf("%d\n", x);
  return;
}

void f5_rs_() {
  int i;
  int x;
  i = getint();
  x = rs[rs1 + i - 1];
  printf("%d\n", x);
  return;
}

void f6_lb() {
  int x;
  x = lb[lb2 - 1];
  printf("%d\n", x);
  return;
}

void f7_rb() {
  int x;
  x = rb[rb1];
  printf("%d\n", x);
  return;
}

void f8_lb_() {
  int i;
  int x;
  i = getint();
  x = lb[lb2 - i];
  printf("%d\n", x);
  return;
}

void f9_rb_() {
  int i;
  int x;
  i = getint();
  x = rb[rb1 + i - 1];
  printf("%d\n", x);
  return;
}

int main() {
  int n;
  int k;
  int t;

  for (n = getint(); n != 0; n = getint()) {
    m = 0;
    la1 = 0;
    la2 = 0;
    ls1 = 0;
    ls2 = 0;
    lb1 = 0;
    lb2 = 0;
    ra1 = 0;
    ra2 = 0;
    rs1 = 0;
    rs2 = 0;
    rb1 = 0;
    rb2 = 0;

    for (k = 0; k < n; k = k + 1) {
      t = getint();
      if (t == 0) {
        f0_add();
      } else if (t == 1) {
        f1_del();
      } else if (t == 2) {
        f2_ls();
      } else if (t == 3) {
        f3_rs();
      } else if (t == 4) {
        f4_ls_();
      } else if (t == 5) {
        f5_rs_();
      } else if (t == 6) {
        f6_lb();
      } else if (t == 7) {
        f7_rb();
      } else if (t == 8) {
        f8_lb_();
      } else {
        f9_rb_();
      }
    }
    printf("end\n");
  }
  return 0;
}
