// test30 - 综合压力测试：大数组+深递归+多函数
int g_data[500];
int g_temp[500];
int g_result[100];

void init_data(int arr[], int n, int seed) {
    int i;
    int val = seed;
    for (i = 0; i < n; i = i + 1) {
        arr[i] = val;
        val = (val * 1103515245 + 12345) % 1000;  // 简单伪随机
    }
}

int partition_count(int arr[], int n, int pivot) {
    int local_less[200];
    int local_greater[200];
    int less_count = 0;
    int greater_count = 0;
    int i;
    
    for (i = 0; i < n; i = i + 1) {
        if (arr[i] < pivot) {
            if (less_count < 200) {
                local_less[less_count] = arr[i];
                less_count = less_count + 1;
            }
        } else {
            if (greater_count < 200) {
                local_greater[greater_count] = arr[i];
                greater_count = greater_count + 1;
            }
        }
    }
    
    return less_count * 1000 + greater_count;
}

int recursive_process(int arr[], int start, int end, int depth) {
    int local_buffer[50];
    int i;
    int sum = 0;
    
    if (depth <= 0) {
        for (i = start; i < end; i = i + 1) {
            sum = sum + arr[i];
        }
        return sum;
    }
    
    if (end - start <= 1) {
        return arr[start];
    }
    
    // 使用局部缓冲区
    int count = 0;
    for (i = start; i < end; i = i + 1) {
        if (count < 50) {
            local_buffer[count] = arr[i];
            count = count + 1;
        }
    }
    
    int mid = (start + end) / 2;
    int left_sum = recursive_process(arr, start, mid, depth - 1);
    int right_sum = recursive_process(arr, mid, end, depth - 1);
    
    // 验证local_buffer
    for (i = 0; i < count; i = i + 1) {
        if (local_buffer[i] != arr[start + i]) {
            printf("Buffer corrupted at depth %d\n", depth);
        }
    }
    
    return left_sum + right_sum;
}

int main() {
    int i;
    
    // 初始化
    init_data(g_data, 500, 42);
    
    printf("First 10 elements: ");
    for (i = 0; i < 10; i = i + 1) {
        printf("%d ", g_data[i]);
    }
    printf("\n");
    
    // 分区计数
    int pc = partition_count(g_data, 100, 500);
    printf("Partition count (pivot=500): less=%d, greater=%d\n", pc / 1000, pc % 1000);
    
    // 递归处理
    int sum = recursive_process(g_data, 0, 100, 10);
    printf("Recursive sum (depth 10): %d\n", sum);
    
    sum = recursive_process(g_data, 0, 200, 15);
    printf("Recursive sum (depth 15): %d\n", sum);
    
    return 0;
}
